/*
 * Original author: Henry Sanford <henrytsanford .at. u.washington.edu>,
 *                  MacCoss Lab, Department of Genome Sciences, UW
 *
 * Copyright 2023 University of Washington - Seattle, WA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows.Forms;
using Newtonsoft.Json;
using pwiz.Common.SystemUtil;
using pwiz.Common.SystemUtil.Caching;
using pwiz.Skyline.Controls.GroupComparison;
using pwiz.Skyline.Controls.SeqNode;
using pwiz.Skyline.Model;
using pwiz.Skyline.Model.AuditLog;
using pwiz.Skyline.Model.Databinding;
using pwiz.Skyline.Model.Databinding.Entities;
using pwiz.Skyline.Model.DocSettings;
using pwiz.Skyline.Model.GroupComparison;
using pwiz.Skyline.Model.Hibernate;
using pwiz.Skyline.Properties;
using pwiz.Skyline.Util;
using ZedGraph;
using pwiz.Skyline.Util.Extensions;
using Peptide = pwiz.Skyline.Model.Databinding.Entities.Peptide;
using pwiz.Skyline.Model.Proteome;

namespace pwiz.Skyline.Controls.Graphs
{
    public abstract class SummaryRelativeAbundanceGraphPane : SummaryBarGraphPaneBase, ILayoutPersistable
    {
        private const int MAX_SELECTED = 100;
        private ReplicateCachingReceiver<GraphDataParameters, GraphData> _graphDataReceiver;
        protected GraphData _graphData;
        private readonly List<LabeledPoint> _labeledPoints; // Labeled points generated by the graph itself
        // Persisted layout kept between graph refreshes
        private static List<LabeledPoint.PointLayout> _labelsLayout = new List<LabeledPoint.PointLayout>();
        private static RelativeAbundanceFormatting _formattingOverride;
        private int _progressValue = -1;
        private Stopwatch _progressStopwatch;
        private const int PROGRESS_INITIAL_DELAY_MS = 300; // Wait before showing progress bar
        private const int PROGRESS_UPDATE_INTERVAL_MS = 100; // Throttle progress UI updates after first show
        private NodeTip _toolTip;
        protected SummaryRelativeAbundanceGraphPane(GraphSummary graphSummary)
            : base(graphSummary)
        {
            var xAxisTitle =
                Helpers.PeptideToMoleculeTextMapper.Translate(GraphsResources.SummaryIntensityGraphPane_SummaryIntensityGraphPane_Protein_Rank,
                    graphSummary.DocumentUIContainer.DocumentUI.DocumentType);
            XAxis.Title.Text = xAxisTitle;
            XAxis.Type = AxisType.Linear;
            XAxis.Scale.Max = GraphSummary.DocumentUIContainer.DocumentUI.MoleculeGroupCount;
            _labeledPoints = new List<LabeledPoint>();

            AxisChangeEvent += this_AxisChangeEvent;
            Settings.Default.PropertyChanged += OnLabelOverlapPropertyChange;
            graphSummary.GraphControl.LabelDragEvent += zedGraphControl_LabelDragComplete;
            graphSummary.GraphControl.EditModifierKeys = Keys.Alt;  // enable label drag with Alt key
            if (graphSummary.LabelLayoutString != null)
            {
                try
                {
                    _labelsLayout =
                        JsonConvert.DeserializeObject<List<LabeledPoint.PointLayout>>(graphSummary.LabelLayoutString);
                }
                catch(Exception e)   // if we cannot read the saved layout we will generate a new one.
                {
                    Trace.Write(@"Cannot deserialize label layout. Error message: " + e.Message);
                }
            }
            // ReSharper disable once VirtualMemberCallInConstructor
            var receiver = GraphDataProducer.RegisterCustomer(GraphSummary, ProductAvailableAction);
            _graphDataReceiver = new ReplicateCachingReceiver<GraphDataParameters, GraphData>(
                receiver,
                CleanCacheForIncrementalUpdates);
            _graphDataReceiver.ProgressChange += UpdateProgressHandler;
        }

        /// <summary>
        /// Smart cache cleaning for incremental updates. Determines which cached entries are stale.
        ///
        /// For index -1 (all replicates mode): keeps entry if MeasuredResults reference unchanged.
        /// For specific replicate index: keeps entry if that ChromatogramSet still exists by reference.
        /// Also removes entries if quantification settings have changed.
        ///
        /// Entries that survive cleaning but have a different document reference will be used
        /// as prior data for incremental updates.
        /// </summary>
        private static IEnumerable<int> CleanCacheForIncrementalUpdates(
            SrmDocument currentDoc, IReadOnlyDictionary<int, SrmDocument> cachedEntries)
        {
            var keysToRemove = new List<int>();
            var currentResults = currentDoc.Settings.MeasuredResults;
            var currentChromatograms = currentResults?.Chromatograms;

            // Build map of current ChromatogramSets by identity for O(1) lookup
            var currentChromById = currentChromatograms?.ToDictionary(c => c.Id.GlobalIndex);

            foreach (var entry in cachedEntries)
            {
                var cacheKey = entry.Key;
                var cachedDoc = entry.Value;

                // Check if document identity changed (different file opened)
                if (!ReferenceEquals(cachedDoc.Id, currentDoc.Id))
                {
                    keysToRemove.Add(cacheKey);
                    continue;
                }

                // Check if quantification settings are compatible
                if (!currentDoc.Settings.HasEqualQuantificationSettings(cachedDoc.Settings))
                {
                    keysToRemove.Add(cacheKey);
                    continue;
                }

                // For median normalization, any target change affects all abundances because the
                // median is recalculated from all values. Require exact document match.
                var normMethod = currentDoc.Settings.PeptideSettings.Quantification.NormalizationMethod;
                if (Equals(normMethod, NormalizationMethod.EQUALIZE_MEDIANS) &&
                    !ReferenceEquals(cachedDoc, currentDoc))
                {
                    keysToRemove.Add(cacheKey);
                    continue;
                }

                // Check if the relevant ChromatogramSet still exists
                if (cacheKey == -1)
                {
                    // All replicates mode: check if MeasuredResults itself is unchanged
                    if (!ReferenceEquals(cachedDoc.Settings.MeasuredResults, currentResults))
                    {
                        keysToRemove.Add(cacheKey);
                    }
                }
                else
                {
                    // Specific replicate: get the ChromatogramSet that was cached
                    var cachedResults = cachedDoc.Settings.MeasuredResults;

                    // Defensive: if cache entry is invalid (shouldn't happen), remove it
                    if (cachedResults == null || cacheKey < 0 || cacheKey >= cachedResults.Chromatograms.Count)
                    {
                        keysToRemove.Add(cacheKey);
                        continue;
                    }

                    var cachedChromSet = cachedResults.Chromatograms[cacheKey];

                    // Two-phase check: find by identity, then check if unchanged
                    bool stillValid = currentChromById != null &&
                                      currentChromById.TryGetValue(cachedChromSet.Id.GlobalIndex, out var currentChromSet) &&
                                      ReferenceEquals(currentChromSet, cachedChromSet);
                    if (!stillValid)
                    {
                        keysToRemove.Add(cacheKey);
                    }
                }
            }

            return keysToRemove;
        }

        private PaneProgressBar ProgressBar { get; set; }
        private void ProductAvailableAction()
        {
            UpdateProgressHandler();
            UpdateGraph(false);
        }
        private void UpdateProgressHandler()
        {
            if (_graphDataReceiver.IsProcessing())
            {
                var newProgressValue = _graphDataReceiver.GetProgressValue();
                if (newProgressValue != _progressValue)
                {
                    if (_progressStopwatch == null)
                    {
                        // First progress update - start timing but don't show yet
                        _progressStopwatch = Stopwatch.StartNew();
                        _progressValue = newProgressValue;
                        return;
                    }

                    bool progressBarShowing = ProgressBar != null;
                    int throttleMs = progressBarShowing ? PROGRESS_UPDATE_INTERVAL_MS : PROGRESS_INITIAL_DELAY_MS;

                    if (_progressStopwatch.ElapsedMilliseconds < throttleMs)
                    {
                        return; // Skip this update, not enough time has passed
                    }

                    _progressStopwatch.Restart();
                    ProgressBar ??= new PaneProgressBar(this);
                    ProgressBar.UpdateProgress(newProgressValue);
                    _progressValue = newProgressValue;
                }
            }
            else
            {
                ProgressBar?.Dispose();
                ProgressBar = null;
                _progressValue = -1;
                _progressStopwatch = null;
            }
        }



        public override void OnClose(EventArgs e)
        {
            base.OnClose(e);
            AxisChangeEvent -= this_AxisChangeEvent;
            Settings.Default.PropertyChanged -= OnLabelOverlapPropertyChange;
            GraphSummary.GraphControl.LabelDragEvent -= zedGraphControl_LabelDragComplete;
            _toolTip?.HideTip();
            _toolTip?.Dispose();
        }

        string ILayoutPersistable.GetPersistentString()
        {
            return JsonConvert.SerializeObject(_labelsLayout);
        }

        protected override int SelectedIndex
        {
            get { return _graphData != null ? _graphData.SelectedIndex : -1; }
        }

        protected override IdentityPath GetIdentityPath(CurveItem curveItem, int barIndex)
        {
            var pointData = (GraphPointData)curveItem[barIndex].Tag;
            return pointData.IdentityPath;
        }

        public void ShowFormattingDialog()
        {
            using var dlg = new VolcanoPlotFormattingDlg(this,
                GraphSummary.DocumentUIContainer.DocumentUI.Settings.DataSettings.RelativeAbundanceFormatting.ColorRows,
                _graphData?.PointPairList.Select(pointPair => (GraphPointData)pointPair.Tag).ToArray() ?? Array.Empty<GraphPointData>(),
                UpdateFormatting);
            if (dlg.ShowDialog(Program.MainWindow) == DialogResult.OK)
            {
                if (_formattingOverride != null)
                {
                    Program.MainWindow.ModifyDocument(string.Empty,
                        doc =>
                        {
                            if (Equals(_formattingOverride, doc.Settings.DataSettings.RelativeAbundanceFormatting))
                            { 
                                return doc;
                            }
                            return doc.ChangeSettings(doc.Settings.ChangeDataSettings(
                                doc.Settings.DataSettings.ChangeRelativeAbundanceFormatting(_formattingOverride)));
                        },
                        AuditLogEntry.SettingsLogFunction);
                }
            }

            if (_formattingOverride != null)
            {
                _formattingOverride = null;
                Program.MainWindow.UpdatePeakAreaGraph();
            }
        }

        private void UpdateFormatting(IEnumerable<MatchRgbHexColor> colorRows)
        {
            var formatting = _formattingOverride ?? GraphSummary.DocumentUIContainer.DocumentUI.Settings.DataSettings.RelativeAbundanceFormatting;
            formatting = formatting.ChangeColorRows(colorRows);
            if (!Equals(formatting, _formattingOverride))
            {
                _formattingOverride = formatting;
                Program.MainWindow.UpdatePeakAreaGraph();
            }
        }

        /// <summary>
        /// Detect changes in settings shared with <see cref="FoldChangeVolcanoPlot"/> right-click menu
        /// </summary>
        public void OnLabelOverlapPropertyChange(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(Settings.Default.GroupComparisonAvoidLabelOverlap))
            {
                try
                {
                    Settings.Default.PropertyChanged -= OnLabelOverlapPropertyChange;
                    Settings.Default.GroupComparisonSuspendLabelLayout = false;
                }
                finally
                {
                    Settings.Default.PropertyChanged += OnLabelOverlapPropertyChange;
                }
                _labelsLayout = null;
                GraphSummary.UpdateUI();
            }
            else if (e.PropertyName == nameof(Settings.Default.GroupComparisonSuspendLabelLayout))
            {
                if (!Settings.Default.GroupComparisonSuspendLabelLayout)
                {
                    AdjustLabelSpacings(_labeledPoints);
                    _labelsLayout = GraphSummary.GraphControl.GraphPane.Layout?.PointsLayout;
                    GraphSummary.GraphControl.Invalidate();
                }
            }
        }

        public override bool HandleMouseDownEvent(ZedGraphControl sender, MouseEventArgs mouseEventArgs)
        {
            // if Alt button is pressed this is a label drag event, no need to change the selection
            if (Control.ModifierKeys == GraphSummary.GraphControl.EditModifierKeys)
            {
                _toolTip?.HideTip();
                return false;
            }

            var ctrl = Control.ModifierKeys.HasFlag(Keys.Control); //CONSIDER allow override of modifier keys?
            int iNearest;
            var axis = GetNearestXAxis(sender, mouseEventArgs);
            if (axis != null)
            {
                iNearest = (int)axis.Scale.ReverseTransform(mouseEventArgs.X) - 1;
                if (iNearest < 0)
                {
                    return false;
                }

                var path = _graphData.XScalePaths.ElementAtOrDefault(iNearest);
                if (path != null)
                {
                    ChangeSelection(path, ctrl);
                }

                return true;
            }

            IdentityPath identityPath = FindIdentityUnderMouse(mouseEventArgs);
            if (identityPath == null)
                return false;
            ChangeSelection(identityPath, ctrl);
            return true;
        }

        private IdentityPath FindIdentityUnderMouse(MouseEventArgs eventArgs)
        {
            IdentityPath identityPath = null;
            var point = new Point(eventArgs.X, eventArgs.Y);
            if (FindNearestPoint(point, out var nearestCurve, out var iNearest))
            {
                identityPath = GetIdentityPath(nearestCurve, iNearest);
            }
            else if (GraphSummary.GraphControl.GraphPane.EnableLabelLayout)
            {
                var labPoint = GraphSummary.GraphControl.GraphPane.OverLabel(point, out var isOverBoundary);
                if (labPoint != null)
                {
                    if (!isOverBoundary)
                        identityPath = (labPoint.Point.Tag as GraphPointData)?.IdentityPath;
                }
            }
            else
            {
                using (var g = Graphics.FromHwnd(IntPtr.Zero))
                {
                    GraphSummary.GraphControl.GraphPane.FindNearestObject(point, g, out var nearestObj, out _);
                    if (nearestObj is TextObj nearestText)
                    {
                        var labels = _labeledPoints.FindAll(lp => lp.Label.Equals(nearestText));
                        if (labels.Any())
                            identityPath = (labels.First().Point.Tag as GraphPointData)?.IdentityPath;
                    }
                }
            }

            return identityPath;
        }

        public override bool HandleMouseMoveEvent(ZedGraphControl sender, MouseEventArgs e)
        {
            var identity = FindIdentityUnderMouse(e);
            if (identity != null)
            {
                sender.Cursor = Cursors.Hand;
                var goalPoint = _graphData.PointPairList.FirstOrDefault(pp => identity.Equals((pp.Tag as GraphPointData)?.IdentityPath));
                if (_toolTip == null)
                    _toolTip = new NodeTip(this) { Parent = GraphSummary.GraphControl };
                _toolTip.SetTipProvider(new RelativeAbundanceTipProvider(goalPoint), new Rectangle(e.Location, new Size()), e.Location);
                return true;
            }
            else
            {
                _toolTip?.HideTip();
                return base.HandleMouseMoveEvent(sender, e);
            }
        }

        private void ChangeSelection(IdentityPath identityPath, bool ctrl)
        {
            if (ctrl)
            {
                DotPlotUtil.MultiSelect(Program.MainWindow, identityPath);
            }
            else
            {
                GraphSummary.StateProvider.SelectedPath = identityPath;
            }
        }

        protected override void ChangeSelection(int selectedIndex, IdentityPath identityPath)
        {
            if (0 <= selectedIndex && selectedIndex < _graphData.XScalePaths.Length)
            {
                GraphSummary.StateProvider.SelectedPath = identityPath;
            }
        }

        public override void UpdateGraph(bool selectionChanged)
        {
            PeptideGroupDocNode selectedProtein = null;
            var selectedTreeNode = GraphSummary.StateProvider.SelectedNode as SrmTreeNode;
            if (selectedTreeNode != null)
            {
                var proteinTreeNode = selectedTreeNode.GetNodeOfType<PeptideGroupTreeNode>();
                if (proteinTreeNode != null)
                {
                    selectedProtein = proteinTreeNode.DocNode;
                }
            }

            var document = GraphSummary.DocumentUIContainer.DocumentUI;
            var graphSettings = GraphSettings.FromSettings();
            var showReplicate = RTLinearRegressionGraphPane.ShowReplicate;
            var resultsIndex = GraphSummary.ResultsIndex;
            var oldGraphData = _graphData;

            // Get prior cached data for this replicate to enable incremental updates
            var cacheKey = showReplicate == ReplicateDisplay.single ? resultsIndex : -1;

            // Clean stale cache entries BEFORE retrieving prior data for incremental updates.
            // This ensures we don't use stale prior data when settings have changed.
            _graphDataReceiver.CleanStaleEntries(document);
            _graphDataReceiver.TryGetCachedResult(cacheKey, out var priorGraphData);

            GraphData newGraphData;
            try
            {
                if (!_graphDataReceiver.TryGetProduct(
                        new GraphDataParameters(document, graphSettings, showReplicate, resultsIndex, priorGraphData),
                        out newGraphData))
                {
                    // Keep showing previous graph while calculating new data (stale-while-revalidate)
                    // Set initial X-axis scale estimate based on document counts
                    if (_graphData == null)
                    {
                        int estimatedCount = graphSettings.AreaProteinTargets
                            ? document.MoleculeGroupCount
                            : document.MoleculeCount;
                        XAxis.Scale.Max = estimatedCount;
                        AxisChange();
                    }
                    return;
                }
            }
            catch (Exception e)
            {
                ExceptionUtil.DisplayOrReportException(Program.MainWindow, e);
                return;
            }

            // Clear only when new data is ready for seamless transition
            Clear();
            _labeledPoints.Clear();
            _graphData = newGraphData;
            // Find selected index - quick O(n) scan on UI thread
            _graphData.SelectedIndex = _graphData.FindSelectedIndex(selectedProtein);
            bool dataChanged = _graphData.MinY != oldGraphData?.MinY || _graphData.MaxY != oldGraphData?.MaxY;

            // For proper z-order, add the selected points, then the matched points, then the unmatched points
            var selectedPoints = new PointPairList();
            var unmatchedPoints = new List<PointPair>();
            if (ShowSelection)
            {
                var selectedPaths = DotPlotUtil.FindSelectedPaths(Program.MainWindow.SequenceTree.SelectedPaths,
                    _graphData.PointPairList.Select(point => point.Tag).OfType<GraphPointData>()
                        .Select(graphPointData => graphPointData.IdentityPath)).ToHashSet();

                foreach (var point in _graphData.PointPairList) 
                {
                    var pointData = (GraphPointData)point.Tag;
                    if (selectedPaths.Contains(pointData.IdentityPath) && selectedPoints.Count < MAX_SELECTED)
                    {
                        selectedPoints.Add(point);
                    }
                    else
                    {
                        unmatchedPoints.Add(point);
                    }
                }
                AddPoints(new PointPairList(selectedPoints), GraphSummary.ColorSelected, DotPlotUtil.PointSizeToFloat(PointSize.large), true, PointSymbol.Circle, true);
            }
            else
            {
                unmatchedPoints.AddRange(_graphData.PointPairList);
            }

            // For each valid match expression specified by the user
            var colorRows = (_formattingOverride ?? document.Settings.DataSettings.RelativeAbundanceFormatting).ColorRows;
            foreach (var colorRow in colorRows.Where(r => r.MatchExpression != null))
            {
                var matchedPoints = new List<PointPair>();
                foreach (var point in unmatchedPoints)
                {
                    var pointData = (GraphPointData)point.Tag;
                    if (colorRow.MatchExpression.Matches(document, pointData.Protein, pointData.Peptide, null, null))
                    {
                        matchedPoints.Add(point);
                    }
                }

                if (matchedPoints.Any())
                {
                    AddPoints(new PointPairList(matchedPoints), colorRow.Color, DotPlotUtil.PointSizeToFloat(colorRow.PointSize), colorRow.Labeled, colorRow.PointSymbol);
                    unmatchedPoints = unmatchedPoints.Except(matchedPoints).ToList();
                }
            }
            AddPoints(new PointPairList(unmatchedPoints), Color.Gray, DotPlotUtil.PointSizeToFloat(PointSize.normal), false, PointSymbol.Circle);
            if(dataChanged || Settings.Default.RelativeAbundanceLogScale != YAxis.Scale.IsLog)
                UpdateAxes();
            if (Settings.Default.GroupComparisonAvoidLabelOverlap)
            {
                AdjustLabelSpacings(_labeledPoints, _labelsLayout);
                _labelsLayout = GraphSummary.GraphControl.GraphPane.Layout?.PointsLayout;
            }
            else
            {
                EnableLabelLayout = false;
                DotPlotUtil.AdjustLabelLocations(_labeledPoints, GraphSummary.GraphControl.GraphPane.YAxis.Scale,
                    GraphSummary.GraphControl.GraphPane.Rect.Height);
            }
            GraphSummary.GraphControl.Invalidate();
        }

        public bool IsComplete
        {
            get
            {
                // Error means we're "done" (no further processing will occur)
                if (_graphDataReceiver.HasError)
                    return true;

                if (!_graphDataReceiver.TryGetCurrentProduct(out var product))
                    return false;

                var currentDoc = GraphSummary.DocumentUIContainer.DocumentUI;
                var currentSettings = GraphSettings.FromSettings();

                // Verify receiver's product matches current state
                if (!ReferenceEquals(product.Document, currentDoc) ||
                    !Equals(product.GraphSettings, currentSettings))
                    return false;

                // Verify _graphData has been updated (ProductAvailableAction callback has run)
                // This prevents race where receiver has product but _graphData is still stale
                return _graphData != null &&
                       ReferenceEquals(_graphData.Document, currentDoc) &&
                       Equals(_graphData.GraphSettings, currentSettings);
            }
        }

        /// <summary>
        /// Returns true only when processing completed successfully (no errors).
        /// Use this in tests to wait for successful completion and fail fast on errors.
        /// </summary>
        public bool IsSuccessfullyComplete => !_graphDataReceiver.HasError && IsComplete;

        /// <summary>
        /// Number of nodes whose values were reused from the prior cache during incremental update.
        /// Zero when full calculation was performed or no graph data is available.
        /// </summary>
        public int CachedNodeCount => _graphData?.CachedNodeCount ?? 0;

        /// <summary>
        /// Number of nodes whose values were calculated from scratch.
        /// Equals total node count when full calculation was performed.
        /// </summary>
        public int RecalculatedNodeCount => _graphData?.RecalculatedNodeCount ?? 0;

        private void this_AxisChangeEvent(GraphPane pane)
        {
            if (Settings.Default.GroupComparisonAvoidLabelOverlap)
            {
                if (!Settings.Default.GroupComparisonSuspendLabelLayout)
                {
                    AdjustLabelSpacings(_labeledPoints);
                    _labelsLayout = GraphSummary.GraphControl.GraphPane.Layout?.PointsLayout;
                }
                else
                {
                    AdjustLabelSpacings(_labeledPoints, _labelsLayout);
                    _labelsLayout = GraphSummary.GraphControl.GraphPane.Layout?.PointsLayout;
                    //UpdateConnectors();
                }
            }
        }

        private void AddPoints(PointPairList points, Color color, float size, bool labeled, PointSymbol pointSymbol, bool selected = false)
        {
            if (points.Count == 0)
            {
                return;
            }
            var symbolType = DotPlotUtil.PointSymbolToSymbolType(pointSymbol);

            LineItem lineItem;
            if (DotPlotUtil.HasOutline(pointSymbol))
            {
                lineItem = new LineItem(null, points, Color.Black, symbolType)
                {
                    Line = { IsVisible = false },
                    Symbol = { Border = { IsVisible = false }, Fill = new Fill(color), Size = size, IsAntiAlias = true }
                };
            }
            else
            {
                lineItem = new LineItem(null, points, Color.Black, symbolType)
                {
                    Line = { IsVisible = false },
                    Symbol = { Border = { IsVisible = true, Color = color }, Size = size, IsAntiAlias = true }
                };
            }

            if (labeled)
            {
                foreach (var point in points)
                {
                    var pointData = point.Tag as GraphPointData;
                    if (pointData == null)
                    {
                        continue;
                    }
                    var label = DotPlotUtil.CreateLabel(point, pointData.Protein, pointData.Peptide, color, size);
                    _labeledPoints.Add(new LabeledPoint(selected, pointData.IdentityPath) {Point = point, Label = label, Curve = lineItem });
                    GraphObjList.Add(label);
                }
            }
            CurveList.Add(lineItem);
        }

        protected abstract Producer<GraphDataParameters, GraphData> GraphDataProducer { get; }

        protected virtual void UpdateAxes()
        {
            if (GraphSummary.DocumentUIContainer.DocumentUI.HasSmallMolecules)
            {
                XAxis.Title.Text = GraphsResources.SummaryRelativeAbundanceGraphPane_UpdateAxes_Molecule_Rank;
            }
            else
            {
                XAxis.Title.Text = Settings.Default.AreaProteinTargets ? GraphsResources.SummaryIntensityGraphPane_SummaryIntensityGraphPane_Protein_Rank : GraphsResources.AreaPeptideGraphPane_UpdateAxes_Peptide_Rank;
            }
            const double xAxisGrace = 0;
            XAxis.Scale.MaxGrace = xAxisGrace;
            XAxis.Scale.MinGrace = xAxisGrace;
            YAxis.Scale.MinGrace = xAxisGrace;
            YAxis.Scale.MaxGrace = xAxisGrace;
            YAxis.Scale.MaxAuto = true;
            YAxis.Scale.MinAuto = true;
            XAxis.Scale.MaxAuto = true;
            XAxis.Scale.MinAuto = true;

            if (CurveList.FirstOrDefault() is LineItem curve)
            {
                // if markers are overlapping leave a little space between the X axis and the first marker
                if(curve.Symbol.Size * _graphData.PointPairList.Count > Chart.Rect.Width)
                    XAxis.Scale.Min = -(_graphData.PointPairList.Last().X - _graphData.PointPairList.First().X) * 0.02;
            }
            if (Settings.Default.RelativeAbundanceLogScale )
            {
                YAxis.Title.Text = TextUtil.SpaceSeparate(GraphsResources.SummaryPeptideGraphPane_UpdateAxes_Log, YAxis.Title.Text);
                YAxis.Type = AxisType.Log;
            }
            else
            {
                YAxis.Type = AxisType.Linear;
                if (_graphData.MinY.HasValue)
                {
                    if (!IsZoomed && !YAxis.Scale.MinAuto)
                        YAxis.Scale.MinAuto = true;
                }
                else
                {
                    YAxis.Scale.MinAuto = false;
                    FixedYMin = YAxis.Scale.Min = 0;
                    YAxis.Scale.Max = _graphData.MaxY * 1.05;
                }
            }
            var aggregateOp = GraphValues.AggregateOp.FromCurrentSettings();
            if (aggregateOp.Cv)
            {
                YAxis.Title.Text = aggregateOp.AnnotateTitle(YAxis.Title.Text);
            }

            if (!_graphData.MinY.HasValue && aggregateOp.Cv)
            {
                if (_graphData.MaxCvSetting != 0)
                {
                    YAxis.Scale.MaxAuto = false;
                    YAxis.Scale.Max = _graphData.MaxCvSetting;
                }
                else if (!IsZoomed && !YAxis.Scale.MaxAuto)
                {
                    YAxis.Scale.MaxAuto = true;
                }
            }
            else if (_graphData.MaxValueSetting != 0 || _graphData.MinValueSetting != 0)
            {
                if (_graphData.MaxValueSetting != 0)
                {
                    YAxis.Scale.MaxAuto = false;
                    YAxis.Scale.Max = _graphData.MaxValueSetting;
                }
                if (_graphData.MinValueSetting != 0)
                {
                    YAxis.Scale.MinAuto = false;
                    YAxis.Scale.Min = _graphData.MinValueSetting;
                    if (!_graphData.MinY.HasValue)
                        FixedYMin = YAxis.Scale.Min;
                }
            }

            AxisChange();
        }

        private static bool ContainsStandards(PeptideGroupDocNode nodeGroupPep)
        {
            return nodeGroupPep.Children.Cast<PeptideDocNode>().Any(IsStandard);
        }

        private static bool IsStandard(PeptideDocNode pepDocNode)
        {
            return pepDocNode.GlobalStandardType != null;
        }

        public void OnSuspendLayout(object sender, EventArgs eventArgs)
        {
            Settings.Default.GroupComparisonSuspendLabelLayout = !Settings.Default.GroupComparisonSuspendLabelLayout;
        }
        private bool zedGraphControl_LabelDragComplete(ZedGraphControl sender, MouseEventArgs mouseEvent)
        {
            _labelsLayout = GraphSummary.GraphControl.GraphPane.Layout?.PointsLayout;
            return true;
        }


        public abstract class GraphData : Immutable, ICachingResult
        {
            protected GraphData(GraphDataParameters parameters, ProductionMonitor productionMonitor)
            {
                Document = parameters.Document;
                GraphSettings = parameters.GraphSettings;
                ShowReplicate = parameters.ShowReplicate;
                ResultsIndex = parameters.ResultsIndex;
                AggregateOp = GraphValues.AggregateOp.FromCurrentSettings();

                if (parameters.PriorGraphData != null)
                {
                    // Incremental update: merge with prior data
                    // The caller (CleanCacheForIncrementalUpdates) has already validated that the
                    // prior data is from the same document identity with compatible settings
                    CalcDataPositionsIncremental(parameters.PriorGraphData, productionMonitor);
                    WasFullCalculation = false;
                }
                else
                {
                    // Full calculation
                    CalcDataPositionsFull(productionMonitor);
                    WasFullCalculation = true;
                }
            }

            /// <summary>
            /// Full calculation: build all points from scratch, sort, assign positions.
            /// </summary>
            private void CalcDataPositionsFull(ProductionMonitor productionMonitor)
            {
                var schema = SkylineDataSchema.MemoryDataSchema(Document, SkylineDataSchema.GetLocalizedSchemaLocalizer());
                bool anyMolecules = Document.HasSmallMolecules;
                var listPoints = new List<GraphPointData>();
                var moleculeGroups = GetFilteredMoleculeGroups();
                int moleculeCount = moleculeGroups.Sum(group => group.MoleculeCount);
                int iMolecule = 0;

                for (int iMoleculeGroup = 0; iMoleculeGroup < moleculeGroups.Count; iMoleculeGroup++)
                {
                    productionMonitor.CancellationToken.ThrowIfCancellationRequested();
                    var moleculeGroup = moleculeGroups[iMoleculeGroup];
                    if (GraphSettings.AreaProteinTargets && !anyMolecules)
                    {
                        productionMonitor.SetProgress(50 * iMoleculeGroup / moleculeGroups.Count);
                        var path = new IdentityPath(IdentityPath.ROOT, moleculeGroup.PeptideGroup);
                        var protein = new Protein(schema, path);
                        listPoints.Add(new GraphPointData(protein));
                    }
                    else
                    {
                        foreach (var nodePep in moleculeGroup.Molecules)
                        {
                            productionMonitor.CancellationToken.ThrowIfCancellationRequested();
                            productionMonitor.SetProgress(50 * iMolecule / moleculeCount);
                            iMolecule++;
                            var pepPath = new IdentityPath(moleculeGroup.PeptideGroup, nodePep.Peptide);
                            var peptide = new Peptide(schema, pepPath);
                            listPoints.Add(new GraphPointData(peptide));
                        }
                    }
                }

                productionMonitor.SetProgress(60);
                CalcDataPositions(listPoints, productionMonitor);

                // Full calculation: all nodes were calculated from scratch
                CachedNodeCount = 0;
                RecalculatedNodeCount = PointPairList?.Count ?? 0;
            }

            /// <summary>
            /// Get molecule groups filtered by current graph settings.
            /// </summary>
            private List<PeptideGroupDocNode> GetFilteredMoleculeGroups()
            {
                bool anyMolecules = Document.HasSmallMolecules;
                return Document.MoleculeGroups.Where(moleculeGroup =>
                {
                    if (GraphSettings.ExcludePeptideLists && !anyMolecules && moleculeGroup.IsPeptideList)
                        return false;
                    if (GraphSettings.ExcludeStandards && ContainsStandards(moleculeGroup))
                        return false;
                    return true;
                }).ToList();
            }

            /// <summary>
            /// Incremental update: use prior data to avoid full re-sort.
            /// Complexity: O(n + k log k) where k is the number of changed nodes.
            /// </summary>
            private void CalcDataPositionsIncremental(GraphData priorData, ProductionMonitor productionMonitor)
            {
                var schema = SkylineDataSchema.MemoryDataSchema(Document, SkylineDataSchema.GetLocalizedSchemaLocalizer());
                int? resultIndex = ShowReplicate == ReplicateDisplay.single ? (int?)ResultsIndex : null;
                var moleculeGroups = GetFilteredMoleculeGroups();

                // Step 1: Build map of new doc nodes by identity for two-phase change detection
                productionMonitor.SetProgress(10);
                var newDocNodes = BuildNewDocNodeMap(moleculeGroups, productionMonitor);

                // Step 2: Partition prior data into unchanged vs changed (identity match + ReferenceEquals)
                productionMonitor.SetProgress(30);
                var unchanged = PartitionPriorData(priorData, newDocNodes, productionMonitor);

                // Build set of unchanged keys to pass to CalculateChangedPoints
                var unchangedKeys = new HashSet<int>(unchanged.Select(u => u.pos.DocNode.Id.GlobalIndex));

                // Step 3: Calculate values for new/changed nodes (skip only truly unchanged nodes)
                productionMonitor.SetProgress(50);
                var changedPoints = CalculateChangedPoints(moleculeGroups, unchangedKeys, schema, resultIndex, productionMonitor);

                // Steps 4-5: Sort changed and merge with unchanged
                productionMonitor.SetProgress(70);
                MergeSortedLists(unchanged, changedPoints, productionMonitor);

                // Assertion: verify all filtered nodes are in the final result
                Assume.AreEqual(newDocNodes.Count, _nodePositions.Count);
            }

            /// <summary>
            /// Build a map of doc nodes by identity (GlobalIndex) for the new document.
            /// In protein mode, maps protein GlobalIndex to protein. In peptide mode, maps peptide GlobalIndex to peptide.
            /// Used for two-phase change detection: first match by identity, then check ReferenceEquals.
            /// </summary>
            private Dictionary<int, DocNode> BuildNewDocNodeMap(List<PeptideGroupDocNode> moleculeGroups, ProductionMonitor productionMonitor)
            {
                bool proteinMode = GraphSettings.AreaProteinTargets;
                int estimatedCount = proteinMode
                    ? moleculeGroups.Count
                    : moleculeGroups.Sum(g => g.MoleculeCount);

                IEnumerable<DocNode> nodes = proteinMode
                    ? moleculeGroups
                    : moleculeGroups.SelectMany(g => g.Molecules.Cast<DocNode>());

                var newDocNodes = new Dictionary<int, DocNode>(estimatedCount);
                foreach (var node in nodes)
                {
                    productionMonitor.CancellationToken.ThrowIfCancellationRequested();
                    newDocNodes[node.Id.GlobalIndex] = node;
                }
                return newDocNodes;
            }

            /// <summary>
            /// Partition prior data to find unchanged nodes (same identity AND same reference).
            /// Uses two-phase change detection: match by identity (GlobalIndex), then check ReferenceEquals.
            /// Returns unchanged list in sorted order (by Y descending, preserving prior PointPairList order).
            /// </summary>
            private List<(PointPair point, NodePosition pos)>
                PartitionPriorData(GraphData priorData, Dictionary<int, DocNode> newDocNodes, ProductionMonitor productionMonitor)
            {
                var unchanged = new List<(PointPair point, NodePosition pos)>(priorData.NodePositions.Count);

                // Build array indexed by PointPairList position for sorted iteration
                var positionsByIndex = new NodePosition?[priorData.PointPairList.Count];
                foreach (var kvp in priorData.NodePositions)
                {
                    positionsByIndex[kvp.Value.Index] = kvp.Value;
                }

                // Iterate in sorted order (PointPairList is sorted by Y descending)
                for (int i = 0; i < priorData.PointPairList.Count; i++)
                {
                    productionMonitor.CancellationToken.ThrowIfCancellationRequested();
                    var pos = positionsByIndex[i];
                    if (!pos.HasValue)
                        continue; // Skip holes (shouldn't happen, but be safe)

                    var priorNodeKey = pos.Value.DocNode.Id.GlobalIndex;

                    // Two-phase change detection:
                    // 1. Match by identity (GlobalIndex) - like finding a database row by ID
                    // 2. Check ReferenceEquals - if same reference, entire subtree is unchanged
                    if (newDocNodes.TryGetValue(priorNodeKey, out var newNode) &&
                        ReferenceEquals(newNode, pos.Value.DocNode) && 
                        !AlwaysRecalculate(newNode))
                    {
                        // Same identity AND same reference - truly unchanged
                        unchanged.Add((priorData.PointPairList[i], pos.Value));
                    }
                    // Nodes with identity missing or reference changed will be recalculated
                }

                return unchanged;
            }

            /// <summary>
            /// Returns true if the area should be recalculated whenever the document has changed
            /// despite <see cref="SrmSettings.HasEqualQuantificationSettings"/> being true.
            /// </summary>
            private bool AlwaysRecalculate(DocNode newNode)
            {
                // If the normalization method was overridden, then assume the area might have changed.
                if (newNode is PeptideDocNode peptideDocNode)
                {
                    if (null != peptideDocNode.NormalizationMethod)
                    {
                        return true;
                    }
                }
                else if (newNode is PeptideGroupDocNode peptideGroupDocNode)
                {
                    if (peptideGroupDocNode.Molecules.Any(molecule => null != molecule.NormalizationMethod))
                    {
                        return true;
                    }
                }
                return false;
            }

            /// <summary>
            /// Calculate Y values for new or changed nodes.
            /// In protein mode, creates Protein entities. In peptide mode, creates Peptide entities.
            /// </summary>
            private List<(PointPair point, DocNode docNode)> CalculateChangedPoints(
                List<PeptideGroupDocNode> moleculeGroups,
                HashSet<int> unchangedKeys,
                SkylineDataSchema schema,
                int? resultIndex,
                ProductionMonitor productionMonitor)
            {
                bool proteinMode = GraphSettings.AreaProteinTargets;
                var changedPoints = new List<(PointPair point, DocNode docNode)>();
                double maxY = 0;
                var minY = double.MaxValue;

                foreach (var moleculeGroup in moleculeGroups)
                {
                    productionMonitor.CancellationToken.ThrowIfCancellationRequested();

                    if (proteinMode)
                    {
                        var nodeKey = moleculeGroup.Id.GlobalIndex;
                        // Skip only if truly unchanged (same identity AND same reference)
                        if (unchangedKeys.Contains(nodeKey))
                            continue;

                        // This is a new or changed protein - calculate its value
                        var path = new IdentityPath(IdentityPath.ROOT, moleculeGroup.PeptideGroup);
                        var protein = new Protein(schema, path);
                        var pointData = new GraphPointData(protein);
                        var pointPair = CreatePointPair(pointData, ref maxY, ref minY, resultIndex);
                        changedPoints.Add((pointPair, moleculeGroup));
                    }
                    else
                    {
                        // Peptide mode - need parent context for IdentityPath
                        foreach (var molecule in moleculeGroup.Molecules)
                        {
                            var nodeKey = molecule.Id.GlobalIndex;
                            // Skip only if truly unchanged (same identity AND same reference)
                            if (unchangedKeys.Contains(nodeKey))
                                continue;

                            // This is a new or changed peptide - calculate its value
                            var path = new IdentityPath(moleculeGroup.PeptideGroup, molecule.Peptide);
                            var peptide = new Peptide(schema, path);
                            var pointData = new GraphPointData(peptide);
                            var pointPair = CreatePointPair(pointData, ref maxY, ref minY, resultIndex);
                            changedPoints.Add((pointPair, molecule));
                        }
                    }
                }

                // Sort by Y descending (typically small list - k items where k << n)
                changedPoints.Sort((a, b) => CompareYValues(a.point, b.point));

                return changedPoints;
            }

            /// <summary>
            /// Merge unchanged list with changed list into final sorted output.
            /// Both lists must already be sorted by Y descending.
            /// </summary>
            private void MergeSortedLists(
                List<(PointPair point, NodePosition pos)> unchanged,
                List<(PointPair point, DocNode docNode)> changed,
                ProductionMonitor productionMonitor)
            {
                // Pre-allocate output structures
                int totalCount = unchanged.Count + changed.Count;
                var pointPairList = new PointPairList();
                var xscalePaths = new List<IdentityPath>(totalCount);
                var identityToIndex = new Dictionary<int, int>(totalCount);
                var nodePositions = new Dictionary<int, NodePosition>(totalCount);

                // Track min/max Y
                double maxY = 0;
                var minY = double.MaxValue;

                // Merge with two pointers
                int iUnchanged = 0, iChanged = 0;
                int outputIndex = 0;

                productionMonitor.SetProgress(85);
                while (iUnchanged < unchanged.Count || iChanged < changed.Count)
                {
                    productionMonitor.CancellationToken.ThrowIfCancellationRequested();
                    PointPair sourcePoint;
                    DocNode docNode;

                    // Pick the larger Y value (descending sort)
                    if (iChanged >= changed.Count ||
                        (iUnchanged < unchanged.Count && CompareYValues(unchanged[iUnchanged].point, changed[iChanged].point) <= 0))
                    {
                        var (point, pos) = unchanged[iUnchanged++];
                        sourcePoint = point;
                        docNode = pos.DocNode;
                    }
                    else
                    {
                        var (point, node) = changed[iChanged++];
                        sourcePoint = point;
                        docNode = node;
                    }

                    // Create output point with correct X position
                    var nextPoint = new PointPair(outputIndex + 1, sourcePoint.Y) { Tag = sourcePoint.Tag };
                    pointPairList.Add(nextPoint);

                    // Update min/max
                    if (nextPoint.Y > maxY) maxY = nextPoint.Y;
                    if (nextPoint.Y < minY) minY = nextPoint.Y;

                    // Build lookup structures
                    var dataPoint = (GraphPointData)nextPoint.Tag;
                    xscalePaths.Add(dataPoint.IdentityPath);

                    var groupIdentity = dataPoint.IdentityPath.GetIdentity(0);
                    if (!identityToIndex.ContainsKey(groupIdentity.GlobalIndex))
                        identityToIndex.Add(groupIdentity.GlobalIndex, outputIndex);

                    var nodeKey = docNode.Id.GlobalIndex;
                    nodePositions.Add(nodeKey, new NodePosition
                    {
                        Index = outputIndex,
                        YValue = nextPoint.Y,
                        DocNode = docNode
                    });

                    outputIndex++;
                }

                productionMonitor.SetProgress(95);
                PointPairList = pointPairList;
                XScalePaths = xscalePaths.ToArray();
                _identityToIndex = identityToIndex;
                _nodePositions = nodePositions;
                MaxY = maxY;
                if (minY != double.MaxValue)
                    MinY = minY;

                // Incremental update: track how many nodes were cached vs recalculated
                CachedNodeCount = unchanged.Count;
                RecalculatedNodeCount = changed.Count;
            }

            /// <summary>
            /// Calculate Y values for each point, sort by Y descending, and assign X positions.
            /// This runs on the background thread during construction.
            /// </summary>
            private void CalcDataPositions(List<GraphPointData> listPoints, ProductionMonitor productionMonitor)
            {
                var xscalePaths = new List<IdentityPath>();
                double maxY = 0;
                var minY = double.MaxValue;

                var pointPairList = new PointPairList();
                int? resultIndex = ShowReplicate == ReplicateDisplay.single ? (int?)ResultsIndex : null;

                foreach (var dataPoint in listPoints)
                {
                    double groupMaxY = 0;
                    var groupMinY = double.MaxValue;
                    var pointPair = CreatePointPair(dataPoint, ref groupMaxY, ref groupMinY, resultIndex);
                    pointPairList.Add(pointPair);
                    maxY = Math.Max(maxY, groupMaxY);
                    minY = Math.Min(minY, groupMinY);
                }

                productionMonitor.SetProgress(80);
                pointPairList.Sort(CompareYValues);

                productionMonitor.SetProgress(90);
                var identityToIndex = new Dictionary<int, int>(pointPairList.Count);
                var nodePositions = new Dictionary<int, NodePosition>(pointPairList.Count);
                for (var i = 0; i < pointPairList.Count; i++)
                {
                    var dataPoint = (GraphPointData)pointPairList[i].Tag;
                    // 1-index the proteins
                    pointPairList[i].X = i + 1;
                    xscalePaths.Add(dataPoint.IdentityPath);
                    // Build map for O(1) selection lookup (use GlobalIndex for reference equality)
                    var groupIdentity = dataPoint.IdentityPath.GetIdentity(0);
                    if (!identityToIndex.ContainsKey(groupIdentity.GlobalIndex))
                        identityToIndex[groupIdentity.GlobalIndex] = i;
                    // Build map for incremental update support
                    // Use peptide DocNode in peptide mode, protein DocNode in protein mode
                    var docNode = dataPoint.Peptide?.DocNode ?? (DocNode)dataPoint.Protein.DocNode;
                    var nodeKey = docNode.Id.GlobalIndex;
                    nodePositions.Add(nodeKey, new NodePosition
                    {
                        Index = i,
                        YValue = pointPairList[i].Y,
                        DocNode = docNode
                    });
                }

                PointPairList = pointPairList;
                XScalePaths = xscalePaths.ToArray();
                _identityToIndex = identityToIndex;
                _nodePositions = nodePositions;
                MaxY = maxY;
                if (minY != double.MaxValue)
                {
                    MinY = minY;
                }
            }

            /// <summary>
            /// Find the index of the selected protein in the sorted list.
            /// Uses dictionary for O(1) lookup on the UI thread.
            /// </summary>
            public int FindSelectedIndex(PeptideGroupDocNode selectedProtein)
            {
                if (selectedProtein == null || _identityToIndex == null)
                    return -1;

                if (_identityToIndex.TryGetValue(selectedProtein.PeptideGroup.GlobalIndex, out var index))
                    return index - 1;

                return -1;
            }

            private Dictionary<int, int> _identityToIndex;

            /// <summary>
            /// Maps doc node reference (via Id.GlobalIndex - guaranteed unique per object) to its position and Y value in the sorted list.
            /// Used for incremental updates: unchanged nodes (same reference) keep their position.
            /// </summary>
            private Dictionary<int, NodePosition> _nodePositions;

            /// <summary>
            /// Stores the position and computed value for a doc node in the sorted list.
            /// In protein mode, this is a PeptideGroupDocNode. In peptide mode, a PeptideDocNode.
            /// </summary>
            internal struct NodePosition
            {
                public int Index;
                public double YValue;
                public DocNode DocNode;
            }

            /// <summary>
            /// Gets the node position data for incremental update support.
            /// </summary>
            internal IReadOnlyDictionary<int, NodePosition> NodePositions => _nodePositions;

            private static int CompareYValues(PointPair p1, PointPair p2)
            {
                return Comparer.Default.Compare(p2.Y, p1.Y);
            }

            public SrmDocument Document { get; }
            public GraphSettings GraphSettings { get; }
            public ReplicateDisplay ShowReplicate { get; }
            public int ResultsIndex { get; }
            public GraphValues.AggregateOp AggregateOp { get; }
            public PointPairList PointPairList { get; private set; }
            public IdentityPath[] XScalePaths { get; private set; }
            public double MaxY { get; private set; }
            public double? MinY { get; private set; }
            public int SelectedIndex { get; set; }

            /// <summary>
            /// Number of nodes whose values were reused from the prior cache during incremental update.
            /// Zero when full calculation was performed.
            /// </summary>
            public int CachedNodeCount { get; private set; }

            /// <summary>
            /// Number of nodes whose values were calculated from scratch.
            /// Equals total node count when full calculation was performed.
            /// </summary>
            public int RecalculatedNodeCount { get; private set; }

            /// <summary>
            /// True if this data was calculated from scratch (CalcDataPositionsFull),
            /// false if it was an incremental update using prior cached data.
            /// </summary>
            public bool WasFullCalculation { get; private set; }

            /// <summary>
            /// Returns diagnostic information for debugging test failures.
            /// </summary>
            public string GetDiagnosticInfo()
            {
                return $@"Full={WasFullCalculation}, Cached={CachedNodeCount}, Recalc={RecalculatedNodeCount}, " +
                       $@"DocId={Document.Id.GlobalIndex}, DocRev={Document.RevisionIndex}";
            }

            public virtual double MaxValueSetting { get { return 0; } }
            public virtual double MinValueSetting { get { return 0; } }
            public virtual double MaxCvSetting { get { return 0; } }

            protected virtual PointPair CreatePointPair(GraphPointData pointData, ref double maxY, ref double minY, int? resultIndex)
            {
                var yValue = GetY(pointData, resultIndex);
                var pointPair = new PointPair(0, yValue)
                    { Tag = pointData };
                maxY = Math.Max(maxY, pointPair.Y);
                minY = Math.Min(minY, pointPair.Y);
                return pointPair;
            }

            private double GetY(GraphPointData pointData, int? resultIndex)
            {
                Statistics statValues;
                if (ShowReplicate == ReplicateDisplay.single && resultIndex.HasValue)
                {
                    statValues = new Statistics(pointData.ReplicateAreas[resultIndex.Value]);
                }
                else
                {
                    statValues = new Statistics(pointData.ReplicateAreas.SelectMany(grouping => grouping));
                }

                if (Settings.Default.ShowPeptideCV)
                {
                    var cv = statValues.StdDev() / statValues.Mean();
                    return cv;
                }

                if (statValues.Length == 0)
                {
                    return 0;
                }

                if (ShowReplicate == ReplicateDisplay.best)
                {
                    return statValues.Max();
                }

                return statValues.Mean();
            }

        }

        public class GraphPointData 
        {
            public GraphPointData(Protein protein)
            {
                Protein = protein;
                IdentityPath = protein.IdentityPath;
                ReplicateAreas = protein.GetProteinAbundances()
                    .ToLookup(kvp => kvp.Key, kvp => kvp.Value.Raw);
            }

            public GraphPointData(Peptide peptide)
            {
                Protein = peptide.Protein;
                Peptide = peptide;
                IdentityPath = peptide.IdentityPath;
                ReplicateAreas = peptide.Results.Values.ToLookup(
                    peptideResult => peptideResult.ResultFile.Replicate.ReplicateIndex,
                    peptideResult => peptideResult.GetQuantificationResult()?.NormalizedArea?.Raw ?? 0);
            }
            public Protein Protein { get; }
            public Peptide Peptide { get; }
            public ILookup<int, double> ReplicateAreas { get; set; }
            public IdentityPath IdentityPath { get; set; }
        }

        public class GraphSettings : Immutable
        {
            public bool AreaProteinTargets { get; private set; }

            public GraphSettings ChangeAreaProteinTargets(bool value)
            {
                return ChangeProp(ImClone(this), im => im.AreaProteinTargets = value);
            }

            public bool ExcludePeptideLists { get; private set; }

            public GraphSettings ChangeExcludePeptideLists(bool value)
            {
                return ChangeProp(ImClone(this), im => im.ExcludePeptideLists = value);
            }

            public bool ExcludeStandards { get; private set; }

            public GraphSettings ChangeExcludeStandards(bool value)
            {
                return ChangeProp(ImClone(this), im => im.ExcludeStandards = value);
            }

            public static GraphSettings FromSettings()
            {
                return new GraphSettings
                {
                    AreaProteinTargets = Settings.Default.AreaProteinTargets,
                    ExcludePeptideLists = Settings.Default.ExcludePeptideListsFromAbundanceGraph,
                    ExcludeStandards = Settings.Default.ExcludeStandardsFromAbundanceGraph
                };
            }

            protected bool Equals(GraphSettings other)
            {
                return AreaProteinTargets == other.AreaProteinTargets
                       && ExcludePeptideLists == other.ExcludePeptideLists
                       && ExcludeStandards == other.ExcludeStandards;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != GetType()) return false;
                return Equals((GraphSettings)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    var hashCode = AreaProteinTargets.GetHashCode();
                    hashCode = (hashCode * 397) ^ ExcludePeptideLists.GetHashCode();
                    hashCode = (hashCode * 397) ^ ExcludeStandards.GetHashCode();
                    return hashCode;
                }
            }
        }

        public class GraphDataParameters : ICachingParameters
        {
            public GraphDataParameters(SrmDocument document, GraphSettings graphSettings,
                ReplicateDisplay showReplicate, int resultsIndex, GraphData priorGraphData = null)
            {
                Document = document;
                GraphSettings = graphSettings;
                ShowReplicate = showReplicate;
                // ResultsIndex only matters for single replicate mode
                ResultsIndex = showReplicate == ReplicateDisplay.single ? resultsIndex : -1;
                PriorGraphData = priorGraphData;
            }

            public SrmDocument Document { get; }
            public GraphSettings GraphSettings { get; }
            public ReplicateDisplay ShowReplicate { get; }
            public int ResultsIndex { get; }

            // ICachingParameters implementation
            int ICachingParameters.CacheKey => ResultsIndex;
            object ICachingParameters.CacheSettings => new { GraphSettings, ShowReplicate };

            /// <summary>
            /// Optional prior graph data for incremental update optimization.
            /// If set, the caller guarantees that the prior data is from the same document identity
            /// with compatible quantification settings. Not included in Equals/GetHashCode.
            /// </summary>
            public GraphData PriorGraphData { get; }

            protected bool Equals(GraphDataParameters other)
            {
                return ReferenceEquals(Document, other.Document) &&
                       GraphSettings.Equals(other.GraphSettings) &&
                       ShowReplicate == other.ShowReplicate &&
                       ResultsIndex == other.ResultsIndex;
            }

            public override bool Equals(object obj)
            {
                if (obj is null) return false;
                if (ReferenceEquals(this, obj)) return true;
                if (obj.GetType() != GetType()) return false;
                return Equals((GraphDataParameters)obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    var hashCode = RuntimeHelpers.GetHashCode(Document);
                    hashCode = (hashCode * 397) ^ GraphSettings.GetHashCode();
                    hashCode = (hashCode * 397) ^ (int)ShowReplicate;
                    hashCode = (hashCode * 397) ^ ResultsIndex;
                    return hashCode;
                }
            }
        }

        class RelativeAbundanceTipProvider : ITipProvider
        {
            private PointPair _pp;
            public RelativeAbundanceTipProvider(PointPair pp)
            {
                _pp = pp;
            }

            public bool HasTip
            {
                get
                {
                    return ((_pp?.Tag is GraphPointData pd) && pd.IdentityPath != null);
                }
            }

            public Size RenderTip(Graphics g, Size sizeMax, bool draw)
            {
                if (HasTip)
                {
                    var pd = _pp?.Tag as GraphPointData;
                    var table = new TableDesc();
                    using (var rt = new RenderTools())
                    {
                        if (pd?.Peptide != null)
                            table.AddDetailRow(
                                Helpers.PeptideToMoleculeTextMapper.Translate(GroupComparisonStrings.FoldChangeRowTipProvider_RenderTip_Peptide, pd.Peptide.IsSmallMolecule()),
                                pd.Peptide.ModifiedSequence == null ? pd.Peptide.ToString() : pd.Peptide.ModifiedSequence.ToString(), rt);
                        if (pd?.Protein != null)
                            table.AddDetailRow(
                                Helpers.PeptideToMoleculeTextMapper.Translate(GroupComparisonStrings.FoldChangeRowTipProvider_RenderTip_Protein, pd.Protein.IsNonProteomic()),
                                ProteinMetadataManager.ProteinModalDisplayText(pd.Protein.DocNode), rt);
                        if (_pp != null )
                        {
                            table.AddDetailRow(GraphsResources.RelativeAbundanceGraph_ToolTip_PeakArea,
                                _pp.Y.ToString(Formats.PEAK_AREA, CultureInfo.CurrentCulture), rt);
                            table.AddDetailRow(GraphsResources.RelativeAbundanceGraph_ToolTip_LogPeakArea,
                                Math.Log10(_pp.Y).ToString(Formats.FoldChange, CultureInfo.CurrentCulture), rt);
                            table.AddDetailRow(GraphsResources.RelativeAbundanceGraph_ToolTip_Rank,
                                _pp?.X.ToString(@"#", CultureInfo.CurrentCulture), rt);
                        }
                        var size = table.CalcDimensions(g);

                        if (draw)
                            table.Draw(g);

                        return new Size((int)size.Width + 2, (int)size.Height + 2);
                    }
                }
                return Size.Empty;
            }
        }
    }
}
