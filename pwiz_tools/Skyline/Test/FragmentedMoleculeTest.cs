using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using pwiz.Common.Chemistry;
using pwiz.Skyline.Model;
using pwiz.Skyline.Model.DocSettings;
using pwiz.Skyline.Properties;
using pwiz.Skyline.Util;
using pwiz.Skyline.Util.Extensions;
using pwiz.SkylineTestUtil;

namespace pwiz.SkylineTest
{
    [TestClass]
    public class FragmentedMoleculeTest : AbstractUnitTest
    {
        [TestMethod]
        public void TestGetPrecursorFormula()
        {
            var modifiedSequence = new ModifiedSequence("PEPTIDE", new ModifiedSequence.Modification[0], MassType.Monoisotopic);
            var fragmentedMolecule = FragmentedMolecule.EMPTY.ChangeModifiedSequence(modifiedSequence);
            var precursorFormula = fragmentedMolecule.PrecursorFormula;
            Assert.AreEqual(0.0, fragmentedMolecule.PrecursorFormula.MonoMassOffset);
            Assert.AreEqual(0.0, fragmentedMolecule.PrecursorFormula.AverageMassOffset);
            var sequenceMassCalc = new SequenceMassCalc(MassType.Monoisotopic);
            var expectedFormula = sequenceMassCalc.GetMolecularFormula(modifiedSequence.GetUnmodifiedSequence());
            Assert.AreEqual(expectedFormula.Molecule.Count, precursorFormula.Molecule.Count);
            foreach (var entry in expectedFormula.Molecule)
            {
                Assert.AreEqual(entry.Value, precursorFormula.Molecule.GetElementCount(entry.Key));
            }
        }

        [TestMethod]
        public void TestGetFragmentFormula()
        {
            var pepseq = "PEPTIDE";
            var sequenceMassCalc = new SequenceMassCalc(MassType.Monoisotopic);
            var precursor = FragmentedMolecule.EMPTY.ChangeModifiedSequence(
                new ModifiedSequence(pepseq, new ModifiedSequence.Modification[0], MassType.Monoisotopic));
            var peptide = new Peptide(precursor.UnmodifiedSequence);
            var transitionGroup = new TransitionGroup(peptide, Adduct.SINGLY_PROTONATED, IsotopeLabelType.light);
            var settings = SrmSettingsList.GetDefault();
            var transitionGroupDocNode = new TransitionGroupDocNode(transitionGroup, Annotations.EMPTY, settings,
                ExplicitMods.EMPTY, null, null, null, new TransitionDocNode[0], false);
            foreach (var ionType in FragmentIonTypes)
            {
                for (int ordinal = 1; ordinal < pepseq.Length; ordinal++)
                {
                    var transition = new Transition(transitionGroup, ionType, Transition.OrdinalToOffset(ionType, ordinal, pepseq.Length), 0, Adduct.SINGLY_PROTONATED);
                    var fragment = precursor.ChangeFragmentIon(ionType, ordinal);
                    var actualMassDistribution = FragmentedMolecule.Settings.DEFAULT.GetMassDistribution(
                        fragment.FragmentFormula, 0, 0);
                    var expectedMz = sequenceMassCalc.GetFragmentMass(transition, transitionGroupDocNode.IsotopeDist);
                    if (expectedMz.IsMassH())
                    {
                        expectedMz = new TypedMass(expectedMz.Value - BioMassCalc.MassProton, expectedMz.MassType & ~MassType.bMassH);
                    }
                    var actualMz = actualMassDistribution.MostAbundanceMass;
                    if (Math.Abs(expectedMz - actualMz) > .001)
                    {
                        Assert.AreEqual(expectedMz, actualMz, .001, "Ion type {0} Ordinal {1}", ionType, ordinal);
                    }
                }
            }
        }

        [TestMethod]
        public void TestGetFragmentFormulaWithNeutralLosses()
        {
            var peptide = new Peptide("PEPTIDE");
            var modPhospho = UniMod.GetModification("Phospho (ST)", true);
            var modPlus100or102 = new StaticMod("Plus100or102", null, null, null, LabelAtoms.None, 100, 102)
                .ChangeLosses(new[]
                {
                    new FragmentLoss("H2O"),
                    new FragmentLoss(null, 10, 11)
                });
            var explicitMods = new ExplicitMods(peptide, new[]
            {
                new ExplicitMod(3, modPhospho),
                new ExplicitMod(1, modPlus100or102)
            }, Array.Empty<TypedExplicitModifications>());
            var transitionGroup = new TransitionGroup(peptide, Adduct.SINGLY_PROTONATED, IsotopeLabelType.light);
            var precursorTransition = new Transition(transitionGroup, IonType.precursor, peptide.Length - 1, 0,
                Adduct.SINGLY_PROTONATED);
            var settings = SrmSettingsList.GetDefault();
            var peptideFragmentedMolecule = FragmentedMolecule.EMPTY.ChangeModifiedSequence(
                ModifiedSequence.GetModifiedSequence(settings, peptide.Sequence, explicitMods, IsotopeLabelType.light)).ChangePrecursorCharge(1);
            foreach (var massType in new[] { MassType.Monoisotopic, MassType.Average })
            {
                double delta = massType == MassType.Monoisotopic ? 1e-3 : 1e-2;
                var sequenceMassCalc = new ExplicitSequenceMassCalc(explicitMods, new SequenceMassCalc(massType), IsotopeLabelType.light);
                var expectedPrecursorMass = sequenceMassCalc.GetPrecursorMass(peptide.Sequence);
                var actualPrecursorMass = GetMass(peptideFragmentedMolecule.PrecursorFormula, massType);
                Assert.AreEqual(expectedPrecursorMass, actualPrecursorMass, delta, "Mass type: {0}", massType);
                var possibleTransitionLosses = new[] { modPhospho, modPlus100or102 }.SelectMany(mod =>
                    mod.Losses.Select(loss => new TransitionLoss(mod, loss, massType))).ToList();
                for (int iCombination = 0; iCombination < 1 << possibleTransitionLosses.Count; iCombination++)
                {
                    var transitionLossList = new List<TransitionLoss>();
                    for (int iLoss = 0; iLoss < possibleTransitionLosses.Count; iLoss++)
                    {
                        if (0 != (iCombination & (1 << iLoss)))
                        {
                            transitionLossList.Add(possibleTransitionLosses[iLoss]);
                        }
                    }
                    var transitionLosses = new TransitionLosses(transitionLossList, massType);
                    var fragmentLosses = transitionLosses.Losses.Select(loss => loss.Loss).ToList();
                    string precursorMessage = string.Format("Mass Type: {0} Losses: {1}", massType,
                        string.Join(",", fragmentLosses));
                    var precursorFragmentedMolecule = peptideFragmentedMolecule.ChangeFragmentIon(IonType.precursor, 0)
                        .ChangeFragmentLosses(transitionLossList.Select(loss=>loss.Loss))
                        .ChangeFragmentCharge(1);
                    var expectedPrecursorMz = sequenceMassCalc.GetFragmentMass(precursorTransition, null) - transitionLosses.Mass;
                    var actualPrecursorMz = GetMass(precursorFragmentedMolecule.FragmentFormula, massType);
                    AssertEx.AreEqual(expectedPrecursorMz, actualPrecursorMz, delta, precursorMessage);
                    foreach (var ionType in FragmentIonTypes)
                    {
                        for (int ionOrdinal = 1; ionOrdinal < peptide.Sequence.Length - 1; ionOrdinal++)
                        {
                            string fragmentMessage = TextUtil.SpaceSeparate(precursorMessage,
                                string.Format("Ion:{0}{1}", ionType, ionOrdinal));
                            var fragmentTransition = new Transition(transitionGroup, ionType,
                                Transition.OrdinalToOffset(ionType, ionOrdinal, peptide.Sequence.Length), 0,
                                Adduct.SINGLY_PROTONATED);
                            var expectedFragmentMz = sequenceMassCalc.GetFragmentMass(fragmentTransition, null) -
                                                     transitionLosses.Mass;
                            var fragmentFragmentedMolecule = peptideFragmentedMolecule
                                .ChangeFragmentIon(ionType, ionOrdinal).ChangeFragmentLosses(fragmentLosses)
                                .ChangeFragmentCharge(1);
                            var actualFragmentMz = GetMass(fragmentFragmentedMolecule.FragmentFormula, massType);
                            AssertEx.AreEqual(expectedFragmentMz, actualFragmentMz, delta, fragmentMessage);
                        }
                    }
                }
            }
        }

        private IEnumerable<IonType> FragmentIonTypes
        {
            get
            {
                return new[]
                    { IonType.a, IonType.b, IonType.c, IonType.x, IonType.y, IonType.z, IonType.zh, IonType.zhh };
            }
        }

        private double GetMass(MoleculeMassOffset moleculeMassOffset, MassType massType)
        {
            if (massType.IsMonoisotopic())
            {
                return FragmentedMolecule.Settings.DEFAULT.GetMonoMass(moleculeMassOffset);
            }

            return FragmentedMolecule.Settings.DEFAULT.GetAverageMass(moleculeMassOffset);
        }

        [TestMethod]
        public void TestGetFragmentMz()
        {
            var chargeTwoOrdinal4Mzs = new[]
            {
                Tuple.Create(IonType.a, 199.1077),
                Tuple.Create(IonType.b, 213.1052),
                Tuple.Create(IonType.c, 221.6185),
                Tuple.Create(IonType.x, 252.1028),
                Tuple.Create(IonType.y, 239.1132),
                Tuple.Create(IonType.z, 230.5999)
            };
            var precursor = FragmentedMolecule.EMPTY.ChangeModifiedSequence(new ModifiedSequence("PEPTIDE",
                new ModifiedSequence.Modification[0], MassType.Monoisotopic));
            foreach (var tuple in chargeTwoOrdinal4Mzs)
            {
                var fragment = precursor.ChangeFragmentCharge(2)
                    .ChangeFragmentIon(tuple.Item1, 4);
                var mzDistribution = fragment.GetFragmentDistribution(FragmentedMolecule.Settings.DEFAULT, null, null, MassType.Monoisotopic);
                var maxAbundance = mzDistribution.Values.Max();
                var monoMz = mzDistribution.First(entry => Equals(entry.Value, maxAbundance)).Key;
                Assert.AreEqual(tuple.Item2, monoMz, .0001);
            }
        }

        [TestMethod]
        public void TestModifiedSequenceParser()
        {
            var unmodifiedSequence = new ModifiedSequence("PEPTIDE", MassType.Monoisotopic);
            Assert.AreEqual("PEPTIDE", unmodifiedSequence.GetUnmodifiedSequence());
            Assert.AreEqual(0, unmodifiedSequence.ExplicitMods.Count);

            var modifiedSequence1 = new ModifiedSequence("PEPT[UNIMOD:21]IDE", MassType.Monoisotopic);
            Assert.AreEqual("PEPTIDE", modifiedSequence1.GetUnmodifiedSequence());
            Assert.AreEqual(1, modifiedSequence1.ExplicitMods.Count);
            Assert.AreEqual("Phospho (ST)", modifiedSequence1.ExplicitMods[0].Name);

            var modifiedSequence2 = new ModifiedSequence("PC[unimod:4]PT[UNIMOD:21]IDE", MassType.Monoisotopic);
            Assert.AreEqual("PCPTIDE", modifiedSequence2.GetUnmodifiedSequence());
            Assert.AreEqual(2, modifiedSequence2.ExplicitMods.Count);
            Assert.AreEqual("Carbamidomethyl (C)", modifiedSequence2.ExplicitMods[0].Name);
            Assert.AreEqual("Phospho (ST)", modifiedSequence2.ExplicitMods[1].Name);

            var modifiedSequence3 = new ModifiedSequence("C[unimod:4]PT[UNIMOD:21]IDEK[UNIMOD:2016]", MassType.Monoisotopic);
            Assert.AreEqual("CPTIDEK", modifiedSequence3.GetUnmodifiedSequence());
            Assert.AreEqual(3, modifiedSequence3.ExplicitMods.Count);
            Assert.AreEqual("Carbamidomethyl (C)", modifiedSequence3.ExplicitMods[0].Name);
            Assert.AreEqual("Phospho (ST)", modifiedSequence3.ExplicitMods[1].Name);
            Assert.AreEqual("TMTpro (K)", modifiedSequence3.ExplicitMods[2].Name);

            var modifiedSequence4 = new ModifiedSequence("C[Carbamidomethyl (C)]PT[Phospho (ST)]IDEK[TMTpro (K)]", MassType.Monoisotopic);
            Assert.AreEqual("CPTIDEK", modifiedSequence4.GetUnmodifiedSequence());
            Assert.AreEqual(3, modifiedSequence4.ExplicitMods.Count);
            Assert.AreEqual("Carbamidomethyl (C)", modifiedSequence4.ExplicitMods[0].Name);
            Assert.AreEqual("Phospho (ST)", modifiedSequence4.ExplicitMods[1].Name);
            Assert.AreEqual("TMTpro (K)", modifiedSequence4.ExplicitMods[2].Name);

            AssertEx.ThrowsException<FormatException>(() => new ModifiedSequence("C[Carbamidomethyl]PT[Phospho]IDEK[TMTpro]", MassType.Monoisotopic),
                string.Format(ModelResources.ModificationMatcher_ThrowUnimodException_Unrecognized_Unimod_id__0__in_modified_peptide_sequence__1___amino_acid__2____3___,
                    0, "C[Carbamidomethyl]PT[Phospho]IDEK[TMTpro]", 1, "C[Carbamidomethyl]"));
        }
    }
}
