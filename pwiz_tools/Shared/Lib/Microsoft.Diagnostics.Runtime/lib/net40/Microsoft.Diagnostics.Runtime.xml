<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Runtime</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrAppDomain">
            <summary>
            Represents an AppDomain in the target runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Runtime">
            <summary>
            Gets the runtime associated with this ClrAppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules">
            <summary>
            Returns a list of modules loaded into this AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile">
            <summary>
            Returns the config file used for the AppDomain.  This may be null if there was no config file
            loaded, or if the targeted runtime does not support enumerating that data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ApplicationBase">
            <summary>
            Returns the base directory for this AppDomain.  This may return null if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.AppBase">
            <summary>
            Returns the base directory for this AppDomain.  This may return null if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrAppDomain.ToString">
            <summary>
            To string override.
            </summary>
            <returns>The name of this AppDomain.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException">
            <summary>
            Exception thrown by Microsoft.Diagnostics.Runtime unless there is a more appropriate
            exception subclass.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR">
            <summary>
            Specific HRESULTS for errors.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.UnknownError">
            <summary>
            Unknown error occured.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.RuntimeUninitialized">
            <summary>
            The dll of the specified runtime (mscorwks.dll or clr.dll) is loaded into the process, but
            has not actually been initialized and thus cannot be debugged.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DebuggerError">
            <summary>
            Something unexpected went wrong with the debugger we used to attach to the process or load
            the crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DataRequestError">
            <summary>
            Something unexpected went wrong when requesting data from the target process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DacError">
            <summary>
            Hit an unexpected (non-recoverable) dac error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.RevisionError">
            <summary>
            The caller attempted to re-use an object after calling ClrRuntime.Flush.  See the
            documentation for ClrRuntime.Flush for more details.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.CrashDumpError">
            <summary>
            An error occurred while processing the given crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.ApplicationError">
            <summary>
            There is an issue with the configuration of this application.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HResult">
            <summary>
            The HRESULT of this exception.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHeap">
            <summary>
            A ClrHeap is a abstraction for the whole GC Heap.   Subclasses allow you to implement this for 
            a particular kind of heap (whether live,
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectType(System.UInt64)">
            <summary>
            And the ability to take an address of an object and fetch its type (The type alows further exploration)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.HasComponentMethodTables">
            <summary>
            Returns whether this version of CLR has component MethodTables.  Component MethodTables were removed from
            desktop CLR in v4.6, and do not exist at all on .Net Native.  If this method returns false, all componet
            MethodTables will be 0, and expected to be 0 when an argument to a function.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.TryGetMethodTable(System.UInt64,System.UInt64@,System.UInt64@)">
            <summary>
            Attempts to retrieve the MethodTable and component MethodTable from the given object.
            Note that this some ClrTypes cannot be uniquely determined by MethodTable alone.  In
            Desktop CLR (prior to v4.6), arrays of reference types all use the same MethodTable but
            also carry a second MethodTable (called the component MethodTable) to determine the
            array element types. Note this function has undefined behavior if you do not pass a
            valid object reference to it.
            </summary>
            <param name="obj">The object to get the MethodTable of.</param>
            <param name="methodTable">The MethodTable for the given object.</param>
            <param name="componentMethodTable">The component MethodTable of the given object.</param>
            <returns>True if methodTable was filled, false if we failed to read memory.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetMethodTable(System.UInt64)">
            <summary>
            Attempts to retrieve the MethodTable from the given object.
            Note that this some ClrTypes cannot be uniquely determined by MethodTable alone.  In
            Desktop CLR, arrays of reference types all use the same MethodTable.  To uniquely
            determine an array of referneces you must also have its component type.
            Note this function has undefined behavior if you do not pass a valid object reference
            to it.
            </summary>
            <param name="obj">The object to get the MethodTablee of.</param>
            <returns>The MethodTable of the object, or 0 if the address could not be read from.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetEEClassByMethodTable(System.UInt64)">
            <summary>
            Retrieves the EEClass from the given MethodTable.  EEClasses do not exist on
            .Net Native. 
            </summary>
            <param name="methodTable">The MethodTable to get the EEClass from.</param>
            <returns>The EEClass for the given MethodTable, 0 if methodTable is invalid or
            does not exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetMethodTableByEEClass(System.UInt64)">
            <summary>
            Retrieves the MethodTable associated with the given EEClass.
            </summary>
            <param name="eeclass">The eeclass to get the method table from.</param>
            <returns>The MethodTable for the given EEClass, 0 if eeclass is invalid
            or does not exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetExceptionObject(System.UInt64)">
            <summary>
            Returns a  wrapper around a System.Exception object (or one of its subclasses).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetRuntime">
            <summary>
            Returns the runtime associated with this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Runtime">
            <summary>
            Returns the runtime associated with this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Segments">
            <summary>
            A heap is has a list of contiguous memory regions called segments.  This list is returned in order of
            of increasing object addresses.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots">
            <summary>
            Enumerate the roots of the process.  (That is, all objects which keep other objects alive.)
            Equivalent to EnumerateRoots(true).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByIndex(System.Int32)">
            <summary>
            Returns a type by its index.
            </summary>
            <param name="index">The type to get.</param>
            <returns>The ClrType of that index.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByName(System.String)">
            <summary>
            Looks up a type by name.
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The ClrType matching 'name', null if the type was not found, and undefined if more than one
            type shares the same name.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByMethodTable(System.UInt64,System.UInt64)">
            <summary>
            Retrieves the given type by its MethodTable/ComponentMethodTable pair.
            </summary>
            <param name="methodTable">The ClrType.MethodTable for the requested type.</param>
            <param name="componentMethodTable">The ClrType's component MethodTable for the requested type.</param>
            <returns>A ClrType object, or null if no such type exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByMethodTable(System.UInt64)">
            <summary>
            Retrieves the given type by its MethodTable/ComponentMethodTable pair.  Note this is only valid if
            the given type's component MethodTable is 0.
            </summary>
            <param name="methodTable">The ClrType.MethodTable for the requested type.</param>
            <returns>A ClrType object, or null if no such type exists.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TypeIndexLimit">
            <summary>
            Returns the max index.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots(System.Boolean)">
            <summary>
            Enumerate the roots in the process.
            </summary>
            <param name="enumerateStatics">True if we should enumerate static variables.  Enumerating with statics 
            can take much longer than enumerating without them.  Additionally these will be be "double reported",
            since all static variables are pinned by handles on the HandleTable (which is also enumerated with 
            EnumerateRoots).  You would want to enumerate statics with roots if you care about what exact statics
            root what objects, but not if you care about performance.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateTypes">
            <summary>
            Enumerates all types in the runtime.
            </summary>
            <returns>An enumeration of all types in the target process.  May return null if it's unsupported for
            that version of CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjectAddresses">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjects">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateBlockingObjects">
            <summary>
            Enumerates all managed locks in the process.  That is anything using System.Monitor either explictly
            or implicitly through "lock (obj)".  This is roughly equivalent to combining SOS's !syncblk command
            with !dumpheap -thinlock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.CanWalkHeap">
            <summary>
            Returns true if the GC heap is in a consistent state for heap enumeration.  This will return false
            if the process was stopped in the middle of a GC, which can cause the GC heap to be unwalkable.
            Note, you may still attempt to walk the heap if this function returns false, but you will likely
            only be able to partially walk each segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjectAddresses">
            <summary>
            Enumerates all objects on the heap.  This is equivalent to enumerating all segments then walking
            each object with ClrSegment.FirstObject, ClrSegment.NextObject, but in a simple enumerator
            for easier use in linq queries.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects">
            <summary>
            Enumerates all objects on the heap.  This is equivalent to enumerating all segments then walking
            each object with ClrSegment.FirstObject, ClrSegment.NextObject, but in a simple enumerator
            for easier use in linq queries.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TotalHeapSize">
            <summary>
            TotalHeapSize is defined as the sum of the length of all segments.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSizeByGen(System.Int32)">
            <summary>
            Get the size by generation 0, 1, 2, 3.  The large object heap is Gen 3 here. 
            The sum of all of these should add up to the TotalHeapSize.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.NextObject(System.UInt64)">
            <summary>
            Returns the object after this one on the segment.
            </summary>
            <param name="obj">The object to find the next for.</param>
            <returns>The next object on the segment, or 0 if the object was the last one on the segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSegmentByAddress(System.UInt64)">
            <summary>
            Returns the GC segment for the given object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.IsInHeap(System.UInt64)">
            <summary>
            Returns true if the given address resides somewhere on the managed heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.PointerSize">
            <summary>
            Pointer size of on the machine (4 or 8 bytes).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ToString">
            <summary>
            Returns a string representation of this heap, including the size and number of segments.
            </summary>
            <returns>The string representation of this heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 'count' bytes from the ClrHeap at 'address' placing it in 'buffer' starting at offset 'offset'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Attempts to efficiently read a pointer from memory.  This acts exactly like ClrRuntime.ReadPointer, but
            there is a greater chance you will hit a chache for a more efficient memory read.
            </summary>
            <param name="addr">The address to read.</param>
            <param name="value">The pointer value.</param>
            <returns>True if we successfully read the value, false if addr is not mapped into the process space.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingObject">
            <summary>
            Represents a managed lock within the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Object">
            <summary>
            The object associated with the lock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Taken">
            <summary>
            Whether or not the object is currently locked.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.RecursionCount">
            <summary>
            The recursion count of the lock (only valid if Locked is true).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owner">
            <summary>
            The thread which currently owns the lock.  This is only valid if Taken is true and
            only valid if HasSingleOwner is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.HasSingleOwner">
            <summary>
            Returns true if this lock has only one owner.  Returns false if this lock
            may have multiple owners (for example, readers on a RW lock).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owners">
            <summary>
            Returns the list of owners for this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Waiters">
            <summary>
            Returns the list of threads waiting on this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Reason">
            <summary>
            The reason why it's blocking.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRootKind">
            <summary>
            The type of GCRoot that a ClrRoot represnts.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.StaticVar">
            <summary>
            The root is a static variable.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.ThreadStaticVar">
            <summary>
            The root is a thread static.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.LocalVar">
            <summary>
            The root is a local variable (or compiler generated temporary variable).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Strong">
            <summary>
            The root is a strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Weak">
            <summary>
            The root is a weak handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Pinning">
            <summary>
            The root is a strong pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Finalizer">
            <summary>
            The root comes from the finalizer queue.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.AsyncPinning">
            <summary>
            The root is an async IO (strong) pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Max">
            <summary>
            The max value of this enum.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRoot">
            <summary>
            Represents a root in the target process.  A root is the base entry to the GC's mark and sweep algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Kind">
            <summary>
            A GC Root also has a Kind, which says if it is a strong or weak root
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Name">
            <summary>
            The name of the root. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Type">
            <summary>
            The type of the object this root points to.  That is, ClrHeap.GetObjectType(ClrRoot.Object).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Object">
            <summary>
            The object on the GC heap that this root keeps alive.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Address">
            <summary>
            The address of the root in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.AppDomain">
            <summary>
            If the root can be identified as belonging to a particular AppDomain this is that AppDomain.
            It an be null if there is no AppDomain associated with the root.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Thread">
            <summary>
            If the root has a thread associated with it, this will return that thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsInterior">
            <summary>
            Returns true if Object is an "interior" pointer.  This means that the pointer may actually
            point inside an object instead of to the start of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPinned">
            <summary>
            Returns true if the root "pins" the object, preventing the GC from relocating it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPossibleFalsePositive">
            <summary>
            Unfortunately some versions of the APIs we consume do not give us perfect information.  If
            this property is true it means we used a heuristic to find the value, and it might not
            actually be considered a root by the GC.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRoot.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSegment">
            <summary>
            A GCHeapSegment represents a contiguous region of memory that is devoted to the GC heap. 
            Segments.  It has a start and end and knows what heap it belongs to.   Segments can
            optional have regions for Gen 0, 1 and 2, and Large properties.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start">
            <summary>
            The start address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.End">
            <summary>
            The end address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length">
            <summary>
            The number of bytes in the segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Heap">
            <summary>
            The GC heap associated with this segment.  There's only one GCHeap per process, so this is
            only a convenience method to keep from having to pass the heap along with a segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ProcessorAffinity">
            <summary>
            The processor that this heap is affinitized with.  In a workstation GC, there is no processor
            affinity (and the return value of this property is undefined).  In a server GC each segment
            has a logical processor in the PC associated with it.  This property returns that logical
            processor number (starting at 0).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Reserved">
            <summary>
            The address of the end of memory reserved for the segment, but not committed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Committed">
            <summary>
            The address of the end of memory committed for the segment (this may be longer than Length).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ReservedEnd">
            <summary>
            The address of the end of memory reserved for the segment, but not committed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.CommittedEnd">
            <summary>
            The address of the end of memory committed for the segment (this may be longer than Length).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.FirstObject">
            <summary>
            If it is possible to move from one object to the 'next' object in the segment. 
            Then FirstObject returns the first object in the heap (or null if it is not
            possible to walk the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.NextObject(System.UInt64)">
            <summary>
            Given an object on the segment, return the 'next' object in the segment.  Returns
            0 when there are no more objects.   (Or enumeration is not possible)  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsLarge">
            <summary>
            Returns true if this is a segment for the Large Object Heap.  False otherwise.
            Large objects (greater than 85,000 bytes in size), are stored in their own segments and
            only collected on full (gen 2) collections. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Large">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeral">
            <summary>
            Returns true if this segment is the ephemeral segment (meaning it contains gen0 and gen1
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Ephemeral">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Start">
            <summary>
            Ephemeral heap sements have geneation 0 and 1 in them.  Gen 1 is always above Gen 2 and
            Gen 0 is above Gen 1.  This property tell where Gen 0 start in memory.   Note that
            if this is not an Ephemeral segment, then this will return End (which makes Gen 0 empty
            for this segment)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Length">
            <summary>
            The length of the gen0 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Start">
            <summary>
            The start of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Length">
            <summary>
            The length of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Start">
            <summary>
            The start of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Length">
            <summary>
            The length of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjectAddresses">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object in this segment.
            </summary>
            <param name="obj">An object in this segment.</param>
            <returns>The generation of the given object if that object lies in this segment.  The return
                     value is undefined if the object does not lie in this segment.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingReason">
            <summary>
            Every thread which is blocking on an object specifies why the object is waiting.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.None">
            <summary>
            Object is not locked.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Unknown">
            <summary>
            Not able to determine why the object is blocking.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Monitor">
            <summary>
            The thread is waiting for a Mutex or Semaphore (such as Monitor.Enter, lock(obj), etc).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.MonitorWait">
            <summary>
            The thread is waiting for a mutex with Monitor.Wait.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitOne">
            <summary>
            The thread is waiting for an event (ManualResetEvent.WaitOne, AutoResetEvent.WaitOne).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAll">
            <summary>
            The thread is waiting in WaitHandle.WaitAll.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAny">
            <summary>
            The thread is waiting in WaitHandle.WaitAny.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ThreadJoin">
            <summary>
            The thread is blocked on a call to Thread.Join.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ReaderAcquired">
            <summary>
            ReaderWriterLock, reader lock is taken.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WriterAcquired">
            <summary>
            ReaderWriterLock, writer lock is taken.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCSegmentType">
            <summary>
            Types of GC segments.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Ephemeral">
            <summary>
            Ephemeral segments are the only segments to contain Gen0 and Gen1 objects.
            It may also contain Gen2 objects, but not always.  Objects are only allocated
            on the ephemeral segment.  There is one ephemeral segment per logical GC heap.
            It is important to not have too many pinned objects in the ephemeral segment,
            or you will run into a performance problem where the runtime runs too many GCs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Regular">
            <summary>
            Regular GC segments only contain Gen2 objects.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.LargeObject">
            <summary>
            The large object heap contains objects greater than a certain threshold.  Large
            object segments are never compacted.  Large objects are directly allocated
            onto LargeObject segments, and all large objects are considered gen2.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GcMode">
            <summary>
            Defines the state of the thread from the runtime's perspective.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GcMode.Cooperative">
            <summary>
            In Cooperative mode the thread must cooperate before a GC may proceed.  This means when a GC
            starts, the runtime will attempt to suspend the thread at a safepoint but cannot immediately
            stop the thread until it synchronizes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GcMode.Preemptive">
            <summary>
            In Preemptive mode the runtime is free to suspend the thread at any time for a GC to occur.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrModule">
            <summary>
            Represents a managed module in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsPdbLoaded">
            <summary>
            Returns true if ClrMD has loaded the the PDB for this module into memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.IsMatchingPdb(System.String)">
            <summary>
            Determines whether a PDB on disk matches this module.  (Note that TryDownloadPdb
            always provides a matching PDB if it finds one, so you do not need to check pdbs
            downloaded with TryDownloadPdb with this function.)
            </summary>
            <param name="pdbPath">The location of the PDB on disk.</param>
            <returns>True if the pdb matches, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.LoadPdb(System.String)">
            <summary>
            Loads the pdb for this module.
            </summary>
            <param name="path">The path to the PDB on disk.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.TryDownloadPdb(Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Attempts to download the PDB for this module from the symbol server.
            </summary>
            <returns>The path on disk of the downloaded PDB, or null if not found.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DefaultSymbolNotification">
            <summary>
            The ISymbolNotification to use if none is specified.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.TryDownloadPdb">
            <summary>
            Attempts to download the PDB for this module from the symbol server.
            </summary>
            <returns>The path on disk of the downloaded PDB, or null if not found.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.PdbInterface">
            <summary>
            Returns the IDiaSession interface if the pdb is loaded for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetSourceInformation(System.UInt32,System.Int32)">
            <summary>
            Gets the source location of a given metadata token for a function and offset.
            </summary>
            <param name="mdMethodToken">A method def token (ClrMethod.MetadataToken).</param>
            <param name="ilOffset">The il offset to look up the source information.</param>
            <returns>The SourceLocation for the given IL offset, or null if no mapping exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetSourceInformation(Microsoft.Diagnostics.Runtime.ClrMethod,System.Int32)">
            <summary>
            Gets the source location of a given metadata token for a function and offset.
            </summary>
            <param name="method">The method to look up the source information.</param>
            <param name="ilOffset">The il offset to look up the source information.</param>
            <returns>The SourceLocation for the given IL offset, or null if no mapping exists.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Runtime">
            <summary>
            Gets the runtime which contains this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AppDomains">
            <summary>
            Returns a list of all AppDomains this module is loaded into.  Please note that unlike
            ClrRuntime.AppDomains, this list may include the shared AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName">
            <summary>
            Returns the name of the assembly that this module is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyId">
            <summary>
            Returns an identifier to uniquely represent this assembly.  This value is not used by any other
            function in ClrMD, but can be used to group modules by their assembly.  (Do not use AssemblyName
            for this, as reflection and other special assemblies can share the same name, but actually be
            different.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Name">
            <summary>
            Returns the name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic">
            <summary>
            Returns true if this module was created through Reflection.Emit (and thus has no associated
            file).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsFile">
            <summary>
            Returns true if this module is an actual PEFile on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.FileName">
            <summary>
            Returns the filename of where the module was loaded from on disk.  Undefined results if
            IsPEFile returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase">
            <summary>
            Returns the base of the image loaded into memory.  This may be 0 if there is not a physical
            file backing it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Size">
            <summary>
            Returns the size of the image in memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypes">
            <summary>
            Enumerate all types defined by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress">
            <summary>
            The location of metadata for this module in the process's memory.  This is useful if you
            need to manually create IMetaData* objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength">
            <summary>
            The length of the metadata for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataImport">
            <summary>
            The IMetaDataImport interface for this module.  Note that this API does not provide a
            wrapper for IMetaDataImport.  You will need to wrap the API yourself if you need to use this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode">
            <summary>
            The debugging attributes for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)">
            <summary>
            Attempts to obtain a ClrType based on the name of the type.  Note this is a "best effort" due to
            the way that the dac handles types.  This function will fail for Generics, and types which have
            never been constructed in the target process.  Please be sure to null-check the return value of
            this function.
            </summary>
            <param name="name">The name of the type.  (This would be the EXACT value returned by ClrType.Name.</param>
            <returns>The requested ClrType, or null if the type doesn't exist or couldn't be constructed.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.ToString">
            <summary>
            Returns a name for the assembly.
            </summary>
            <returns>A name for the assembly.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Pdb">
            <summary>
            Returns the pdb information for this module.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime">
            <summary>
            Represents a single runtime in a target process or crash dump.  This serves as the primary
            entry point for getting diagnostic information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ClrInfo">
            <summary>
            The ClrInfo of the current runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget">
            <summary>
            Returns the DataTarget associated with this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ServerGC">
            <summary>
            Whether or not the process is running in server GC mode or not.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateGCThreads">
            <summary>
            Enumerates the OS thread ID of GC threads in the runtime.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.HeapCount">
            <summary>
            The number of logical GC heaps in the process.  This is always 1 for a workstation
            GC, and usually it's the number of logical processors in a server GC application.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.AppDomains">
            <summary>
            Enumerates the list of appdomains in the process.  Note the System appdomain and Shared
            AppDomain are omitted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SystemDomain">
            <summary>
            Give access to the System AppDomain
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SharedDomain">
            <summary>
            Give access to the Shared AppDomain
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateFinalizerQueueObjectAddresses">
            <summary>
            Enumerates all objects currently on the finalizer queue.  (Not finalizable objects, but objects
            which have been collected and will be imminently finalized.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateFinalizerQueue">
            <summary>
            Enumerates all objects currently on the finalizer queue.  (Not finalizable objects, but objects
            which have been collected and will be imminently finalized.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByHandle(System.UInt64)">
            <summary>
            Returns a ClrMethod by its internal runtime handle (on desktop CLR this is a MethodDesc).
            </summary>
            <param name="methodHandle">The method handle (MethodDesc) to look up.</param>
            <returns>The ClrMethod for the given method handle, or null if no method was found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetCcwDataFromAddress(System.UInt64)">
            <summary>
            Returns the CCW data associated with the given address.  This is used when looking at stowed
            exceptions in CLR.
            </summary>
            <param name="addr">The address of the CCW obtained from stowed exception data.</param>
            <returns>The CcwData describing the given CCW, or null.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetCcwDataByAddress(System.UInt64)">
            <summary>
            Returns the CCW data associated with the given address.  This is used when looking at stowed
            exceptions in CLR.
            </summary>
            <param name="addr">The address of the CCW obtained from stowed exception data.</param>
            <returns>The CcwData describing the given CCW, or null.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadVirtual(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read data out of the target process.
            </summary>
            <param name="address">The address to start the read from.</param>
            <param name="buffer">The buffer to write memory to.</param>
            <param name="bytesRequested">How many bytes to read (must be less than/equal to buffer.Length)</param>
            <param name="bytesRead">The number of bytes actually read out of the process.  This will be less than
            bytes requested if the request falls off the end of an allocation.</param>
            <returns>False if the memory is not readable (free or no read permission), true if *some* memory was read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read data out of the target process.
            </summary>
            <param name="address">The address to start the read from.</param>
            <param name="buffer">The buffer to write memory to.</param>
            <param name="bytesRequested">How many bytes to read (must be less than/equal to buffer.Length)</param>
            <param name="bytesRead">The number of bytes actually read out of the process.  This will be less than
            bytes requested if the request falls off the end of an allocation.</param>
            <returns>False if the memory is not readable (free or no read permission), true if *some* memory was read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Reads a pointer value out of the target process.  This function reads only the target's pointer size,
            so if this is used on an x86 target, only 4 bytes is read and written to val.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="value">The value at that address.</param>
            <returns>True if the read was successful, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateHandles">
            <summary>
            Enumerates a list of GC handles currently in the process.  Note that this list may be incomplete
            depending on the state of the process when we attempt to walk the handle table.
            </summary>
            <returns>The list of GC handles in the process, NULL on catastrophic error.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetThreadPool">
            <summary>
            Returns data on the CLR thread pool for this runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByAddress(System.UInt64)">
            <summary>
            Attempts to get a ClrMethod for the given instruction pointer.  This will return NULL if the
            given instruction pointer is not within any managed method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateModules">
            <summary>
            Enumerates all modules in the process.
            </summary>
            <returns>An enumeration of modules.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Modules">
            <summary>
            A list of all modules loaded into the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.  After calling this function, you must discard ALL ClrMD objects
            you have cached other than DataTarget and ClrRuntime and re-request the objects and data you need.
            (E.G. if you want to use the ClrHeap object after calling flush, you must call ClrRuntime.GetHeap
            again after Flush to get a new instance.)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime.RuntimeFlushedCallback">
            <summary>
            Delegate called when the RuntimeFlushed event is triggered.
            </summary>
            <param name="runtime">Which runtime was flushed.</param>
        </member>
        <member name="E:Microsoft.Diagnostics.Runtime.ClrRuntime.RuntimeFlushed">
            <summary>
            Called whenever the runtime is being flushed.  All references to ClrMD objects need to be released
            and not used for the given runtime after this call.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.OnRuntimeFlushed">
            <summary>
            Call when flushing the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.HasArrayComponentMethodTables">
            <summary>
            Whether or not the runtime has component method tables for arrays.  This is an extra field in
            array objects on the heap, which was removed in v4.6 of desktop clr.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadPool">
            <summary>
            Provides information about CLR's threadpool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.TotalThreads">
            <summary>
            The total number of threadpool worker threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.RunningThreads">
            <summary>
            The number of running threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.IdleThreads">
            <summary>
            The number of idle threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinThreads">
            <summary>
            The minimum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxThreads">
            <summary>
            The maximum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinCompletionPorts">
            <summary>
            Returns the minimum number of completion ports (if any).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxCompletionPorts">
            <summary>
            Returns the maximum number of completion ports.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.CpuUtilization">
            <summary>
            Returns the CPU utilization of the threadpool (as a percentage out of 100).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.FreeCompletionPortCount">
            <summary>
            The number of free completion port threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxFreeCompletionPorts">
            <summary>
            The maximum number of free completion port threads.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateNativeWorkItems">
            <summary>
            Enumerates the work items on the threadpool (native side).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateManagedWorkItems">
            <summary>
            Enumerates work items on the thread pool (managed side).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ManagedWorkItem">
            <summary>
            A managed threadpool object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Object">
            <summary>
            The object address of this entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Type">
            <summary>
            The type of Object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.WorkItemKind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.Unknown">
            <summary>
            Unknown.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncTimer">
            <summary>
            Callback for an async timer.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncCallback">
            <summary>
            Async callback.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.QueueUserWorkItem">
            <summary>
            From ThreadPool.QueueUserWorkItem.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.TimerDelete">
            <summary>
            Timer delete callback.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.NativeWorkItem">
            <summary>
            Represents a work item on CLR's thread pool (native side).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Kind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Callback">
            <summary>
            Returns the callback's address.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Data">
            <summary>
            Returns the pointer to the user's data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HandleType">
            <summary>
            Types of Clr handles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakShort">
            <summary>
            Weak, short lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakLong">
            <summary>
            Weak, long lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Strong">
            <summary>
            Strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Pinned">
            <summary>
            Strong handle, prevents relocation of target object.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.RefCount">
            <summary>
            RefCounted handle (strong when the reference count is greater than 0).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Dependent">
            <summary>
            A weak handle which may keep its "secondary" object alive if the "target" object is also alive.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.AsyncPinned">
            <summary>
            A strong, pinned handle (keeps the target object from being relocated), used for async IO operations.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.SizedRef">
            <summary>
            Strong handle used internally for book keeping.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandle">
            <summary>
            Represents a Clr handle in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Address">
            <summary>
            The address of the handle itself.  That is, *Address == Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Object">
            <summary>
            The Object the handle roots.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Type">
            <summary>
            The the type of the Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Strong">
            <summary>
            Whether the handle is strong (roots the object) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsStrong">
            <summary>
            Whether the handle is strong (roots the object) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsPinned">
            <summary>
            Whether or not the handle pins the object (doesn't allow the GC to
            relocate it) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.HandleType">
            <summary>
            Gets the type of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.RefCount">
            <summary>
            If this handle is a RefCount handle, this returns the reference count.
            RefCount handles with a RefCount > 0 are strong.
            NOTE: v2 CLR CANNOT determine the RefCount.  We always set the RefCount
                  to 1 in a v2 query since a strong RefCount handle is the common case.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentTarget">
            <summary>
            Set only if the handle type is a DependentHandle.  Dependent handles add
            an extra edge to the object graph.  Meaning, this.Object now roots the
            dependent target, but only if this.Object is alive itself.
            NOTE: CLRs prior to v4.5 cannot obtain the dependent target.  This field will
                  be 0 for any CLR prior to v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentType">
            <summary>
            The type of the dependent target, if non 0.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.AppDomain">
            <summary>
            The AppDomain the handle resides in.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHandle.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType">
            <summary>
            Types of memory regions in a Clr process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LowFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HighFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.StubHeap">
            <summary>
            Data on the stub heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.IndcellHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LookupHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ResolveHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.DispatchHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.CacheEntryHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitHostCodeHeap">
            <summary>
            Heap for JIT code data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitLoaderCodeHeap">
            <summary>
            Heap for JIT loader data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleThunkHeap">
            <summary>
            Heap for module jump thunks.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleLookupTableHeap">
            <summary>
            Heap for module lookup tables.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.GCSegment">
            <summary>
            A segment on the GC heap (committed memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ReservedGCSegment">
            <summary>
            A segment on the GC heap (reserved, but not committed, memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HandleTableChunk">
            <summary>
            A portion of Clr's handle table.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegion">
            <summary>
            Represents a region of memory in the process which Clr allocated and controls.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Address">
            <summary>
            The start address of the memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Size">
            <summary>
            The size of the memory region in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Type">
            <summary>
            The type of heap/memory that the region contains.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.AppDomain">
            <summary>
            The AppDomain pointer that corresponds to this heap.  You can obtain the
            name of the AppDomain index or name by calling the appropriate function
            on RuntimeBase.
            Note:  HasAppDomainData must be true before getting this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Module">
            <summary>
            The Module pointer that corresponds to this heap.  You can obtain the
            filename of the module with this property.
            Note:  HasModuleData must be true or this property will be null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.HeapNumber">
            <summary>
            Returns the heap number associated with this data.  Returns -1 if no
            GC heap is associated with this memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.GCSegmentType">
            <summary>
            Returns the gc segment type associated with this data.  Only callable if
            HasGCHeapData is true.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString(System.Boolean)">
            <summary>
            Returns a string describing the region of memory (for example "JIT Code Heap"
            or "GC Segment").
            </summary>
            <param name="detailed">Whether or not to include additional data such as the module,
            AppDomain, or GC Heap associaed with it.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrameType">
            <summary>
            The type of frame the ClrStackFrame represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.ManagedMethod">
            <summary>
            Indicates this stack frame is a standard managed method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.Runtime">
            <summary>
            Indicates this stack frame is a special stack marker that the Clr runtime leaves on the stack.
            Note that the ClrStackFrame may still have a ClrMethod associated with the marker.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrame">
            <summary>
            A frame in a managed stack trace.  Note you can call ToString on an instance of this object to get the
            function name (or clr!Frame name) similar to SOS's !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.InstructionPointer">
            <summary>
            The instruction pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.StackPointer">
            <summary>
            The stack pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind">
            <summary>
            The type of frame (managed or internal).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.DisplayString">
            <summary>
            The string to display in a stack trace.  Similar to !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Method">
            <summary>
            Returns the ClrMethod which corresponds to the current stack frame.  This may be null if the
            current frame is actually a CLR "Internal Frame" representing a marker on the stack, and that
            stack marker does not have a managed method associated with it.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStackFrame.GetFileAndLineNumber">
            <summary>
            Returns the source file and line number of the location represented by this stack frame.
            This will return null if the location cannot be determined (or the module containing it does
            not have PDBs loaded).
            </summary>
            <returns>The file and line number for this stack frame, null if not found.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.ModuleName">
            <summary>
            Returns the module name to use for building the stack trace.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrame.UnknownModuleName">
            <summary>
            The default name used when a module name cannot be calculated.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.SourceLocation">
            <summary>
            A SourceLocation represents a point in the source code.  That is the file and the line number.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.FilePath">
            <summary>
            The source file for the code
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.LineNumber">
            <summary>
            The line number for the code.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.LineNumberEnd">
            <summary>
            The end line number of the location (if multiline this will be different from LineNumber).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.ColStart">
            <summary>
            The start column of the source line.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.ColEnd">
            <summary>
            The end column of the source line.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.SourceLocation.ToString">
            <summary>
            Generates a human readable form of the source location.
            </summary>
            <returns>File:Line-Line</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThread">
            <summary>
            Represents a managed thread in the target process.  Note this does not wrap purely native threads
            in the target process (that is, threads which have never run managed code before).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Runtime">
            <summary>
            Gets the runtime associated with this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.GcMode">
            <summary>
            The suspension state of the thread according to the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsFinalizer">
            <summary>
            Returns true if this is the finalizer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Address">
            <summary>
            The address of the underlying datastructure which makes up the Thread object.  This
            serves as a unique identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAlive">
            <summary>
            Returns true if the thread is alive in the process, false if this thread was recently terminated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.OSThreadId">
            <summary>
            The OS thread id for the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.ManagedThreadId">
            <summary>
            The managed thread ID (this is equivalent to System.Threading.Thread.ManagedThreadId
            in the target process).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.AppDomain">
            <summary>
            The AppDomain the thread is running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.LockCount">
            <summary>
            The number of managed locks (Monitors) the thread has currently entered but not left.
            This will be highly inconsistent unless the process is stopped.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Teb">
            <summary>
            The TEB (thread execution block) address in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackBase">
            <summary>
            The base of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackLimit">
            <summary>
            The limit of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackObjects">
            <summary>
            Enumerates the GC references (objects) on the stack.  This is equivalent to
            EnumerateStackObjects(true).
            </summary>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackObjects(System.Boolean)">
            <summary>
            Enumerates the GC references (objects) on the stack.
            </summary>
            <param name="includePossiblyDead">Include all objects found on the stack.  Passing
            false attempts to replicate the behavior of the GC, reporting only live objects.</param>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackTrace">
            <summary>
            Returns the managed stack trace of the thread.  Note that this property may return incomplete
            data in the case of a bad stack unwind or if there is a very large number of methods on the stack.
            (This is usually caused by a stack overflow on the target thread, stack corruption which leads to
            a bad stack unwind, or other inconsistent state in the target debuggee.)
            
            Note: This property uses a heuristic to attempt to detect bad unwinds to stop enumerating
            frames by inspecting the stack pointer and instruction pointer of each frame to ensure the stack
            walk is "making progress".  Additionally we cap the number of frames returned by this method
            as another safegaurd.  This means we may not have all frames even if the stack walk was making
            progress.
            
            If you want to ensure that you receive an un-clipped stack trace, you should use EnumerateStackTrace
            instead of this property, and be sure to handle the case of repeating stack frames.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackTrace">
            <summary>
            Enumerates a stack trace for a given thread.  Note this method may loop infinitely in the case of
            stack corruption or other stack unwind issues which can happen in practice.  When enumerating frames
            out of this method you should be careful to either set a maximum loop count, or to ensure the stack
            unwind is making progress by ensuring that ClrStackFrame.StackPointer is making progress (though it
            is expected that sometimes two frames may return the same StackPointer in some corner cases).
            </summary>
            <returns>An enumeration of stack frames.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentException">
            <summary>
            Returns the exception currently on the thread.  Note that this field may be null.  Also note
            that this is basically the "last thrown exception", and may be stale...meaning the thread could
            be done processing the exception but a crash dump was taken before the current exception was
            cleared off the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGC">
            <summary>
            Returns if this thread is a GC thread.  If the runtime is using a server GC, then there will be
            dedicated GC threads, which this will indicate.  For a runtime using the workstation GC, this flag
            will only be true for a thread which is currently running a GC (and the background GC thread).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebuggerHelper">
            <summary>
            Returns if this thread is the debugger helper thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolTimer">
            <summary>
            Returns true if this thread is a threadpool timer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolCompletionPort">
            <summary>
            Returns true if this thread is a threadpool IO completion port.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWorker">
            <summary>
            Returns true if this is a threadpool worker thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWait">
            <summary>
            Returns true if this is a threadpool wait thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolGate">
            <summary>
            Returns true if this is the threadpool gate thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSuspendingEE">
            <summary>
            Returns if this thread currently suspending the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsShutdownHelper">
            <summary>
            Returns true if this thread is currently the thread shutting down the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAbortRequested">
            <summary>
            Returns true if an abort was requested for this thread (such as Thread.Abort, or AppDomain unload).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAborted">
            <summary>
            Returns true if this thread was aborted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGCSuspendPending">
            <summary>
            Returns true if the GC is attempting to suspend this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUserSuspended">
            <summary>
            Returns true if the user has suspended the thread (using Thread.Suspend).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebugSuspended">
            <summary>
            Returns true if the debugger has suspended the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsBackground">
            <summary>
            Returns true if this thread is a background thread.  (That is, if the thread does not keep the
            managed execution environment alive and running.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUnstarted">
            <summary>
            Returns true if this thread was created, but not started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsCoInitialized">
            <summary>
            Returns true if the Clr runtime called CoIntialize for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSTA">
            <summary>
            Returns true if this thread is in a COM single threaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsMTA">
            <summary>
            Returns true if the thread is a COM multithreaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.BlockingObjects">
            <summary>
            Returns the object this thread is blocked waiting on, or null if the thread is not blocked.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Architecture">
            <summary>
            The architecture of a process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Unknown">
            <summary>
            Unknown.  Should never be exposed except in case of error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.X86">
            <summary>
            x86.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Amd64">
            <summary>
            x64
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Arm">
            <summary>
            ARM
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrElementType">
            <summary>
            This is a representation of the metadata element type.  These values
            directly correspond with Clr's CorElementType.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown">
            <summary>
            Not one of the other types.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Boolean">
            <summary>
            ELEMENT_TYPE_BOOLEAN
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Char">
            <summary>
            ELEMENT_TYPE_CHAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int8">
            <summary>
            ELEMENT_TYPE_I1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt8">
            <summary>
            ELEMENT_TYPE_U1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int16">
            <summary>
            ELEMENT_TYPE_I2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt16">
            <summary>
            ELEMENT_TYPE_U2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int32">
            <summary>
            ELEMENT_TYPE_I4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt32">
            <summary>
            ELEMENT_TYPE_U4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int64">
            <summary>
            ELEMENT_TYPE_I8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt64">
            <summary>
            ELEMENT_TYPE_U8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Float">
            <summary>
            ELEMENT_TYPE_R4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Double">
            <summary>
            ELEMENT_TYPE_R8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.String">
            <summary>
            ELEMENT_TYPE_STRING
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Pointer">
            <summary>
            ELEMENT_TYPE_PTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Struct">
            <summary>
            ELEMENT_TYPE_VALUETYPE
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Class">
            <summary>
            ELEMENT_TYPE_CLASS
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Array">
            <summary>
            ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeInt">
            <summary>
            ELEMENT_TYPE_I
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeUInt">
            <summary>
            ELEMENT_TYPE_U
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.FunctionPointer">
            <summary>
            ELEMENT_TYPE_FNPTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Object">
            <summary>
            ELEMENT_TYPE_OBJECT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.SZArray">
            <summary>
            ELEMENT_TYPE_SZARRAY
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInterface">
            <summary>
            An interface implementation in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.Name">
            <summary>
            The typename of the interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.BaseInterface">
            <summary>
            The interface that this interface inherits from.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.ToString">
            <summary>
            Display string for this interface.
            </summary>
            <returns>Display string for this interface.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="obj">Object to compare to.</param>
            <returns>True if this interface equals another.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.GetHashCode">
            <summary>
            GetHashCode override.
            </summary>
            <returns>A hashcode for this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrType">
            <summary>
            A representation of a type in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Index">
            <summary>
            The index of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MethodTable">
            <summary>
            Retrieves the first type handle in EnumerateMethodTables().  MethodTables
            are unique to an AppDomain/Type pair, so when there are multiple domains
            there will be multiple MethodTable for a class.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateMethodTables">
            <summary>
            Enumerates all MethodTable for this type in the process.  MethodTable
            are unique to an AppDomain/Type pair, so when there are multiple domains
            there may be multiple MethodTable.  Note that even if a type could be
            used in an AppDomain, that does not mean we actually have a MethodTable
            if the type hasn't been created yet.
            </summary>
            <returns>An enumeration of MethodTable in the process for this given
            type.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MetadataToken">
            <summary>
            Returns the metadata token of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Name">
            <summary>
            Types have names.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetSize(System.UInt64)">
            <summary>
            GetSize returns the size in bytes for the total overhead of the object 'objRef'.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateRefsOfObject(System.UInt64,System.Action{System.UInt64,System.Int32})">
            <summary>
            EnumeationRefsOfObject will call 'action' once for each object reference inside 'objRef'.  
            'action' is passed the address of the outgoing refernece as well as an integer that
            represents the field offset.  While often this is the physical offset of the outgoing
            refernece, abstractly is simply something that can be given to GetFieldForOffset to 
            return the field information for that object reference  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateRefsOfObjectCarefully(System.UInt64,System.Action{System.UInt64,System.Int32})">
            <summary>
            Does the same as EnumerateRefsOfObject, but does additional bounds checking to ensure
            we don't loop forever with inconsistent data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers">
            <summary>
            Returns true if the type CAN contain references to other objects.  This is used in optimizations 
            and 'true' can always be returned safely.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Heap">
            <summary>
            All types know the heap they belong to.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsRuntimeType">
            <summary>
            Returns true if this object is a 'RuntimeType' (that is, the concrete System.RuntimeType class
            which is what you get when calling "typeof" in C#).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetRuntimeType(System.UInt64)">
            <summary>
            Returns the concrete type (in the target process) that this RuntimeType represents.
            Note you may only call this function if IsRuntimeType returns true.
            </summary>
            <param name="obj">The RuntimeType object to get the concrete type for.</param>
            <returns>The underlying type that this RuntimeType actually represents.  May return null if the
                     underlying type has not been fully constructed by the runtime, or if the underlying type
                     is actually a typehandle (which unfortunately ClrMD cannot convert into a ClrType due to
                     limitations in the underlying APIs.  (So always null-check the return value of this
                     function.) </returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Module">
            <summary>
            Returns the module this type is defined in.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetMethod(System.UInt32)">
            <summary>
            Returns a method based on its token.
            </summary>
            <param name="token">The token of the method to return.</param>
            <returns>A ClrMethod for the given token, null if no such methodDesc exists.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementType">
            <summary>
            Returns the ElementType of this Type.  Can return ELEMENT_TYPE_VOID on error.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrimitive">
            <summary>
            Returns true if this type is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this type is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsValueClass">
            <summary>
            Returns true if this type is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this type is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsObjectReference">
            <summary>
            Returns true if this type is an object reference, false otherwise.
            </summary>
            <returns>True if this type is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Interfaces">
            <summary>
            Returns the list of interfaces this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizeSuppressed(System.UInt64)">
            <summary>
            Returns true if the finalization is suppressed for an object.  (The user program called
            System.GC.SupressFinalize.  The behavior of this function is undefined if the object itself
            is not finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizable">
            <summary>
            Returns whether objects of this type are finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPublic">
            <summary>
            Returns true if this type is marked Public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrivate">
            <summary>
            returns true if this type is marked Private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInternal">
            <summary>
            Returns true if this type is accessable only by items in its own assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsProtected">
            <summary>
            Returns true if this nested type is accessable only by subtypes of its outer type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsAbstract">
            <summary>
            Returns true if this class is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsSealed">
            <summary>
            Returns true if this class is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInterface">
            <summary>
            Returns true if this type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Fields">
            <summary>
            Returns all possible fields in this type.   It does not return dynamically typed fields.  
            Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticFields">
            <summary>
            Returns a list of static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ThreadStaticFields">
            <summary>
            Returns a list of thread static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Methods">
            <summary>
            Gets the list of methods this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldForOffset(System.Int32,System.Boolean,Microsoft.Diagnostics.Runtime.ClrInstanceField@,System.Int32@)">
            <summary>
            When you enumerate a object, the offset within the object is returned.  This offset might represent
            nested fields (obj.Field1.Field2).    GetFieldOffset returns the first of these field (Field1), 
            and 'remaining' offset with the type of Field1 (which must be a struct type).   Calling 
            GetFieldForOffset repeatedly until the childFieldOffset is 0 will retrieve the whole chain.  
            </summary>
            <returns>true if successful.  Will fail if it 'this' is an array type</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetStaticFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Convenience function which dereferences fields.  For example, if you wish to dereference m_foo.m_bar.m_baz, you can pass:
            { "m_foo", "m_bar", "m_baz" } into this function's second parameter to dereference those fields to get the value.
            Throws Exception if a field you expect does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String},System.Object@)">
            <summary>
            Same as GetFieldValue but returns true on success, false on failure, and does not throw.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseType">
            <summary>
            If this type inherits from another type, this is that type.  Can return null if it does not inherit (or is unknown)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsCCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Com-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetCCWData(System.UInt64)">
            <summary>
            Returns the CCWData for the given object.  Note you may only call this function if IsCCW returns true.
            </summary>
            <returns>The CCWData associated with the object, undefined result of obj is not a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsRCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Runtime-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is an RCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetRCWData(System.UInt64)">
            <summary>
            Returns the RCWData for the given object.  Note you may only call this function if IsRCW returns true.
            </summary>
            <returns>The RCWData associated with the object, undefined result of obj is not a RCW.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPointer">
            <summary>
            Indicates if the type is in fact a pointer. If so, the pointer operators
            may be used.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ComponentType">
            <summary>
            Gets the type of the element referenced by the pointer.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsArray">
            <summary>
            A type is an array if you can use the array operators below, Abstractly arrays are objects 
            that whose children are not statically known by just knowing the type.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ArrayComponentType">
            <summary>
            Gets the type of the elements in the array.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayLength(System.UInt64)">
            <summary>
            If the type is an array, then GetArrayLength returns the number of elements in the array.  Undefined
            behavior if this type is not an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementAddress(System.UInt64,System.Int32)">
            <summary>
            Returns the absolute address to the given array element.  You may then make a direct memory read out
            of the process to get the value if you want.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementValue(System.UInt64,System.Int32)">
            <summary>
            Returns the array element value at the given index.  Returns 'null' if the array element is of type
            VALUE_CLASS.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementSize">
            <summary>
            Returns the size of individual elements of an array.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseSize">
            <summary>
            Returns the base size of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsString">
            <summary>
            Returns true if this type is System.String.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFree">
            <summary>
            Returns true if this type represents free space on the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsException">
            <summary>
            Returns true if this type is an exception (that is, it derives from System.Exception).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum">
            <summary>
            Returns true if this type is an enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumElementType">
            <summary>
            Returns the element type of this enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumNames">
            <summary>
            Returns a list of names in the enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumName(System.Object)">
            <summary>
            Gets the name of the value in the enum, or null if the value doesn't have a name.
            This is a convenience function, and has undefined results if the same value appears
            twice in the enum.
            </summary>
            <param name="value">The value to lookup.</param>
            <returns>The name of one entry in the enum with this value, or null if none exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumName(System.Int32)">
            <summary>
            Gets the name of the value in the enum, or null if the value doesn't have a name.
            This is a convenience function, and has undefined results if the same value appears
            twice in the enum.
            </summary>
            <param name="value">The value to lookup.</param>
            <returns>The name of one entry in the enum with this value, or null if none exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetEnumValue(System.String,System.Int32@)">
            <summary>
            Attempts to get the integer value for a given enum entry.  Note you should only call this function if
            GetEnumElementType returns ELEMENT_TYPE_I4.
            </summary>
            <param name="name">The name of the value to get (taken from GetEnumNames).</param>
            <param name="value">The value to write out.</param>
            <returns>True if we successfully filled value, false if 'name' is not a part of the enumeration.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetEnumValue(System.String,System.Object@)">
            <summary>
            Attempts to get the value for a given enum entry.  The type of "value" can be determined by the
            return value of GetEnumElementType.
            </summary>
            <param name="name">The name of the value to get (taken from GetEnumNames).</param>
            <param name="value">The value to write out.</param>
            <returns>True if we successfully filled value, false if 'name' is not a part of the enumeration.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.HasSimpleValue">
            <summary>
            Returns true if instances of this type have a simple value.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetValue(System.UInt64)">
            <summary>
            Returns the simple value of an instance of this type.  Undefined behavior if HasSimpleValue returns false.
            For example ELEMENT_TYPE_I4 is an "int" and the return value of this function would be an int.
            </summary>
            <param name="address">The address of an instance of this type.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrField">
            <summary>
            A representation of a field in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Name">
            <summary>
            The name of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Type">
            <summary>
            The type of the field.  Note this property may return null on error.  There is a bug in several versions
            of our debugging layer which causes this.  You should always null-check the return value of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ElementType">
            <summary>
            Returns the element type of this field.  Note that even when Type is null, this should still tell you
            the element type of the field.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsPrimitive">
            <summary>
            Returns true if this field is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this field is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsValueClass">
            <summary>
            Returns true if this field is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this field is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsObjectReference">
            <summary>
            Returns true if this field is an object reference, false otherwise.
            </summary>
            <returns>True if this field is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Size">
            <summary>
            Gets the size of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPublic">
            <summary>
            Returns true if this field is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrivate">
            <summary>
            Returns true if this field is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsInternal">
            <summary>
            Returns true if this field is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsProtected">
            <summary>
            Returns true if this field is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.HasSimpleValue">
            <summary>
            Returns true if this field has a simple value (meaning you may call "GetFieldValue" in one of the subtypes
            of this class).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInstanceField">
            <summary>
            Represents an instance field of a type.   Fundamentally it respresents a name and a type 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64,System.Boolean)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64,System.Boolean)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetValue(System.UInt64)">
            <summary>
            Returns the value of this field.  Equivalent to GetFieldValue(objRef, false).
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetValue(System.UInt64,System.Boolean)">
            <summary>
            Returns the value of this field, optionally specifying if this field is
            on a value class which is on the interior of another object.
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetValue(System.UInt64,System.Boolean,System.Boolean)">
            <summary>
            Returns the value of this field, optionally specifying if this field is
            on a value class which is on the interior of another object.
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <param name="convertStrings">When true, the value of a string field will be 
            returned as a System.String object; otherwise the address of the String object will be returned.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64,System.Boolean)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStaticField">
            <summary>
            Represents a static field in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.IsInitialized(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns whether this static field has been initialized in a particular AppDomain
            or not.  If a static variable has not been initialized, then its class constructor
            may have not been run yet.  Calling GetFieldValue on an uninitialized static
            will result in returning either NULL or a value of 0.
            </summary>
            <param name="appDomain">The AppDomain to see if the variable has been initialized.</param>
            <returns>True if the field has been initialized (even if initialized to NULL or a default
            value), false if the runtime has not initialized this variable.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Gets the value of the static field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the value.</param>
            <returns>The value of this static field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,System.Boolean)">
            <summary>
            Gets the value of the static field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the value.</param>
            <param name="convertStrings">When true, the value of a string field will be 
            returned as a System.String object; otherwise the address of the String object will be returned.</param>
            <returns>The value of this static field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns the address of the static field's value in memory.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStaticField.HasDefaultValue">
            <summary>
            Returns true if the static field has a default value (and if we can obtain it).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetDefaultValue">
            <summary>
            The default value of the field.
            </summary>
            <returns>The default value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadStaticField">
            <summary>
            Represents a thread static value in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the value of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's value.</param>
            <param name="thread">The thread on which to get the field's value.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread,System.Boolean)">
            <summary>
            Gets the value of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's value.</param>
            <param name="thread">The thread on which to get the field's value.</param>
            <param name="convertStrings">When true, the value of a string field will be 
            returned as a System.String object; otherwise the address of the String object will be returned.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the address of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <param name="thread">The thread on which to get the field's address.</param>
            <returns>The address of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrException">
            <summary>
            A wrapper class for exception objects which help with common tasks for exception objects.
            Create this using GCHeap.GetExceptionObject.  You may call that when GCHeapType.IsException
            returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Type">
            <summary>
            Returns the GCHeapType for this exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Message">
            <summary>
            Returns the exception message.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Address">
            <summary>
            Returns the address of the exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Inner">
            <summary>
            Returns the inner exception, if one exists, null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.HResult">
            <summary>
            Returns the HRESULT associated with this exception (or S_OK if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.StackTrace">
            <summary>
            Returns the StackTrace for this exception.  Note that this may be empty or partial depending
            on the state of the exception in the process.  (It may have never been thrown or we may be in
            the middle of constructing the stackwalk.)  This returns an empty list if no stack trace is
            associated with this exception object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComInterfaceData">
            <summary>
            The COM implementation details of a single CCW entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.Type">
            <summary>
            The CLR type this represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.InterfacePointer">
            <summary>
            The interface pointer of Type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CcwData">
            <summary>
            Helper for Com Callable Wrapper objects.  (CCWs are CLR objects exposed to native code as COM
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Object">
            <summary>
            Returns the pointer to the managed object representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Handle">
            <summary>
            Returns the CLR handle associated with this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.RefCount">
            <summary>
            Returns the refcount of this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Interfaces">
            <summary>
            Returns the interfaces that this CCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RcwData">
            <summary>
            Helper for Runtime Callable Wrapper objects.  (RCWs are COM objects which are exposed to the runtime
            as managed objects.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.VTablePointer">
            <summary>
            Returns the external VTable associated with this RCW.  (It's useful to resolve the VTable as a symbol
            which will tell you what the underlying native type is...if you have the symbols for it loaded).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.RefCount">
            <summary>
            Returns the RefCount of the RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Object">
            <summary>
            Returns the managed object associated with this of RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Disconnected">
            <summary>
            Returns true if the RCW is disconnected from the underlying COM type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.CreatorThread">
            <summary>
            Returns the thread which created this RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.WinRTObject">
            <summary>
            Returns the internal WinRT object associated with this RCW (if one exists).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Interfaces">
            <summary>
            Returns the list of interfaces this RCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MethodCompilationType">
            <summary>
            The way a method was JIT'ed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.None">
            <summary>
            Method is not yet JITed and no NGEN image exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Jit">
            <summary>
            Method was JITed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Ngen">
            <summary>
            Method was NGEN'ed (pre-JITed).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMethod">
            <summary>
            Represents a method on a class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MethodDesc">
            <summary>
            Retrieves the first MethodDesc in EnumerateMethodDescs().  For single
            AppDomain programs this is the only MethodDesc.  MethodDescs
            are unique to an Method/AppDomain pair, so when there are multiple domains
            there will be multiple MethodDescs for a method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.EnumerateMethodDescs">
            <summary>
            Enumerates all method descs for this method in the process.  MethodDescs
            are unique to an Method/AppDomain pair, so when there are multiple domains
            there will be multiple MethodDescs for a method.
            </summary>
            <returns>An enumeration of method handles in the process for this given
            method.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Name">
            <summary>
            The name of the method.  For example, "void System.Foo.Bar(object o, int i)" would return "Bar".
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetFullSignature">
            <summary>
            Returns the full signature of the function.  For example, "void System.Foo.Bar(object o, int i)"
            would return "System.Foo.Bar(System.Object, System.Int32)"
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.NativeCode">
            <summary>
            Returns the instruction pointer in the target process for the start of the method's assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetSourceLocationForOffset(System.UInt64)">
            <summary>
            Returns the file and line number for the given offset in the method.
            </summary>
            <param name="nativeOffset">The offset within the method (not the address in memory) of the instruction pointer.</param>
            <returns>The file and line number for the given offset.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetILOffset(System.UInt64)">
            <summary>
            Gets the ILOffset of the given address within this method.
            </summary>
            <param name="addr">The absolute address of the code (not a relative offset).</param>
            <returns>The IL offset of the given address.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.CompilationType">
            <summary>
            Returns the way this method was compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.ILOffsetMap">
            <summary>
            Returns the IL to native offset mapping.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MetadataToken">
            <summary>
            Returns the metadata token of the current method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Type">
            <summary>
            Returns the enclosing type of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPublic">
            <summary>
            Returns if this method is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPrivate">
            <summary>
            Returns if this method is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsInternal">
            <summary>
            Returns if this method is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsProtected">
            <summary>
            Returns if this method is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsStatic">
            <summary>
            Returns if this method is static.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsFinal">
            <summary>
            Returns if this method is final.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPInvoke">
            <summary>
            Returns if this method is a PInvoke.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsSpecialName">
            <summary>
            Returns if this method is a special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsRTSpecialName">
            <summary>
            Returns if this method is runtime special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsVirtual">
            <summary>
            Returns if this method is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsAbstract">
            <summary>
            Returns if this method is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsConstructor">
            <summary>
            Returns whether this method is an instance constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsClassConstructor">
            <summary>
            Returns whether this method is a static constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILToNativeMap">
            <summary>
            A method's mapping from IL to native offsets.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.ILOffset">
            <summary>
            The IL offset for this entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.StartAddress">
            <summary>
            The native start offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.EndAddress">
            <summary>
            The native end offset of this IL entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ILToNativeMap.ToString">
            <summary>
            To string.
            </summary>
            <returns>A visual display of the map entry.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap._reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VersionInfo">
            <summary>
            Represents the version of a DLL.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Major">
            <summary>
            In a version 'A.B.C.D', this field represents 'A'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Minor">
            <summary>
            In a version 'A.B.C.D', this field represents 'B'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Revision">
            <summary>
            In a version 'A.B.C.D', this field represents 'C'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Patch">
            <summary>
            In a version 'A.B.C.D', this field represents 'D'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The A.B.C.D version prepended with 'v'.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrFlavor">
            <summary>
            Returns the "flavor" of CLR this module represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Desktop">
            <summary>
            This is the full version of CLR included with windows.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.CoreCLR">
            <summary>
            This is a reduced CLR used in other projects.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Redhawk">
            <summary>
            Same as .Net Native.  This is obsolete and will be removed. Use ClrFlavor.Native instead.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Native">
            <summary>
            Used for .Net Native.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfo">
            <summary>
            Represents information about a single Clr runtime in a process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Version">
            <summary>
            The version number of this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Flavor">
            <summary>
            The type of CLR this module represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DacInfo">
            <summary>
            Returns module information about the Dac needed create a ClrRuntime instance for this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.ModuleInfo">
            <summary>
            Returns module information about the ClrInstance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.LocalMatchingDac">
            <summary>
            Returns the location of the local dac on your machine which matches this version of Clr, or null
            if one could not be found.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryGetDacLocation">
            <summary>
            The location of the Dac on the local machine, if a matching Dac could be found.
            If this returns null it means that no matching Dac could be found, and you will
            need to make a symbol server request using DacInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryDownloadDac(Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Attemps to download the matching dac for this runtime from the symbol server.  Note that this command
            does not attempt to inspect or parse _NT_SYMBOL_PATH, so if you want to use that as a "default", you
            need to add that path to the sympath parameter manually.  This function will return a local dac location
            (and bypass the symbol server) if a matching dac exists locally on your computer.
            </summary>
            <param name="notification">A notification callback (null ok).</param>
            <returns>The local path (in the cache) of the dac if found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryDownloadDac">
            <summary>
            Attemps to download the matching dac for this runtime from the symbol server.  Note that this command
            does not attempt to inspect or parse _NT_SYMBOL_PATH, so if you want to use that as a "default", you
            need to add that path to the sympath parameter manually.  This function will return a local dac location
            (and bypass the symbol server) if a matching dac exists locally on your computer.
            </summary>
            <returns>The local path (in the cache) of the dac if found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime">
            <summary>
            Creates a runtime from the given Dac file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime(System.Object)">
            <summary>
            Creates a runtime from a given IXClrDataProcess interface.  Used for debugger plugins.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime(System.String,System.Boolean)">
            <summary>
            Creates a runtime from the given Dac file on disk.
            </summary>
            <param name="dacFilename">A full path to the matching mscordacwks for this process.</param>
            <param name="ignoreMismatch">Whether or not to ignore mismatches between </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>A version string for this Clr runtime.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CompareTo(System.Object)">
            <summary>
            IComparable.  Sorts the object by version.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>-1 if less, 0 if equal, 1 if greater.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AttachFlag">
            <summary>
            Specifies how to attach to a live process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Invasive">
            <summary>
            Performs an invasive debugger attach.  Allows the consumer of this API to control the target
            process through normal IDebug function calls.  The process will be paused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.NonInvasive">
            <summary>
            Performs a non-invasive debugger attach.  The process will be paused by this attached (and
            for the duration of the attach) but the caller cannot control the target process.  This is
            useful when there's already a debugger attached to the process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Passive">
            <summary>
            Performs a "passive" attach, meaning no debugger is actually attached to the target process.
            The process is not paused, so queries for quickly changing data (such as the contents of the
            GC heap or callstacks) will be highly inconsistent unless the user pauses the process through
            other means.  Useful when attaching with ICorDebug (managed debugger), as you cannot use a
            non-invasive attach with ICorDebug.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PdbInfo">
            <summary>
            Information about a specific PDB instance obtained from a PE image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Guid">
            <summary>
            The Guid of the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Revision">
            <summary>
            The pdb revision.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.FileName">
            <summary>
            The filename of the pdb.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.#ctor">
            <summary>
            Creates an instance of the PdbInfo class
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.#ctor(System.String,System.Guid,System.Int32)">
            <summary>
            Creates an instance of the PdbInfo class with the corresponding properties initialized
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleInfo">
            <summary>
            Provides information about loaded modules in a DataTarget
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageBase">
            <summary>
            The base address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileSize">
            <summary>
            The filesize of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.TimeStamp">
            <summary>
            The build timestamp of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileName">
            <summary>
            The filename of the module on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IsRuntime">
            <summary>
            Returns true if this module is a native (non-managed) .Net runtime module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.GetPEFile">
            <summary>
            Returns a PEFile from a stream constructed using instance fields of this object.
            If the PEFile cannot be constructed correctly, null is returned
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IsManaged">
            <summary>
            Whether the module is managed or not.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The filename of the module.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Pdb">
            <summary>
            The PDB associated with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Version">
            <summary>
            The version information for this file.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor">
            <summary>
            Empty constructor for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Creates a ModuleInfo object with an IDataReader instance.  This is used when
            lazily evaluating VersionInfo. 
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInfo">
            <summary>
            Represents the dac dll
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInfo.GetDacRequestFileName(Microsoft.Diagnostics.Runtime.ClrFlavor,Microsoft.Diagnostics.Runtime.Architecture,Microsoft.Diagnostics.Runtime.Architecture,Microsoft.Diagnostics.Runtime.VersionInfo)">
            <summary>
            Returns the filename of the dac dll according to the specified parameters
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.PlatformAgnosticFileName">
            <summary>
            The platform-agnostice filename of the dac dll
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.TargetArchitecture">
            <summary>
            The architecture (x86 or amd64) being targeted
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInfo.#ctor(Microsoft.Diagnostics.Runtime.IDataReader,System.String,Microsoft.Diagnostics.Runtime.Architecture)">
            <summary>
            Constructs a DacInfo object with the appropriate properties initialized
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VirtualQueryData">
            <summary>
            The result of a VirtualQuery.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VirtualQueryData.BaseAddress">
            <summary>
            The base address of the allocation.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VirtualQueryData.Size">
            <summary>
             The size of the allocation.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VirtualQueryData.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="addr">Base address of the memory range.</param>
            <param name="size">The size of the memory range.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult">
            <summary>
            The result of an asynchronous memory read.  This is returned by an IDataReader
            when an async memory read is requested.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Complete">
            <summary>
            A wait handle which is signaled when the read operation is complete.
            Complete must be assigned a valid EventWaitHandle before this object is
            returned by ReadMemoryAsync, and Complete must be signaled after the
            request is completed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Address">
            <summary>
            The address to read from.  Address must be assigned to before this objct is
            returned by ReadMemoryAsync.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.BytesRequested">
            <summary>
            The number of bytes requested in this async read.  BytesRequested must be
            assigned to before this objct is returned by ReadMemoryAsync.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.BytesRead">
            <summary>
            The actual number of bytes read out of the data target.  This must be
            assigned to before Complete is signaled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Result">
            <summary>
            The result of the memory read.  This must be assigned to before Complete is
            signaled.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.#ctor">
            <summary>
            Empty constructor, no properties/fields assigned.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.#ctor(System.UInt64,System.Int32)">
            <summary>
            Constructor.  Assigns Address, BytesRequested, and Complete.  (Uses a ManualResetEvent
            for Complete).
            </summary>
            <param name="addr">The address of the memory read.</param>
            <param name="requested">The number of bytes requested.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.ToString">
            <summary>
            To string.
            </summary>
            <returns>The memory range requested.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult._read">
            <summary>
            The amount read, backing variable for BytesRead.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult._result">
            <summary>
            The actual data buffer, backing variable for Result.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IDataReader">
            <summary>
            An interface for reading data out of the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.Close">
            <summary>
            Called when the DataTarget is closing (Disposing).  Used to clean up resources.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.Flush">
            <summary>
            Informs the data reader that the user has requested all data be flushed.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetArchitecture">
            <summary>
            Gets the architecture of the target.
            </summary>
            <returns>The architecture of the target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetPointerSize">
            <summary>
            Gets the size of a pointer in the target process.
            </summary>
            <returns>The pointer size of the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules">
            <summary>
            Enumerates modules in the target process.
            </summary>
            <returns>A list of the modules in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetVersionInfo(System.UInt64,Microsoft.Diagnostics.Runtime.VersionInfo@)">
            <summary>
            Gets the version information for a given module (given by the base address of the module).
            </summary>
            <param name="baseAddress">The base address of the module to look up.</param>
            <param name="version">The version info for the given module.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <param name="bytesRead">The number of bytes actually read out of the target process.</param>
            <returns>True if any bytes were read at all, false if the read failed (and no bytes were read).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemory(System.UInt64,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <param name="bytesRead">The number of bytes actually read out of the target process.</param>
            <returns>True if any bytes were read at all, false if the read failed (and no bytes were read).</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.CanReadAsync">
            <summary>
            Returns true if this data reader can read data out of the target process asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemoryAsync(System.UInt64,System.Int32)">
            <summary>
            Reads memory from the target process asynchronously.  Only called if CanReadAsync returns true.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <returns>A data structure containing an event to wait for as well as a new byte array to read from.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.IsMinidump">
            <summary>
            Returns true if the data target is a minidump (or otherwise may not contain full heap data).
            </summary>
            <returns>True if the data target is a minidump (or otherwise may not contain full heap data).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadTeb(System.UInt32)">
            <summary>
            Gets the TEB of the specified thread.
            </summary>
            <param name="thread">The OS thread ID to get the TEB for.</param>
            <returns>The address of the thread's teb.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateAllThreads">
            <summary>
            Enumerates the OS thread ID of all threads in the process.
            </summary>
            <returns>An enumeration of all threads in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.VirtualQuery(System.UInt64,Microsoft.Diagnostics.Runtime.VirtualQueryData@)">
            <summary>
            Gets information about the given memory range.
            </summary>
            <param name="addr">An arbitrary address in the target process.</param>
            <param name="vq">The base address and size of the allocation.</param>
            <returns>True if the address was found and vq was filled, false if the address is not valid memory.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.UInt32,System.IntPtr)">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="contextSize">The size (in bytes) of the context parameter.</param>
            <param name="context">A pointer to the buffer to write to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="contextSize">The size (in bytes) of the context parameter.</param>
            <param name="context">A pointer to the buffer to write to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadPointerUnsafe(System.UInt64)">
            <summary>
            Read a pointer out of the target process.
            </summary>
            <returns>The pointer at the give address, or 0 if that pointer doesn't exist in
            the data target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadDwordUnsafe(System.UInt64)">
            <summary>
            Read an int out of the target process.
            </summary>
            <returns>The int at the give address, or 0 if that pointer doesn't exist in
            the data target.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CrashDumpReader">
            <summary>
            The type of crash dump reader to use.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.CrashDumpReader.DbgEng">
            <summary>
            Use DbgEng.  This allows the user to obtain an instance of IDebugClient through the
            DataTarget.DebuggerInterface property, at the cost of strict threading requirements.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.CrashDumpReader.ClrMD">
            <summary>
            Use a simple dump reader to read data out of the crash dump.  This allows processing
            multiple dumps (using separate DataTargets) on multiple threads, but the
            DataTarget.DebuggerInterface property will return null.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataTarget">
            <summary>
            A crash dump or live process to read out of.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadCrashDump(System.String)">
            <summary>
            Creates a DataTarget from a crash dump.
            </summary>
            <param name="fileName">The crash dump's filename.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadCrashDump(System.String,Microsoft.Diagnostics.Runtime.CrashDumpReader)">
            <summary>
            Creates a DataTarget from a crash dump, specifying the dump reader to use.
            </summary>
            <param name="fileName">The crash dump's filename.</param>
            <param name="dumpReader">The type of dump reader to use.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDataReader(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Create an instance of DataTarget from a user defined DataReader
            </summary>
            <param name="reader">A user defined DataReader.</param>
            <returns>A new DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDebuggerInterface(Microsoft.Diagnostics.Runtime.Interop.IDebugClient)">
            <summary>
            Creates a data target from an existing IDebugClient interface.  If you created and attached
            a dbgeng based debugger to a process you may pass the IDebugClient RCW object to this function
            to create the DataTarget.
            </summary>
            <param name="client">The dbgeng IDebugClient object.  We will query interface on this for IDebugClient.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32)">
            <summary>
            Invasively attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32,Microsoft.Diagnostics.Runtime.AttachFlag)">
            <summary>
            Attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <param name="attachFlag">The type of attach requested for the target process.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DataReader">
            <summary>
            The data reader for this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.SymbolLocator">
            <summary>
            Instance to manage the symbol path(s)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.SymbolProvider">
            <summary>
            A symbol provider which loads PDBs on behalf of ClrMD.  This should be set so that when ClrMD needs to
            resolve names which can only come from PDBs.  If this is not set, you may have a degraded experience.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.IsMinidump">
            <summary>
            Returns true if the target process is a minidump, or otherwise might have limited memory.  If IsMinidump
            returns true, a greater range of functions may fail to return data due to the data not being present in
            the application/crash dump you are debugging.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.SetSymbolPath(System.String)">
            <summary>
            Sets the symbol path for ClrMD.
            </summary>
            <param name="path">This should be in the format that Windbg/dbgeng expects with the '.sympath' command.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.ClearSymbolPath">
            <summary>
            Clears the symbol path.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AppendSymbolPath(System.String)">
            <summary>
            Appends 'path' to the symbol path.
            </summary>
            <param name="path">The location to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.GetSymbolPath">
            <summary>
            Returns the current symbol path.
            </summary>
            <returns>The symbol path.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.Architecture">
            <summary>
            Returns the architecture of the target process or crash dump.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.ClrVersions">
            <summary>
            Returns the list of Clr versions loaded into the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.PointerSize">
            <summary>
            Returns the pointer size for the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.ReadProcessMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads memory from the target.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="buffer">The buffer to store the data in.  Size must be greator or equal to
            bytesRequested.</param>
            <param name="bytesRequested">The amount of bytes to read from the target process.</param>
            <param name="bytesRead">The actual number of bytes read.</param>
            <returns>True if any bytes were read out of the process (including a partial read).  False
            if no bytes could be read from the address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.String)">
            <summary>
            Creates a runtime from the given Dac file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.Object)">
            <summary>
            Creates a runtime from a given IXClrDataProcess interface.  Used for debugger plugins.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DebuggerInterface">
            <summary>
            Returns the IDebugClient interface associated with this datatarget.  (Will return null if the
            user attached passively.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.EnumerateModules">
            <summary>
            Enumerates information about the loaded modules in the process (both managed and unmanaged).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ISymbolNotification">
            <summary>
            Interface for receiving callback notifications when downloading symbol files.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.FoundSymbolInCache(System.String)">
            <summary>
            Symbol lookup was initiated, but found in a cache without needing to fetch it
            from the symbol path.
            </summary>
            <param name="localPath">The location of the file on disk.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.ProbeFailed(System.String)">
            <summary>
            Called when attempting to resolve a location (either local or remote), but we did
            not find the file.
            </summary>
            <param name="url">The path/url attempted.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.FoundSymbolOnPath(System.String)">
            <summary>
            We found the symbol on the symbol path.
            </summary>
            <param name="url">Where we found the symbol from.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DownloadProgress(System.Int32)">
            <summary>
            Called periodically when downloading the symbol from the symbol server.
            </summary>
            <param name="bytesDownloaded">The total bytes downloaded thus far.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DownloadComplete(System.String,System.Boolean)">
            <summary>
            Called when the download is complete.
            </summary>
            <param name="localPath">Where the file was placed.</param>
            <param name="requiresDecompression">True if the file requires us to decompress it (done automatically).</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DecompressionComplete(System.String)">
            <summary>
            Called when the file is finished decompressing.
            </summary>
            <param name="localPath">The location of the resulting decompressed file.</param>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SOURCE_PATH_HAS_SOURCE_SERVER">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_CONTEXT">
            <summary>
            InBuffer - Unused.
            OutBuffer - Machine-specific CONTEXT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_THREAD">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG system ID of thread.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_RECORD">
            <summary>
            InBuffer - Unused.
            OutBuffer - EXCEPTION_RECORD64.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_WIN32_MAJOR_MINOR_VERSIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG[2] major/minor.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_USER_MINIDUMP_STREAM">
            <summary>
            InBuffer - DEBUG_READ_USER_MINIDUMP_STREAM.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_CAN_DETACH">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_LOCAL_IMPLICIT_COMMAND_LINE">
            <summary>
            InBuffer - PTSTR.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CAPTURED_EVENT_CODE_OFFSET">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream offset.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_CAPTURED_EVENT_CODE_STREAM">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.EXT_TYPED_DATA_ANSI">
            <summary>
            InBuffer - Input data block.
            OutBuffer - Processed data block.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_EXTENSION_SEARCH_PATH_WIDE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Returned path.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_WIDE">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - DEBUG_CACHED_SYMBOL_INFO.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.ADD_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - DEBUG_CACHED_SYMBOL_INFO.
            OutBuffer - ULONG64 cookie.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.REMOVE_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_ANSI">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_OFFSET_UNWIND_INFORMATION">
            <summary>
            InBuffer - ULONG64 offset.
            OutBuffer - Unwind information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_DUMP_HEADER">
            <summary>
            InBuffer - Unused
            OutBuffer - returned DUMP_HEADER32/DUMP_HEADER64 structure.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_DUMP_HEADER">
            <summary>
            InBuffer - DUMP_HEADER32/DUMP_HEADER64 structure.
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MIDORI">
            <summary>
            InBuffer - Midori specific
            OutBuffer - Midori specific
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.PROCESS_DESCRIPTORS">
            <summary>
            InBuffer - Unused
            OutBuffer - PROCESS_NAME_ENTRY blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MISC_INFORMATION">
            <summary>
            InBuffer - Unused
            OutBuffer - MINIDUMP_MISC_INFO_N blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_PROCESS_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_THREAD_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.DUPLICATE_TOKEN">
            <summary>
            InBuffer -  ULONG64 as TokenHandle being duplicated
            OutBuffer - ULONG64 as new duplicated TokenHandle
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.QUERY_INFO_TOKEN">
            <summary>
            InBuffer - a ULONG64 as TokenHandle and a ULONG as NtQueryInformationToken() request code
            OutBuffer - NtQueryInformationToken() return
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CLOSE_TOKEN">
            <summary>
            InBuffer - ULONG64 as TokenHandle
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_PROCESS">
            <summary>
            InBuffer - ULONG64 for process server identification and ULONG as PID
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_MODULE">
            <summary>
            InBuffer - ULONG64 for process server identification and PWSTR as module path
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.LIVE_USER_NON_INVASIVE">
            <summary>
            InBuffer - Unused
            OutBuffer - Unused
            return - S_OK if non-invasive user-mode attach, S_FALSE if not (but still live user-mode), E_FAIL otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.RESUME_THREAD">
            <summary>
            InBuffer - TID
            OutBuffer - Unused
            return - ResumeThreads() return.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.INSIDE_WAIT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status is changing due to operations performed during a
               wait, such as making synchronous callbacks. If the bit is not set the
               execution status is changing due to a wait being satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.WAIT_TIMEOUT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status update is coming after a wait has timed-out. It
               indicates that the execution status change was not due to an actual event.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.New">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.CreateAlways">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenExisting">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenAlways">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.TruncateExisting">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interop.IDebugOutputCallbacks2.Output(Microsoft.Diagnostics.Runtime.Interop.DEBUG_OUTPUT,System.String)">
            <summary>
               This method is not used.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID">
            <summary>
               Describes a symbol within a module.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.ModuleBase">
            <summary>
               The location in the target's virtual address space of the module's base address.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.Id">
            <summary>
               The symbol ID of the symbol within the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.CLRVersion">
            <summary>
            Returns the version of the target process (v2, v4, v45)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.ArrayMethodTable">
            <summary>
            Returns the MethodTable for an array of objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.StringMethodTable">
            <summary>
            Returns the MethodTable for string objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.FreeMethodTable">
            <summary>
            Returns the MethodTable for free space markers.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SystemDomainAddress">
            <summary>
            The address of the system domain in CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SharedDomainAddress">
            <summary>
            The address of the shared domain in CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SystemDomain">
            <summary>
            The address of the system domain in CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SharedDomain">
            <summary>
            The address of the shared domain in CLR.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetAppDomainByAddress(System.UInt64)">
            <summary>
            Converts an address into an AppDomain.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetTypeName(Microsoft.Diagnostics.Runtime.Desktop.TypeHandle)">
            <summary>
            
            Returns the name of the type as specified by the TypeHandle.  Note this returns the name as specified by the
            metadata, NOT as you would expect to see it in a C# program.  For example, generics are denoted with a ` and
            the number of params.  Thus a Dictionary (with two type params) would look like:
                System.Collections.Generics.Dictionary`2
            </summary>
            <param name="id">The TypeHandle to get the name of.</param>
            <returns>The name of the type, or null on error.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.MemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.AllocPointers">
            <summary>
            The allocation context pointers/limits for this heap.  The keys of this
            dictionary are the allocation pointers, the values of this dictionary are
            the limits.  If an allocation pointer is ever reached while walking a
            segment, you must "skip" past the allocation limit.  That is:
                if (curr_obj is in AllocPointers)
                    curr_obj = AllocPointers[curr_obj] + min_object_size;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralSegment">
            <summary>
            Returns the address of the ephemeral segment.  Users of this API should use
            HeapSegment.Ephemeral instead of this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralEnd">
            <summary>
            Returns the actual end of the ephemeral segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopHeapType.FixGenericsWorker(System.String,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            A messy version with better performance that doesn't use regular expression.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ISymbolProvider">
            <summary>
            While ClrMD provides a managed PDB reader and PDB locator, it would be inefficient to load our own PDB
            reader into memory if the user already has one available.  For ClrMD operations which require reading data
            from PDBs, you will need to provide this implementation.  (This is currently only required for debugging
            .Net Native applications).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolProvider.GetSymbolResolver(System.String,System.Guid,System.Int32)">
            <summary>
            Loads a PDB by its given guid/age and provides an ISymbolResolver for that PDB.
            </summary>
            <param name="pdbName">The name of the pdb.  This may be a full path and not just a simple name.</param>
            <param name="guid">The guid of the pdb to locate.</param>
            <param name="age">The age of the pdb to locate.</param>
            <returns>A symbol resolver for the given pdb.  Null if none was found.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ISymbolResolver">
            <summary>
            ISymbolResolver represents a single symbol module (PDB) loaded into the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolResolver.GetSymbolNameByRVA(System.UInt32)">
            <summary>
            Retrieves the given symbol's name based on its RVA.
            </summary>
            <param name="rva">A relative virtual address in the module.</param>
            <returns>The symbol corresponding to RVA.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a 
            parapeter to the constuctor of a Command.  
            
            It is useful for these options be be on a separate class (rather than 
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options
            </summary>
            <returns>The copy of the command options</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero 
            exit code.  NoThrow suppresses this. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow propery and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Elevate">
            <summary>
            Indicates that the command must run at elevated Windows privledges (causes a new command window)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout propery and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property 
            of the command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of 
            environmetn variables to be passed to the sub-process and returns the 
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexitity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.StartTime">
            <summary>
            The time the process started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.HasExited">
            <summary>
            returns true if the process has exited. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitTime">
            <summary>
            The time the processed Exited.  (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Duration">
            <summary>
            The duration of the command (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Id">
            <summary>
            The operating system ID for the subprocess.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitCode">
            <summary>
            The process exit code for the subprocess.  (HasExited should be true before calling)
            Often this does not need to be checked because Command.Run will throw an exception 
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property 
            was set.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Output">
            <summary>
            The standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is 
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Options">
            <summary>
            Returns that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.RunToConsole(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine', sending the output to the console, and wait for the command to complete.
            This simulates what batch filedo when executing their commands.  It is a bit more verbose
            by default, however 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Run(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command 
            structure. 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you 
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options. 
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be true on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal 
            Command.Run failure was the appropriate action.  
            </summary>
            <param name="message">An additional message to print in the throw (can be null)</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Process">
            <summary>
            Get the underlying process object.  Generally not used. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the 
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.   
            Returns null if it was not found.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer">
            <summary>
            Immutable pointer into the dump file. Has associated size for runtime checking.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Shrink(System.UInt32)">
            <summary>
            Returns a DumpPointer to the same memory, but associated with a smaller size.
            </summary>
            <param name="size">smaller size to shrink the pointer to.</param>
            <returns>new DumpPointer</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Copy(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Copy numberBytesToCopy from the DumpPointer into &amp;destinationBuffer[indexDestination].
            </summary>
            <param name="dest"></param>
            <param name="destinationBufferSizeInBytes"></param>
            <param name="numberBytesToCopy"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Copy(System.IntPtr,System.UInt32)">
            <summary>
            Copy raw bytes to buffer
            </summary>
            <param name="destinationBuffer">buffer to copy to.</param>
            <param name="sizeBytes">number of bytes to copy. Caller ensures the destinationBuffer
            is large enough</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.PtrToStructure``1">
            <summary>
            Marshal this into a managed structure, and do bounds checks.
            </summary>
            <typeparam name="T">Type of managed structure to marshal as</typeparam>
            <returns>a managed copy of the structure</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader">
            <summary>
            Read contents of a minidump. 
            If we have a 32-bit dump, then there's an addressing collision possible.
            OS debugging code sign extends 32 bit wide addresses into 64 bit wide addresses.
            The CLR does not sign extend, thus you cannot round-trip target addresses exposed by this class.
            Currently we read these addresses once and don't hand them back, so it's not an issue.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE">
            <summary>
            Type of stream within the minidump.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.ZeroExtendAddress(System.UInt64)">
            <summary>
            Remove the OS sign-extension from a target address.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR">
            <summary>
            Describes a data stream within the minidump
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.DataSize">
            <summary>
            Size of the stream in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.Rva">
            <summary>
            Offset (in bytes) from the start of the minidump to the data stream.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.IsNull">
            <summary>
            True iff the data is missing.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64">
            <summary>
            Describes a data stream within the minidump
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64.DataSize">
            <summary>
            Size of the stream in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64.Rva">
            <summary>
            Offset (in bytes) from the start of the minidump to the data stream.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR">
            <summary>
            Describes a range of memory in the target.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR._startofmemoryrange">
            <summary>
            Starting Target address of the memory range.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR.Memory">
            <summary>
            Location in minidump containing the memory corresponding to StartOfMemoryRage
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64">
            <summary>
            Describes a range of memory in the target.
            </summary>
            <remarks>
            This is used for full-memory minidumps where
            all of the raw memory is laid out sequentially at the
            end of the dump.  There is no need for individual RVAs
            as the RVA is the base RVA plus the sum of the preceeding
            data blocks.
            </remarks>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64._startofmemoryrange">
            <summary>
            Starting Target address of the memory range.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64.DataSize">
            <summary>
            Size of memory in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_EXCEPTION">
            <summary>
            The struct that holds an EXCEPTION_RECORD
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_EXCEPTION_STREAM">
            <summary>
            The struct that holds contents of a dump's MINIDUMP_STREAM_TYPE.ExceptionStream
            which is a MINIDUMP_EXCEPTION_STREAM.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_SYSTEM_INFO">
            <summary>
            Describes system information about the system the dump was taken on.
            This is returned by the MINIDUMP_STREAM_TYPE.SystemInfoStream stream.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE._baseofimage">
            <summary>
            Address that module is loaded within target.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.SizeOfImage">
            <summary>
            Size of image within memory copied from IMAGE_OPTIONAL_HEADER.SizeOfImage.
            Note that this is usually different than the file size.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.CheckSum">
            <summary>
            Checksum, copied from IMAGE_OPTIONAL_HEADER.CheckSum. May be 0 if not optional
            header is not available.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.TimeDateStamp">
            <summary>
            TimeStamp in Unix 32-bit time_t format. Copied from IMAGE_FILE_HEADER.TimeDateStamp
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.ModuleNameRva">
            <summary>
            RVA within minidump of the string containing the full path of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.Timestamp">
            <summary>
            Gets TimeDateStamp as a DateTime. This is based off a 32-bit value and will overflow in 2038.
            This is not the same as the timestamps on the file.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD">
            <summary>
            Raw MINIDUMP_THREAD structure imported from DbgHelp.h
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD.Stack">
            <summary>
            Describes the memory location of the thread's raw stack.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD_LIST`1">
            <summary>
            List of Threads in the minidump.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(System.UInt64)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA64)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetString(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA)">
            <summary>
            Gets a MINIDUMP_STRING at the given RVA as an System.String.
            </summary>
            <param name="rva">RVA of MINIDUMP_STRING</param>
            <returns>System.String representing contents of MINIDUMP_STRING at the given RVA</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetString(Microsoft.Diagnostics.Runtime.Utilities.DumpPointer)">
            <summary>
            Gets a MINIDUMP_STRING at the given DumpPointer as an System.String.
            </summary>
            <param name="ptr">DumpPointer to a MINIDUMP_STRING</param>
            <returns>System.String representing contents of MINIDUMP_STRING at the given location
            in the dump</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.Int32)">
            <summary>
            Read memory from the dump file and return results in newly allocated buffer
            </summary>
            <param name="targetAddress">target address in dump to read length bytes from</param>
            <param name="length">number of bytes to read</param>
            <returns>newly allocated byte array containing dump memory</returns>
            <remarks>All memory requested must be readable or it throws.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Read memory from the dump file and copy into the buffer
            </summary>
            <param name="targetAddress">target address in dump to read buffer.Length bytets from</param>
            <param name="buffer">destination buffer to copy target memory to.</param>
            <param name="cbRequestSize">count of bytes to read</param>
            <remarks>All memory requested must be readable or it throws.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.IntPtr,System.UInt32)">
            <summary>
            Read memory from target and copy it to the local buffer pointed to by
            destinationBuffer. Throw if any portion of the requested memory is unavailable.
            </summary>
            <param name="targetRequestStart">target address in dump file to copy
            destinationBufferSizeInBytes bytes from. </param>
            <param name="destinationBuffer">pointer to copy the memory to.</param>
            <param name="destinationBufferSizeInBytes">size of the destinationBuffer in bytes.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadPartialMemory(System.UInt64,System.IntPtr,System.UInt32)">
            <summary>
            Read memory from target and copy it to the local buffer pointed to by destinationBuffer.
            
            </summary>
            <param name="targetRequestStart">target address in dump file to copy
            destinationBufferSizeInBytes bytes from. </param>
            <param name="destinationBuffer">pointer to copy the memory to.</param>
            <param name="destinationBufferSizeInBytes">size of the destinationBuffer in bytes.</param>
            <returns>Number of contiguous bytes successfuly copied into the destination buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ToString">
            <summary>
            ToString override. 
            </summary>
            <returns>string description of the DumpReader.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="path">filename to open dump file</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.Dispose">
            <summary>
            Dispose method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetStream(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE)">
            <summary>
            Get a DumpPointer for the given stream. That can then be used to further decode the stream.
            </summary>
            <param name="type">type of stream to lookup</param>
            <returns>DumpPointer refering into the stream. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TryGetStream(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE,Microsoft.Diagnostics.Runtime.Utilities.DumpPointer@)">
            <summary>
            Get a DumpPointer for the given stream. That can then be used to further decode the stream.
            </summary>
            <param name="type">type of stream to lookup</param>
            <param name="stream">DumpPointer refering into the stream. </param>
            <returns>True if stream was succesfully retrived</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.Version">
            <summary>
            Version numbers of OS that this dump was taken on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.OSVersion">
            <summary>
            Operating system that the dump was taken on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.OSVersionString">
            <summary>
            Friendly helper to get full OS version string (including CSDVersion) that the dump was taken on.
            </summary>
            <remarks>This is really just to compensate that public OperatingSystem's ctor doesn't let us
            add the service pack string, so we need a special helper for that.</remarks>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ProcessorArchitecture">
            <summary>
            The processor architecture that this dump was taken on.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetThread(System.Int32)">
            <summary>
            Get the thread for the given thread Id.
            </summary>
            <param name="threadId">thread Id to lookup.</param>
            <returns>a DumpThread object representing a thread in the dump whose thread id matches
            the requested id.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.EnumerateThreads">
            <summary>
            Enumerate all the native threads in the dump
            </summary>
            <returns>an enumerate of DumpThread objects</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.IsExceptionStream">
            <summary>
            Check on whether there's an exception stream in the dump
            </summary>
            <returns> true iff there is a MINIDUMP_EXCEPTION_STREAM in the dump. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ExceptionStreamThreadId">
            <summary>
            Return the TID from the exception stream.
            </summary>
            <returns> The TID from the exception stream. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.LookupModule(System.String)">
            <summary>
            Lookup the first module in the target with a matching. 
            </summary>
            <param name="nameModule">The name can either be a matching full name, or just shortname</param>
            <returns>The first DumpModule that has a matching name. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TryLookupModuleByAddress(System.UInt64)">
            <summary>
            Return the module containing the target address, or null if no match.
            </summary>
            <param name="targetAddress">address in target</param>
            <returns>Null if no match. Else a DumpModule such that the target address is in between the range specified
            by the DumpModule's .BaseAddress and .Size property </returns>
            <remarks>This can be useful for symbol lookups or for using module images to
            supplement memory read requests for minidumps.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.EnumerateModules">
            <summary>
            Enumerate all the modules in the dump.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpModule">
            <summary>
            Represents a native module in a dump file. This is a flyweight object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.#ctor(Microsoft.Diagnostics.Runtime.Utilities.DumpReader,Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE)">
            <summary>
            Constructor
            </summary>
            <param name="owner">owning DumpReader</param>
            <param name="raw">unmanaged dump structure describing the module</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.FullName">
            <summary>
             Usually, the full filename of the module. Since the dump may not be captured on the local
             machine, be careful of using this filename with the local file system.
             In some cases, this could be a short filename, or unavailable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.BaseAddress">
            <summary>
            Base address within the target of where this module is loaded.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.Size">
            <summary>
            Size of this module in bytes as loaded in the target.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.Timestamp">
            <summary>
            UTC Time stamp of module. This is based off a 32-bit value and will overflow in 2038.
            This is different than any of the filestamps. Call ToLocalTime() to convert from UTC.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.RawTimestamp">
            <summary>
            Gets the raw 32 bit time stamp. Use the Timestamp property to get this as a System.DateTime.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpThread">
            <summary>
            Represents a thread from a minidump file. This is a flyweight object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.#ctor(Microsoft.Diagnostics.Runtime.Utilities.DumpReader,Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD)">
            <summary>
            Constructor for DumpThread
            </summary>
            <param name="owner">owning DumpReader object</param>
            <param name="raw">unmanaged structure in dump describing the thread</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.ThreadId">
            <summary>
            The native OS Thread Id of this thread.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.GetThreadContext(System.IntPtr,System.Int32)">
            <summary>
            Get a thread's context using a raw buffer and size
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility">
            <summary>
            Utility class to provide various random Native debugging operations.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.IMAGE_DOS_HEADER.IsValid">
            <summary>
            Determine if this is a valid DOS image. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.MarshalAt``1(System.Byte[],System.UInt32)">
            <summary>
            Marshal a structure from the given buffer. Effectively returns ((T*) &amp;buffer[offset]).
            </summary>
            <typeparam name="T">type of structure to marshal</typeparam>
            <param name="buffer">array of bytes representing binary buffer to marshal</param>
            <param name="offset">offset in buffer to marhsal from</param>
            <returns>marshaled structure</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.GetTimestamp(System.String)">
            <summary>
            Gets the raw compilation timestamp of a file. 
            This can be matched with the timestamp of a module in a dump file.
            NOTE: This is NOT the same as the file's creation or last-write time.
            </summary>
            <param name="file"></param>
            <returns>0 for common failures like file not found or invalid format. Throws on gross
            errors. Else returns the module's timestamp for comparison against the minidump
            module's stamp.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbConstant">
            <summary>
            This class represents a constant value in source code, such as:
                const int Foo = 3;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbConstant.Name">
            <summary>
            The variable name of the constant.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbConstant.Token">
            <summary>
            The metadata token of this constant.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbConstant.Value">
            <summary>
            The value of this constant.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbFunction">
            <summary>
            Represents a single function in a module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbFunction.SequencePoints">
            <summary>
            Sequence points of this function.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbFunction.Token">
            <summary>
            Metadata token of this function.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbFunction.Scopes">
            <summary>
            The scopes of this function.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader">
            <summary>
            An object that can map offsets in an IL stream to source locations and block scopes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.GetPdbProperties(System.String,System.Guid@,System.Int32@)">
            <summary>
            Gets the properties of a given pdb.  Throws IOException on error.
            </summary>
            <param name="pdbFile">The pdb file to load.</param>
            <param name="signature">The signature of pdbFile.</param>
            <param name="age">The age of pdbFile.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.#ctor(System.IO.Stream)">
            <summary>
            Allocates an object that can map some kinds of ILocation objects to IPrimarySourceLocation objects. 
            For example, a PDB reader that maps offsets in an IL stream to source locations.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.#ctor(System.String)">
            <summary>
            Constructs a PdbReader from a path on disk.
            </summary>
            <param name="fileName">The pdb on disk to load.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Sources">
            <summary>
            A collection of all sources in this pdb.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Functions">
            <summary>
            A collection of all functions in this pdb.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Version">
            <summary>
            The version of this PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Signature">
            <summary>
            The Guid signature of this pdb.  Should be compared to the corresponding pdb signature in the matching PEFile.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Age">
            <summary>
            The age of this pdb.  Should be compared to the corresponding pdb age in the matching PEFile.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Dispose">
            <summary>
            Closes all of the source files that have been opened to provide the contents source locations corresponding to IL offsets.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.Finalize">
            <summary>
            Closes all of the source files that have been opened to provide the contents source locations corresponding to IL offsets.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbReader.GetFunctionFromToken(System.UInt32)">
            <summary>
            Retreives a PdbFunction by its metadata token.
            </summary>
            <param name="methodToken"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope">
            <summary>
            Represents a scope within a function or class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Constants">
            <summary>
            A list of constants defined in this scope.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Slots">
            <summary>
            A list of variable slots in this function.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Scopes">
            <summary>
            A list of sub-scopes within this scope.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.UsedNamespaces">
            <summary>
            A list of namespaces used in this scope.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Address">
            <summary>
            The address of this scope.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Offset">
            <summary>
            The IL offset of this scope.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbScope.Length">
            <summary>
            The length of this scope.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint">
            <summary>
            Represents a sequence point (multiple lines) in a source file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.Offset">
            <summary>
            The IL offset of this line.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.LineBegin">
            <summary>
            The first line of this sequence point.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.LineEnd">
            <summary>
            The last line of this sequence point.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.ColBegin">
            <summary>
            The first column of the first line of this sequence point.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.ColEnd">
            <summary>
            The last column of the last line of this sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePoint.ToString">
            <summary>
            ToString override.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePointCollection">
            <summary>
            A collection of sequence points (usually for a single function).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePointCollection.File">
            <summary>
            The source file these sequence points came from.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSequencePointCollection.Lines">
            <summary>
            A list of IL sequence points in this collection.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSlot">
            <summary>
            The representation of a local variable slot.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSlot.Slot">
            <summary>
            The slot number.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSlot.Name">
            <summary>
            The name of this variable slot.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSlot.Flags">
            <summary>
            the flags associated with this slot.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource">
            <summary>
            A source file in the program.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.Name">
            <summary>
            The name of the source file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.DocType">
            <summary>
            The DocType for this source.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.Language">
            <summary>
            Pdb source language.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.Vendor">
            <summary>
            Pdb source vendor
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.AlgorithmId">
            <summary>
            Pdb algorithm id.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.Checksum">
            <summary>
            Checksum for this pdb.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Pdb.PdbSource.Source">
            <summary>
            The embeded source in this pdb.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEFile">
            <summary>
            PEFile is a reader for the information in a Portable Exectable (PE) FILE.   This is what EXEs and DLLs are.  
            
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.TryLoad(System.IO.Stream,System.Boolean)">
            <summary>
            Parses a PEFile from a given stream. If it is valid, a new PEFile object is
            constructed and returned. Otherwise, null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.#ctor(System.String)">
            <summary>
            Create a new PEFile header reader.
            </summary>
            <param name="filePath">The path to the file on disk.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructor which allows you to specify a stream instead of file on disk.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="virt">Whether the stream is currently in virtual memory (true)
            or if this reading from disk (false).</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEFile.Header">
            <summary>
            The Header for the PE file.  This contains the infor in a link /dump /headers 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetPdbSignature(System.String@,System.Guid@,System.Int32@,System.Boolean)">
            <summary>
            Looks up the debug signature information in the EXE.   Returns true and sets the parameters if it is found. 
            
            If 'first' is true then the first entry is returned, otherwise (by default) the last entry is used 
            (this is what debuggers do today).   Thus NGEN images put the IL PDB last (which means debuggers 
            pick up that one), but we can set it to 'first' if we want the NGEN PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEFile.PdbInfo">
            <summary>
            Holds information about the pdb for the current PEFile
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEFile.Disposed">
            <summary>
            Whether this object has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetSxSManfest">
            <summary>
            For side by side dlls, the manifest that decribes the binding information is stored as the RT_MANIFEST resource, and it
            is an XML string.   This routine returns this.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.Dispose">
            <summary>
            Closes any file handles and cleans up resources.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEHeader">
            <summary>
            A PEHeader is a reader of the data at the begining of a PEFile.    If the header bytes of a 
            PEFile are read or mapped into memory, this class can parse it when given a pointer to it.
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.FromBuffer(Microsoft.Diagnostics.Runtime.Utilities.PEBuffer,System.Boolean)">
            <summary>
            Parses the given buffer for the header of a PEFile. If it can be parsed correctly,
            a new PEHeader object is constructed from the buffer and returned. Otherwise, null
            is returned.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.PEHeaderSize">
            <summary>
            The total s,ize of the header,  including section array of the the PE header.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.VirtualAddressToRva(System.Void*)">
            <summary>
            Given a virtual address to data in a mapped PE file, return the relative virtual address (displacement from start of the image)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.RvaToVirtualAddress(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return the virtual address to data in a mapped PE file
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.RvaToFileOffset(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return a offset in the file data for that data.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.TryGetFileOffsetFromRva(System.Int32,System.Int32@)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return a offset in the file data for that data, if
            the RVA is valid. If the RVA is invalid, the method will return false. Otherwise, the method will return true and store the
            offset in the result parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.IsPE64">
            <summary>
            Returns true if this is PE file for a 64 bit architecture.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.IsManaged">
            <summary>
            Returns true if this file contains managed code (might also contain native code). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Signature">
            <summary>   
            Returns the 'Signture' of the PE HEader PE\0\0 = 0x4550, used for sanity checking.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Machine">
            <summary>
            The machine this PE file is intended to run on 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfSections">
            <summary>
            PE files have a number of sections that represent regions of memory with the access permisions.  This is the nubmer of such sections.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.TimeDateStampSec">
            <summary>
            The the PE file was created represented as the number of seconds since Jan 1 1970 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.TimeDateStamp">
            <summary>
            The the PE file was created represented as a DateTime object
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.PointerToSymbolTable">
            <summary>
            PointerToSymbolTable (see IMAGE_FILE_HEADER in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfSymbols">
            <summary>
            NumberOfSymbols (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfOptionalHeader">
            <summary>
            SizeOfOptionalHeader (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Characteristics">
            <summary>
            Characteristics (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Magic">
            <summary>
            Magic (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorLinkerVersion">
            <summary>
            MajorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorLinkerVersion">
            <summary>
            MinorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfCode">
            <summary>
            SizeOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfInitializedData">
            <summary>
            SizeOfInitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfUninitializedData">
            <summary>
            SizeOfUninitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.AddressOfEntryPoint">
            <summary>
            AddressOfEntryPoint (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BaseOfCode">
            <summary>
            BaseOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImageBase">
            <summary>
            ImageBase (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SectionAlignment">
            <summary>
            SectionAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.FileAlignment">
            <summary>
            FileAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorOperatingSystemVersion">
            <summary>
            MajorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorOperatingSystemVersion">
            <summary>
            MinorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorImageVersion">
            <summary>
            MajorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorImageVersion">
            <summary>
            MinorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorSubsystemVersion">
            <summary>
            MajorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorSubsystemVersion">
            <summary>
            MinorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Win32VersionValue">
            <summary>
            Win32VersionValue (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfImage">
            <summary>
            SizeOfImage (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeaders">
            <summary>
            SizeOfHeaders (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.CheckSum">
            <summary>
            CheckSum (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Subsystem">
            <summary>
            Subsystem (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DllCharacteristics">
            <summary>
            DllCharacteristics (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfStackReserve">
            <summary>
            SizeOfStackReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfStackCommit">
            <summary>
            SizeOfStackCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeapReserve">
            <summary>
            SizeOfHeapReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeapCommit">
            <summary>
            SizeOfHeapCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.LoaderFlags">
            <summary>
            LoaderFlags (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfRvaAndSizes">
            <summary>
            NumberOfRvaAndSizes (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Directory(System.Int32)">
            <summary>
            returns the data directory (virtual address an blob, of a data directory with index 'idx'.   14 are currently defined.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ExportDirectory">
            <summary>
            Return the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImportDirectory">
            <summary>
            Return the data directory for DLL Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ResourceDirectory">
            <summary>
            Return the data directory for DLL Resources see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ExceptionDirectory">
            <summary>
            Return the data directory for DLL Exceptions see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.CertificatesDirectory">
            <summary>
            Return the data directory for DLL securiy certificates (Authenticode) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BaseRelocationDirectory">
            <summary>
            Return the data directory Image Base Relocations (RELOCS) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DebugDirectory">
            <summary>
            Return the data directory for Debug information see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ArchitectureDirectory">
            <summary>
            Return the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.GlobalPointerDirectory">
            <summary>
            Return the data directory for GlobalPointer (IA64) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ThreadStorageDirectory">
            <summary>
            Return the data directory for THread local storage see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.LoadConfigurationDirectory">
            <summary>
            Return the data directory for Load Configuration see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BoundImportDirectory">
            <summary>
            Return the data directory for Bound Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImportAddressTableDirectory">
            <summary>
            Return the data directory for the DLL Import Address Table (IAT) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DelayImportDirectory">
            <summary>
            Return the data directory for Delayed Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ComDescriptorDirectory">
            <summary>
             see PE file spec for more .NET Runtime infomration.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.MachineType">
            <summary>
            The Machine types supporte by the portable executable (PE) File format
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.Native">
            <summary>
            Unknown machine type
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.X86">
            <summary>
            Intel X86 CPU 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.ia64">
            <summary>
            Intel IA64 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.ARM">
            <summary>
            ARM 32 bit 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.Amd64">
            <summary>
            Arm 64 bit 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY">
            <summary>
            Represents a Portable Executable (PE) Data directory.  This is just a well known optional 'Blob' of memory (has a starting point and size)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY.VirtualAddress">
            <summary>
            The start of the data blob when the file is mapped into memory
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY.Size">
            <summary>
            The length of the data blob.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo">
            <summary>
            FileVersionInfo reprents the extended version formation that is optionally placed in the PE file resource area. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.FileVersion">
            <summary>
            The verison string 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.Comments">
            <summary>
            Comments to supplement the file version
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEBuffer">
            <summary>
            A PEBuffer represents 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator">
            <summary>
            This class is a general purpose symbol locator and binary locator.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinaryAsync(System.String,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinaryAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinaryAsync(Microsoft.Diagnostics.Runtime.ModuleInfo,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="module">The module to locate.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinaryAsync(Microsoft.Diagnostics.Runtime.DacInfo)">
            <summary>
            Attempts to locate a dac via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  Note that
            the dac should not validate if the properties of the file match the one it was indexed under.
            </summary>
            <param name="dac">The dac to locate.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdbAsync(Microsoft.Diagnostics.Runtime.ModuleInfo)">
            <summary>
            Attempts to locate the pdb for a given module.
            </summary>
            <param name="module">The module to locate the pdb for.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdbAsync(Microsoft.Diagnostics.Runtime.PdbInfo)">
            <summary>
            Attempts to locate the pdb for a given module.
            </summary>
            <param name="pdb">The pdb to locate.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdbAsync(System.String,System.Guid,System.Int32)">
            <summary>
            Attempts to locate a pdb based on its name, guid, and revision number.
            </summary>
            <param name="pdbName">The name the pdb is indexed under.</param>
            <param name="pdbIndexGuid">The guid the pdb is indexed under.</param>
            <param name="pdbIndexAge">The age of the pdb.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.CopyStreamToFileAsync(System.IO.Stream,System.String,System.String,System.Int64)">
            <summary>
            Copies the given file from the input stream into fullDestPath.
            </summary>
            <param name="input">The input stream to copy the file from.</param>
            <param name="fullSrcPath">The source of this file.  This is for informational/logging purposes and shouldn't be opened directly.</param>
            <param name="fullDestPath">The destination path of where the file should go on disk.</param>
            <param name="size">The length of the given file.  (Also for informational purposes, do not use this as part of a copy loop.</param>
            <returns>A task indicating when the copy is completed.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator._symbolPath">
            <summary>
            The raw symbol path.  You should probably use the SymbolPath property instead.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator._symbolCache">
            <summary>
            The raw symbol cache.  You should probably use the SymbolCache property instead.
            </summary>
            
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.Timeout">
            <summary>
            The timeout (in milliseconds) used when contacting each individual server.  This is not a total timeout for the entire
            symbol server operation.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator._missingPdbs">
            <summary>
            A set of pdbs that we did not find when requested.  This set is SymbolLocator specific (not global
            like successful downloads) and is cleared when we change the symbol path or cache.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator._missingFiles">
            <summary>
            A set of files that we did not find when requested.  This set is SymbolLocator specific (not global
            like successful downloads) and is cleared when we change the symbol path or cache.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.MicrosoftSymbolServerPath">
            <summary>
            Return the string representing a symbol path for the 'standard' microsoft symbol servers.   
            This returns the public msdl.microsoft.com server if outside Microsoft.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.MicrosoftSymbolServers">
            <summary>
            Retrieves a list of the default Microsoft symbol servers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator._NT_SYMBOL_PATH">
            <summary>
            This property gets and sets the global _NT_SYMBOL_PATH environment variable.
            This is the global setting for symbol paths on a computer.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.SymbolCache">
            <summary>
            Gets or sets the local symbol file cache.  This is the location that
            all symbol files are downloaded to on your computer.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.SymbolPath">
            <summary>
            Gets or sets the SymbolPath this object uses to attempt to find PDBs and binaries.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinary(System.String,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinary(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinary(Microsoft.Diagnostics.Runtime.ModuleInfo,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="module">The module to locate.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindBinary(Microsoft.Diagnostics.Runtime.DacInfo)">
            <summary>
            Attempts to locate a dac via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  Note that
            the dac should not validate if the properties of the file match the one it was indexed under.
            </summary>
            <param name="dac">The dac to locate.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdb(Microsoft.Diagnostics.Runtime.ModuleInfo)">
            <summary>
            Attempts to locate the pdb for a given module.
            </summary>
            <param name="module">The module to locate the pdb for.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdb(Microsoft.Diagnostics.Runtime.PdbInfo)">
            <summary>
            Attempts to locate the pdb for a given module.
            </summary>
            <param name="pdb">The pdb to locate.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.FindPdb(System.String,System.Guid,System.Int32)">
            <summary>
            Attempts to locate a pdb based on its name, guid, and revision number.
            </summary>
            <param name="pdbName">The name the pdb is indexed under.</param>
            <param name="pdbIndexGuid">The guid the pdb is indexed under.</param>
            <param name="pdbIndexAge">The age of the pdb.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.ValidatePdb(System.String,System.Guid,System.Int32)">
            <summary>
            Validates whether a pdb on disk matches the given Guid/revision.
            </summary>
            <param name="pdbName"></param>
            <param name="guid"></param>
            <param name="age"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.ValidateBinary(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Validates whether a file on disk matches the properties we expect.
            </summary>
            <param name="fullPath">The full path on disk of a PEImage to inspect.</param>
            <param name="buildTimeStamp">The build timestamp we expect to match.</param>
            <param name="imageSize">The build image size we expect to match.</param>
            <param name="checkProperties">Whether we should actually validate the imagesize/timestamp or not.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.CopyStreamToFile(System.IO.Stream,System.String,System.String,System.Int64)">
            <summary>
            Copies a given stream to a file.
            </summary>
            <param name="input">The stream of data to copy.</param>
            <param name="fullSrcPath">The original source location of "stream".  This may be a URL or null.</param>
            <param name="fullDestPath">The full destination path to copy the file to.</param>
            <param name="size">A hint as to the length of the stream.  This may be 0 or negative if the length is unknown.</param>
            <returns>True if the method successfully copied the file, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.Trace(System.String,System.Object[])">
            <summary>
            Writes diagnostic messages about symbol loading to System.Diagnostics.Trace.  Figuring out symbol issues can be tricky,
            so if you override methods in SymbolLocator, be sure to trace the information here.
            </summary>
            <param name="fmt"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolLocator.SymbolPathOrCacheChanged">
            <summary>
            Called when changing the symbol file path or cache.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator">
            <summary>
            In v4.5, this class supports multithreading.
            </summary>
            <summary>
            Default implementation of a symbol locator.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.FindBinaryAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.FindPdbAsync(System.String,System.Guid,System.Int32)">
            <summary>
            Attempts to locate a pdb based on its name, guid, and revision number.
            </summary>
            <param name="pdbName">The name the pdb is indexed under.</param>
            <param name="pdbIndexGuid">The guid the pdb is indexed under.</param>
            <param name="pdbIndexAge">The age of the pdb.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.SymbolPathOrCacheChanged">
            <summary>
            Clear missing file/pdb cache
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.CopyStreamToFile(System.IO.Stream,System.String,System.String,System.Int64)">
            <summary>
            Copies the given file from the input stream into fullDestPath.
            </summary>
            <param name="stream">The input stream to copy the file from.</param>
            <param name="fullSrcPath">The source of this file.  This is for informational/logging purposes and shouldn't be opened directly.</param>
            <param name="fullDestPath">The destination path of where the file should go on disk.</param>
            <param name="size">The length of the given file.  (Also for informational purposes, do not use this as part of a copy loop.</param>
            <returns>A task indicating when the copy is completed.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.CopyStreamToFileAsync(System.IO.Stream,System.String,System.String,System.Int64)">
            <summary>
            Copies the given file from the input stream into fullDestPath.
            </summary>
            <param name="input">The input stream to copy the file from.</param>
            <param name="fullSrcPath">The source of this file.  This is for informational/logging purposes and shouldn't be opened directly.</param>
            <param name="fullDestPath">The destination path of where the file should go on disk.</param>
            <param name="size">The length of the given file.  (Also for informational purposes, do not use this as part of a copy loop.</param>
            <returns>A task indicating when the copy is completed.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.FindPdb(System.String,System.Guid,System.Int32)">
            <summary>
            Default implementation of finding a pdb.
            </summary>
            <param name="pdbName">The name the pdb is indexed under.</param>
            <param name="pdbIndexGuid">The guid the pdb is indexed under.</param>
            <param name="pdbIndexAge">The age of the pdb.</param>
            <returns>A full path on disk (local) of where the pdb was copied to.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DefaultSymbolLocator.FindBinary(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.
            </summary>
            <param name="fileName">The filename that the binary is indexed under.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, null if it was not found.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement">
            <summary>
            SymPathElement represents the text between the semicolons in a symbol path.  It can be a symbol server specification or a simple directory path. 
            
            SymPathElement follows functional conventions.  After construction everything is read-only. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.GetElements(System.String)">
            <summary>
            returns a list of SymPathElements from a semicolon delimited string representing a symbol path
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.IsSymServer">
            <summary>
            returns true if this element of the symbol server path a symbol server specification
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Cache">
            <summary>
            returns the local cache for a symbol server specifcation.  returns null if not specified
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Target">
            <summary>
            returns location to look for symbols.  This is either a directory specification or an URL (for symbol servers)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.IsRemote">
            <summary>
            IsRemote returns true if it looks like the target is not on the local machine.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.ToString">
            <summary>
            returns the string repsentation for the symbol server path element (e.g. SRV*c:\temp*\\symbols\symbols)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Equals(System.Object)">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.GetHashCode">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.#ctor(System.Boolean,System.String,System.String)">
            <summary>
            returns a new SymPathElement with the corresponding properties initialized
            </summary>
        </member>
    </members>
</doc>
