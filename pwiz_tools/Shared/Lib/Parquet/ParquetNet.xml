<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parquet</name>
    </assembly>
    <members>
        <member name="M:System.SpanExtensions.CopyWithLimitTo``1(System.Span{``0},System.Span{``0})">
            <summary>
            Copies the source span to the target one. If the source span is larger than
            the target span, it will fill the target and discard the rest. If the source 
            is smaller, only the bytes available will be copied to the target.
            </summary>
        </member>
        <member name="T:System.DateTimeExtensions">
            <summary>
            <see cref="T:System.DateTime"/> extension methods
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.RoundToDay(System.DateTime)">
            <summary>
            Strips time from the date structure
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.EndOfDay(System.DateTime)">
            <summary>
            Changes to the end of day time, i.e. hours, minutes and seconds are changed to 23:59:59
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.RoundToMinute(System.DateTime,System.Int32,System.Boolean)">
            <summary>
            Rounds to the closest minute
            </summary>
            <param name="time">Input date</param>
            <param name="round">Closest minute i.e. 15, 30, 45 etc.</param>
            <param name="roundLeft">Whether to use minimum or maximum value. For example
            when time is 13:14 and rounding is to every 15 minutes, when this parameter is true
            the result it 13:00, otherwise 13:15</param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.RoundToSecond(System.DateTime)">
            <summary>
            Strips off details after seconds
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.RoundToMillisecond(System.DateTime)">
            <summary>
            Strips off details after milliseconds
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.IsToday(System.DateTime)">
            <summary>
            Returns true if the date is today's date.
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.IsTomorrow(System.DateTime)">
            <summary>
            Returns true if the date is tomorrow's date.
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.ToHourMinuteString(System.DateTime)">
            <summary>
            Returns date in "HH:mm" format
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.ToIso8601DateString(System.DateTime)">
            <summary>
            Formats date in ISO 8601 format
            </summary>
        </member>
        <member name="T:System.LongExtensions">
            <summary>
            <see cref="T:System.Int64"/> extension methods
            </summary>
        </member>
        <member name="M:System.LongExtensions.ToFileSizeString(System.Int64)">
            <summary>
            Converts number to readable size string in IEC format, i.e. 1024 converts to "1.02 KiB"
            </summary>
        </member>
        <member name="M:System.LongExtensions.ToFileSizeUiString(System.Int64)">
            <summary>
            Converts number to readable size string in SI format, i.e. 1024 converts to "1.02 KB"
            </summary>
        </member>
        <member name="M:System.IntExtensions.ToFileSizeString(System.Int32)">
            <summary>
            Converts number to readable size string in IEC format, i.e. 1024 converts to "1.02 KiB"
            </summary>
        </member>
        <member name="M:System.IntExtensions.ToFileSizeUiString(System.Int32)">
            <summary>
            Converts number to readable size string in SI format, i.e. 1024 converts to "1.02 KB"
            </summary>
        </member>
        <member name="M:System.IntExtensions.Seconds(System.Int32)">
            <summary>
            Converts number to seconds
            </summary>
            <param name="number">Number of seconds</param>
            <returns>Timespan values</returns>
        </member>
        <member name="M:System.IntExtensions.Minutes(System.Int32)">
            <summary>
            Converts number to minutes
            </summary>
            <param name="number">Number of minutes</param>
            <returns>Timespan value</returns>
        </member>
        <member name="M:System.IntExtensions.Hours(System.Int32)">
            <summary>
            Converts number to hours 
            </summary>
            <param name="number">Number of hours</param>
            <returns>Timespan value</returns>
        </member>
        <member name="T:System.TaskExtensions">
            <summary>
            Task utility methods
            </summary>
        </member>
        <member name="M:System.TaskExtensions.Forget(System.Threading.Tasks.Task)">
            <summary>
            Fire-and-forget without compiler warnings
            </summary>
            <param name="task"></param>
        </member>
        <member name="T:System.ByteArrayExtensions">
            <summary>
            Byte array extensions methods
            </summary>
        </member>
        <member name="M:System.ByteArrayExtensions.ToHexString(System.Byte[])">
            <summary>
            Converts byte array to hexadecimal string
            </summary>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            String extensions.
            </summary>
        </member>
        <member name="M:System.StringExtensions.FromHexToBytes(System.String)">
            <summary>
            Converts hex string to byte array
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.StripHtml(System.String)">
            <summary>
            Strips HTML string from any tags leaving text only.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.Base64Encode(System.String)">
            <summary>
            Encodes a string to BASE64 format
            </summary>
        </member>
        <member name="M:System.StringExtensions.Base64Decode(System.String)">
            <summary>
            Decodes a BASE64 encoded string
            </summary>
        </member>
        <member name="M:System.StringExtensions.Base64DecodeAsBytes(System.String)">
            <summary>
            Decodes a BASE64 encoded string to byte array
            </summary>
            <param name="s">String to decode</param>
            <returns>Byte array</returns>
        </member>
        <member name="M:System.StringExtensions.FromShortestGuid(System.String)">
            <summary>
            Converts shortest guid representation back to Guid. See <see cref="M:System.GuidExtensions.ToShortest(System.Guid)"/>
            on how to convert Guid to string.
            </summary>
        </member>
        <member name="M:System.StringExtensions.UrlEncode(System.String)">
            <summary>
            URL-encodes input string
            </summary>
            <param name="value">String to encode</param>
            <returns>Encoded string</returns>
        </member>
        <member name="M:System.StringExtensions.UrlDecode(System.String)">
            <summary>
            URL-decodes input string
            </summary>
            <param name="value">String to decode</param>
            <returns>Decoded string</returns>
        </member>
        <member name="M:System.StringExtensions.ToMemoryStream(System.String,System.Text.Encoding)">
            <summary>
            Converts to MemoryStream with a specific encoding
            </summary>
        </member>
        <member name="M:System.StringExtensions.ToMemoryStream(System.String)">
            <summary>
            Converts to MemoryStream in UTF-8 encoding
            </summary>
        </member>
        <member name="M:System.StringExtensions.FindTagged(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Looks for <paramref name="startTag"/> and <paramref name="endTag"/> followed in sequence and when found returns the text between them.
            </summary>
            <param name="s">Input string</param>
            <param name="startTag">Start tag</param>
            <param name="endTag">End tag</param>
            <param name="includeOuterTags">When set to true, returns the complete phrase including start and end tag value,
            otherwise only inner text returned</param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.ReplaceTagged(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Looks for <paramref name="startTag"/> and <paramref name="endTag"/> followed in sequence, and if found
            performs a replacement of text inside them with <paramref name="replacementText"/>
            </summary>
            <param name="s">Input string</param>
            <param name="startTag">Start tag</param>
            <param name="endTag">End tag</param>
            <param name="replacementText">Replacement text</param>
            <param name="replaceOuterTokens">When set to true, not only the text between tags is replaced, but the whole
            phrase with <paramref name="startTag"/>, text between tags and <paramref name="endTag"/></param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.SpacedToCamelCase(System.String)">
            <summary>
            Converts a string with spaces to a camel case version, for example
            "The camel string" is converted to "TheCamelString"
            </summary>
        </member>
        <member name="M:System.StringExtensions.Capitalize(System.String)">
            <summary>
            Transforms the string so that the first letter is uppercase and the rest of them are lowercase
            </summary>
        </member>
        <member name="M:System.StringExtensions.Slice(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Pythonic approach to slicing strings
            </summary>
            <param name="s">Input string</param>
            <param name="start">Is the start index to slice from. It can be either positive or negative.
            Negative value indicates that the index is taken from the end of the string.</param>
            <param name="end">Is the index to slice to. It can be either positive or negative.
            Negative value indicates that the index is taken from the end of the string.</param>
            <returns>Sliced string</returns>
        </member>
        <member name="M:System.StringExtensions.SplitByDelimiter(System.String,System.String[])">
            <summary>
            Splits the string into key and value using the provided delimiter values. Both key and value are trimmed as well.
            </summary>
            <param name="s">Input string. When null returns null immediately.</param>
            <param name="delimiter">List of delmiters between key and value. This method searches for all the provided
            delimiters, and splits by the first left-most one.</param>
            <returns>A tuple of two values where the first one is the key and second is the value. If none of the delimiters
            are found the second value of the tuple is null and the first value is the input string</returns>
        </member>
        <member name="M:System.StringExtensions.RemoveLinesContaining(System.String,System.String,System.StringComparison)">
            <summary>
            Splits text line by line and removes lines containing specific substring
            </summary>
        </member>
        <member name="M:System.StringExtensions.ToEscapedJsonValueString(System.String)">
            <summary>
            Escapes a string for JSON encoding
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.DownloadUrlToTempFile(System.String)">
            <summary>
            Treat this string as URL and download it as stream
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:System.EnumerableExtensions">
            <summary>
            <see cref="T:System.IEquatable`1"/> extension methods
            </summary>
        </member>
        <member name="M:System.EnumerableExtensions.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Split the elements of a sequence into chunks of size at most <paramref name="size"/>.
            </summary>
            <remarks>
            Every chunk except the last will be of size <paramref name="size"/>.
            The last chunk will contain the remaining elements and may be of a smaller size.
            </remarks>
            <param name="source">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to chunk.
            </param>
            <param name="size">
            Maximum size of each chunk.
            </param>
            <typeparam name="TSource">
            The type of the elements of source.
            </typeparam>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the elements the input sequence split into chunks of size <paramref name="size"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="size"/> is below 1.
            </exception>
        </member>
        <member name="M:System.EnumerableExtensions.TryGetNonEnumeratedCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
             <summary>
               Attempts to determine the number of elements in a sequence without forcing an enumeration.
             </summary>
             <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
             <param name="source">A sequence that contains elements to be counted.</param>
             <param name="count">
                 When this method returns, contains the count of <paramref name="source" /> if successful,
                 or zero if the method failed to determine the count.</param>
             <returns>
               <see langword="true" /> if the count of <paramref name="source"/> can be determined without enumeration;
               otherwise, <see langword="false" />.
             </returns>
             <remarks>
               The method performs a series of type tests, identifying common subtypes whose
               count can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
               <see cref="T:System.Collections.ICollection"/> as well as internal types used in the LINQ implementation.
            
               The method is typically a constant-time operation, but ultimately this depends on the complexity
               characteristics of the underlying collection implementation.
             </remarks>
        </member>
        <member name="M:System.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a specific action on each element of the sequence
            </summary>
        </member>
        <member name="T:System.StreamExtensions">
            <summary>
            <see cref="T:System.IO.Stream"/> extension
            </summary>
        </member>
        <member name="M:System.StreamExtensions.TryGetSize(System.IO.Stream,System.Int64@)">
            <summary>
            Attemps to get the size of this stream by reading the Length property, otherwise returns 0.
            </summary>
        </member>
        <member name="M:System.StreamExtensions.TryGetSize(System.IO.Stream)">
            <summary>
            Attemps to get the size of this stream by reading the Length property, otherwise returns 0.
            </summary>
        </member>
        <member name="M:System.StreamExtensions.ReadUntil(System.IO.Stream,System.Byte[])">
            <summary>
            Reads the stream until a specified sequence of bytes is reached.
            </summary>
            <returns>Bytes before the stop sequence</returns>
        </member>
        <member name="M:System.StreamExtensions.ToByteArray(System.IO.Stream)">
            <summary>
            Reads all stream in memory and returns as byte array
            </summary>
        </member>
        <member name="M:System.StreamExtensions.ToString(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Converts the stream to string using specified encoding. This is done by reading the stream into
            byte array first, then applying specified encoding on top.
            </summary>
        </member>
        <member name="T:Parquet.CompressionMethod">
            <summary>
            Parquet compression method
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Snappy">
            <summary>
            Snappy compression 
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Gzip">
            <summary>
            Gzip compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Lzo">
            <summary>
            LZO
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Brotli">
            <summary>
            Brotli
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.LZ4">
            <summary>
            LZ4
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Zstd">
            <summary>
            ZSTD
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Lz4Raw">
            <summary>
            LZ4 raw
            </summary>
        </member>
        <member name="T:Parquet.Data.DataColumn">
            <summary>
            The primary low-level structure to hold data for a parquet column.
            Handles internal data composition/decomposition to enrich with custom data Parquet format requires.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Schema.DataField,System.Array,System.Int32[],System.Int32[])">
            <summary>
            Creates a new instance of DataColumn from essential parts of Parquet data.
            </summary>
            <param name="field">Data field associated with this data column.</param>
            <param name="definedData">Raw data as it, without definition levels applied</param>
            <param name="repetitionLevels">Repetition levels, if required.</param>
            <param name="definitionLevels">Definition levels, if required.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Schema.DataField,System.Array,System.Int32[])">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
            <param name="repetitionLevels"></param>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Schema.DataField,System.Array)">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
        </member>
        <member name="P:Parquet.Data.DataColumn.Field">
            <summary>
            Data field
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.DefinedData">
            <summary>
            Defined data. If definition levels are present, they are not applied here.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Data">
            <summary>
            Column data where definition levels are already applied
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.DefinitionLevels">
            <summary>
            Definition levels, if present
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.RepetitionLevels">
            <summary>
            Repetition levels if any.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.HasRepetitions">
            <summary>
            When true, this field has repetitions. It doesn't mean that it's an array though. This property simply checks that
            repetition levels are present on this column.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.HasDefinitions">
            <summary>
            When true, this column has definition levels
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Statistics">
            <summary>
            Basic statistics for this data column (populated only on read)
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.NumValues">
            <summary>
            Number of actual values in this column, including nulls and null/empty lists polyfills.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.AsSpan``1(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Casts <see cref="P:Parquet.Data.DataColumn.Data"/> to <see cref="T:System.Span`1"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">When T is invalid type</exception>
        </member>
        <member name="M:Parquet.Data.DataColumn.Concat(System.Collections.Generic.IEnumerable{Parquet.Data.DataColumn})">
            <summary>
            Concatenates multiple columns into a single column. All columns must have the same schema.
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.DataColumn.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Parquet.Data.DataColumnStatistics">
            <summary>
            Basic statistics for data column
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor">
            <summary>
            Creates an uninitalised instance of column statistics
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor(System.Nullable{System.Int64},System.Nullable{System.Int64},System.Object,System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.NullCount">
            <summary>
            Number of null values
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.DistinctCount">
            <summary>
            Number of distinct values if set.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MinValue">
            <summary>
            Minimum value, casted to CLR type
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MaxValue">
            <summary>
            Maximum value, casted to CLR type
            </summary>
        </member>
        <member name="T:Parquet.Data.DecimalFormatDefaults">
            <summary>
            Pre-defined decimal handling default values; providing backwards compatibility prior to v3.9 where these were made configurable.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultPrecision">
            <summary>
            The Default Precision value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultScale">
            <summary>
            The Default Scale value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Encode8ValuesLE(System.Span{System.Int32},System.Span{System.Byte},System.Int32)">
            <summary>
            Encodes exactly 8 values from input span. Unlike pack, checks for boundaries.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Pack8ValuesLE(System.Span{System.Int32},System.Span{System.Byte},System.Int32)">
            <summary>
            Packs exactly 8 int values using little-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Decode8ValuesLE(System.Span{System.Byte},System.Span{System.Int32},System.Int32)">
            <summary>
            Decodes exactly 8 values from input span. Unlike unpack, checks for boundaries.
            </summary>
            <returns>Number of values unpacked</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Unpack8ValuesLE(System.Span{System.Byte},System.Span{System.Int32},System.Int32)">
            <summary>
            Unpacks exactly 8 int values using little-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Encode8ValuesBE(System.Span{System.Int32},System.Span{System.Byte},System.Int32)">
            <summary>
            Encodes exactly 8 values from input span. Unlike pack, checks for boundaries.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Pack8ValuesBE(System.Span{System.Int32},System.Span{System.Byte},System.Int32)">
            <summary>
            Packs exactly 8 int values using big-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Decode8ValuesBE(System.Span{System.Byte},System.Span{System.Int32},System.Int32)">
            <summary>
            Decodes exactly 8 values from input span. Unlike unpack, checks for boundaries.
            </summary>
            <returns>Number of values unpacked</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Unpack8ValuesBE(System.Span{System.Byte},System.Span{System.Int32},System.Int32)">
            <summary>
            Unpacks exactly 8 int values using big-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Encode8ValuesLE(System.Span{System.Int64},System.Span{System.Byte},System.Int32)">
            <summary>
            Encodes exactly 8 values from input span. Unlike pack, checks for boundaries.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Pack8ValuesLE(System.Span{System.Int64},System.Span{System.Byte},System.Int32)">
            <summary>
            Packs exactly 8 long values using little-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Decode8ValuesLE(System.Span{System.Byte},System.Span{System.Int64},System.Int32)">
            <summary>
            Decodes exactly 8 values from input span. Unlike unpack, checks for boundaries.
            </summary>
            <returns>Number of values unpacked</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Unpack8ValuesLE(System.Span{System.Byte},System.Span{System.Int64},System.Int32)">
            <summary>
            Unpacks exactly 8 long values using little-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Encode8ValuesBE(System.Span{System.Int64},System.Span{System.Byte},System.Int32)">
            <summary>
            Encodes exactly 8 values from input span. Unlike pack, checks for boundaries.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Pack8ValuesBE(System.Span{System.Int64},System.Span{System.Byte},System.Int32)">
            <summary>
            Packs exactly 8 long values using big-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Decode8ValuesBE(System.Span{System.Byte},System.Span{System.Int64},System.Int32)">
            <summary>
            Decodes exactly 8 values from input span. Unlike unpack, checks for boundaries.
            </summary>
            <returns>Number of values unpacked</returns>
        </member>
        <member name="M:Parquet.Encodings.BitPackedEncoder.Unpack8ValuesBE(System.Span{System.Byte},System.Span{System.Int64},System.Int32)">
            <summary>
            Unpacks exactly 8 long values using big-endian encoding from src into dest without checking for boundaries.
            </summary>
        </member>
        <member name="T:Parquet.Encodings.DeltaBinaryPackedEncoder">
             <summary>
             DELTA_BINARY_PACKED (https://github.com/apache/parquet-format/blob/master/Encodings.md#delta-encoding-delta_binary_packed--5)
             fastparquet sample: https://github.com/dask/fastparquet/blob/c59e105537a8e7673fa30676dfb16d9fa5fb1cac/fastparquet/cencoding.pyx#L232
             golang sample: https://github.com/xitongsys/parquet-go/blob/62cf52a8dad4f8b729e6c38809f091cd134c3749/encoding/encodingread.go#L270
            
             Supported Types: short, ushort, int, uint, long, ulong
             </summary>
        </member>
        <member name="M:Parquet.Encodings.DeltaBinaryPackedEncoder.CanEncode(System.Array,System.Int32,System.Int32)">
            <summary>
            Determines whether the specified data can be encoded using delta binary packed encoding.
            For ulong arrays, checks if all values are within the range of long.MaxValue.
            </summary>
            <param name="data">The input array to check</param>
            <param name="offset">Starting offset in the array</param>
            <param name="count">Number of elements to check</param>
            <returns>True if the data can be delta encoded, false otherwise</returns>
        </member>
        <member name="M:Parquet.Encodings.DeltaBinaryPackedEncoder.Encode(System.Array,System.Int32,System.Int32,System.IO.Stream,Parquet.Data.DataColumnStatistics)">
            <summary>
            Encodes the provided data using a delta encoding scheme and writes it to the given destination stream.
            Optionally, collects statistics about the encoded data if the 'stats' parameter is provided.
            </summary>
            <param name="data">The input array to be encoded.</param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="destination">The stream where the encoded data will be written.</param>
            <param name="stats">Optional parameter to collect statistics about the encoded data (can be null).</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:Parquet.Encodings.DeltaByteArrayEncoder">
            <summary>
            DELTA_BYTE_ARRAY = 7, aka "Delta Strings"
            Supported Types: BYTE_ARRAY, FIXED_LEN_BYTE_ARRAY
            see https://github.com/apache/parquet-format/blob/master/Encodings.md#delta-strings-delta_byte_array--7
            </summary>
            <remarks>
            This encoding depends on DELTA_BINARY_PACKED and DELTA_LENGTH_BYTE_ARRAY
            </remarks>
        </member>
        <member name="T:Parquet.Encodings.DeltaLengthByteArrayEncoder">
            <summary>
            DELTA_LENGTH_BYTE_ARRAY = 6
            Supported Types: BYTE_ARRAY
            see https://github.com/apache/parquet-format/blob/master/Encodings.md#delta-length-byte-array-delta_length_byte_array--6
            </summary>
        </member>
        <member name="T:Parquet.Encodings.ParquetPlainEncoder">
            <summary>
            Fast data encoder. 
            See https://github.com/aloneguid/parquet-dotnet/issues/643#issuecomment-3489932123 for future performance ideas.
            Experimental.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.ParquetPlainEncoder.FillStats(System.ReadOnlySpan{System.Byte},Parquet.Data.DataColumnStatistics)">
            Statistics will make certain types of queries on Parquet files much faster.
            The problem with statistics is they are very expensive to calculate, in particular
            exact number of distinct values.
            Min, Max and NullCount are relatively cheap though.
            To calculate distincts, we used to use HashSet and it's really slow, taking more than 50% of the whole encoding process.
            HyperLogLog is slower than HashSet though https://github.com/saguiitay/CardinalityEstimation .
        </member>
        <member name="M:Parquet.Encodings.RleBitpackedHybridEncoder.EncodeWithLength(System.IO.Stream,System.Int32,System.Span{System.Int32})">
            <summary>
            Writes to target stream without jumping around, therefore can be used in forward-only stream.
            Before writing actual data, writes out int32 value indicating total data binary length.
            </summary>
        </member>
        <member name="M:Parquet.Encodings.SchemaEncoder.Decode(System.Collections.Generic.List{Parquet.Meta.SchemaElement},Parquet.ParquetOptions,System.Int32@,System.Int32@)">
            <summary>
            Builds <see cref="T:Parquet.Schema.Field"/> from schema
            </summary>
            <param name="schema"></param>
            <param name="options"></param>
            <param name="index"></param>
            <param name="ownedChildCount"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Extensions.ArrayExtensions.Explode(System.Array,System.Span{System.Int32},System.Array,System.Int32,System.Int32)">
            <summary>
            Explodes dictionary and indexes into full array. This is used to unpack dictionary encoding.
            Result must be already pre-allocated before calling this method.
            </summary>
        </member>
        <member name="M:Parquet.Extensions.EncodingExtensions.ULEB128Encode(System.UInt64,System.Span{System.Byte},System.Int32@)">
            <summary>
            Encodes in ULEB128 and returns number of emitted bytes.
            https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128
            </summary>
        </member>
        <member name="M:Parquet.Extensions.EncodingExtensions.ULEB128Decode(System.Span{System.Byte},System.Int32@)">
            <summary>
            Decodes to unsigned long from span of bytes using ULEB128 encoding.
            </summary>
            <param name="data">Span to read from</param>
            <param name="offset">Reference to start offset in the span. It is updated as the value is read.</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Extensions.ExpressionExtensions.ClearArray(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Calls <see cref="M:System.Array.Clear(System.Array,System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Parquet.Extensions.ExpressionExtensions.GetPseudoCode(System.Linq.Expressions.Expression)">
            <summary>
            Gets internal property "DebugView" which is normally only available in Visual Studio debugging session
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.CollectionExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Batch through IEnumerable without going to the beginning every time. May need optimisations but OK so far.
            </summary>
        </member>
        <member name="T:Parquet.ThriftExtensions">
            <summary>
            Internal data structure helpers
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.CreateGenericList(System.Type)">
            <summary>
            Creates a generic typed list of elements of this type.
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.TryExtractIEnumerableType(System.Type,System.Type@)">
            <summary>
            Checks if this type implements generic IEnumerable or an array.
            </summary>
            <param name="t"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.File.DataColumnReader">
            <summary>
            Reader for Parquet data column
            </summary>
        </member>
        <member name="M:Parquet.File.DataColumnReader.GetColumnStatistics">
            <summary>
            Return data column statistics
            </summary>
            <returns>Data column statistics or null</returns>
        </member>
        <member name="M:Parquet.File.DataColumnReader.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            Read entire column data
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>DataColumn object filled in with data</returns>
            <exception cref="T:System.NotSupportedException">Unsupported page type</exception>
        </member>
        <member name="T:Parquet.File.PackedColumn">
            <summary>
            Represents column data packed into Parquet logical parts. This is an intermediate data structure that
            will be incorporated into <see cref="T:Parquet.Data.DataColumn"/> when the times are better.
            </summary>
        </member>
        <member name="M:Parquet.File.PackedColumn.Pack(System.Boolean,System.Double)">
            <summary>
            Sets statistics: null count
            </summary>
        </member>
        <member name="T:Parquet.File.StringListComparer">
            <summary>
            Wraps a list of strings and provides equality 
            </summary>
        </member>
        <member name="T:Parquet.File.Values.Primitives.BigDecimal">
            <summary>
            A class that encapsulates BigDecimal like the java class
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.DecimalValue">
            <summary>
            Contains a Decimal value that is the big integer
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Scale">
            <summary>
            The scale of the decimal value
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Precision">
            <summary>
            The precision of the decimal value
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.op_Implicit(Parquet.File.Values.Primitives.BigDecimal)~System.Decimal">
            <summary>
            Converts a BigDecimal to a decimal
            </summary>
            <param name="bd">The BigDecimal value</param>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.GetBufferSize(System.Int32)">
            <summary>
            Gets buffer size enough to be able to hold the decimal number of a specific precision
            </summary>
            <param name="precision">Precision value</param>
            <returns>Length in bytes</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.Interval">
            <summary>
            A parquet interval type compatible with a Spark INTERVAL type
            12 byte little Endian structure fits in an INT96 original type with an INTERVAL converted type
            </summary>
        </member>
        <member name="F:Parquet.File.Values.Primitives.Interval.BinarySize">
            <summary>
            Binary serialised size
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to create an interval type
            </summary>
            <param name="months">The month interval</param>
            <param name="days">The days interval</param>
            <param name="millis">The milliseconds interval</param>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Millis">
            <summary>
            Returns the number of milliseconds in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Days">
            <summary>
            Returns the number of days in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Months">
            <summary>
            Returns the number of months in type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.GetBytes">
            <summary>
            Converts to bytes representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.ToString">
            <summary>
            String repr
            </summary>
        </member>
        <member name="T:Parquet.Globals">
            <summary>
            Global values.
            CI should run envsubst to put actual values inside it. Prefer global constants to reflection as reflection is not
            available everywhere.
            </summary>
        </member>
        <member name="F:Parquet.Globals.Version">
            <summary>
            Library version
            </summary>
        </member>
        <member name="F:Parquet.Globals.GithubSha">
            <summary>
            Github Actions stamped commit SHA. For more supported variables see
            https://docs.github.com/en/actions/learn-github-actions/variables
            </summary>
        </member>
        <member name="T:Parquet.Meta.Type">
            <summary>
            Types supported by Parquet.  These types are intended to be used in combination with the encodings to control the on disk storage format. For example INT16 is not included as a type since a good encoding of INT32 would handle this.
            </summary>
        </member>
        <member name="T:Parquet.Meta.ConvertedType">
            <summary>
            DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet. ConvertedType is superseded by LogicalType.  This enum should not be extended.  See LogicalTypes.md for conversion between ConvertedType and LogicalType.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.UTF8">
            <summary>
            A BYTE_ARRAY actually contains UTF8 encoded chars.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.MAP">
            <summary>
            A map is converted as an optional field containing a repeated key/value pair.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.MAP_KEY_VALUE">
            <summary>
            A key/value pair is converted into a group of two fields.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.LIST">
            <summary>
            A list is converted into an optional field containing a repeated field for its values.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.ENUM">
            <summary>
            An enum is converted into a BYTE_ARRAY field.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.DECIMAL">
            <summary>
            A decimal value.  This may be used to annotate BYTE_ARRAY or FIXED_LEN_BYTE_ARRAY primitive types. The underlying byte array stores the unscaled value encoded as two&#39;s complement using big-endian byte order (the most significant byte is the zeroth element). The value of the decimal is the value * 10^{-scale}.  This must be accompanied by a (maximum) precision and a scale in the SchemaElement. The precision specifies the number of digits in the decimal and the scale stores the location of the decimal point. For example 1.23 would have precision 3 (3 total digits) and scale 2 (the decimal point is 2 digits over).
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.DATE">
            <summary>
            A Date  Stored as days since Unix epoch, encoded as the INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.TIME_MILLIS">
            <summary>
            A time  The total number of milliseconds since midnight.  The value is stored as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.TIME_MICROS">
            <summary>
            A time.  The total number of microseconds since midnight.  The value is stored as an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.TIMESTAMP_MILLIS">
            <summary>
            A date/time combination  Date and time recorded as milliseconds since the Unix epoch.  Recorded as a physical type of INT64.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.TIMESTAMP_MICROS">
            <summary>
            A date/time combination  Date and time recorded as microseconds since the Unix epoch.  The value is stored as an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.UINT_8">
            <summary>
            An unsigned integer value.  The number describes the maximum number of meaningful data bits in the stored value. 8, 16 and 32 bit values are stored using the INT32 physical type.  64 bit values are stored using the INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.INT_8">
            <summary>
            A signed integer value.  The number describes the maximum number of meaningful data bits in the stored value. 8, 16 and 32 bit values are stored using the INT32 physical type.  64 bit values are stored using the INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.JSON">
            <summary>
            An embedded JSON document  A JSON document embedded within a single UTF8 column.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.BSON">
            <summary>
            An embedded BSON document  A BSON document embedded within a single BYTE_ARRAY column.
            </summary>
        </member>
        <member name="F:Parquet.Meta.ConvertedType.INTERVAL">
            <summary>
            An interval of time  This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12 This data is composed of three separate little endian unsigned integers.  Each stores a component of a duration of time.  The first integer identifies the number of months associated with the duration, the second identifies the number of days associated with the duration and the third identifies the number of milliseconds associated with the provided duration.  This duration of time is independent of any particular timezone or date.
            </summary>
        </member>
        <member name="T:Parquet.Meta.FieldRepetitionType">
            <summary>
            Representation of Schemas.
            </summary>
        </member>
        <member name="F:Parquet.Meta.FieldRepetitionType.REQUIRED">
            <summary>
            This field is required (can not be null) and each row has exactly 1 value.
            </summary>
        </member>
        <member name="F:Parquet.Meta.FieldRepetitionType.OPTIONAL">
            <summary>
            The field is optional (can be null) and each row has 0 or 1 values.
            </summary>
        </member>
        <member name="F:Parquet.Meta.FieldRepetitionType.REPEATED">
            <summary>
            The field is repeated and can contain 0 or more values.
            </summary>
        </member>
        <member name="T:Parquet.Meta.Encoding">
            <summary>
            Encodings supported by Parquet.  Not all encodings are valid for all types.  These enums are also used to specify the encoding of definition and repetition levels. See the accompanying doc for the details of the more complicated encodings.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.PLAIN">
            <summary>
            Default encoding. BOOLEAN - 1 bit per value. 0 is false; 1 is true. INT32 - 4 bytes per value.  Stored as little-endian. INT64 - 8 bytes per value.  Stored as little-endian. FLOAT - 4 bytes per value.  IEEE. Stored as little-endian. DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian. BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes. FIXED_LEN_BYTE_ARRAY - Just the bytes.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.PLAIN_DICTIONARY">
            <summary>
            Deprecated: Dictionary encoding. The values in the dictionary are encoded in the plain type. in a data page use RLE_DICTIONARY instead. in a Dictionary page use PLAIN instead.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.RLE">
            <summary>
            Group packed run length encoding. Usable for definition/repetition levels encoding and Booleans (on one bit: 0 is false; 1 is true.).
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.BIT_PACKED">
            <summary>
            Bit packed encoding.  This can only be used if the data has a known max width.  Usable for definition/repetition levels encoding.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.DELTA_BINARY_PACKED">
            <summary>
            Delta encoding for integers. This can be used for int columns and works best on sorted data.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.DELTA_LENGTH_BYTE_ARRAY">
            <summary>
            Encoding for byte arrays to separate the length values and the data. The lengths are encoded using DELTA_BINARY_PACKED.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.DELTA_BYTE_ARRAY">
            <summary>
            Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED. Suffixes are stored as delta length byte arrays.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.RLE_DICTIONARY">
            <summary>
            Dictionary encoding: the ids are encoded using the RLE encoding.
            </summary>
        </member>
        <member name="F:Parquet.Meta.Encoding.BYTE_STREAM_SPLIT">
            <summary>
            Encoding for fixed-width data (FLOAT, DOUBLE, INT32, INT64, FIXED_LEN_BYTE_ARRAY). K byte-streams are created where K is the size in bytes of the data type. The individual bytes of a value are scattered to the corresponding stream and the streams are concatenated. This itself does not reduce the size of the data but can lead to better compression afterwards.  Added in 2.8 for FLOAT and DOUBLE. Support for INT32, INT64 and FIXED_LEN_BYTE_ARRAY added in 2.11.
            </summary>
        </member>
        <member name="T:Parquet.Meta.CompressionCodec">
            <summary>
            Supported compression algorithms.  Codecs added in format version X.Y can be read by readers based on X.Y and later. Codec support may vary between readers based on the format version and libraries available at runtime.  See Compression.md for a detailed specification of these algorithms.
            </summary>
        </member>
        <member name="T:Parquet.Meta.BoundaryOrder">
            <summary>
            Enum to annotate whether lists of min/max elements inside ColumnIndex are ordered and if so, in which direction.
            </summary>
        </member>
        <member name="T:Parquet.Meta.SizeStatistics">
            <summary>
            A structure for capturing metadata for estimating the unencoded, uncompressed size of data written. This is useful for readers to estimate how much memory is needed to reconstruct data in their memory model and for fine grained filter pushdown on nested structures (the histograms contained in this structure can help determine the number of nulls at a particular nesting level and maximum length of lists).
            </summary>
        </member>
        <member name="P:Parquet.Meta.SizeStatistics.UnencodedByteArrayDataBytes">
            <summary>
            The number of physical bytes stored for BYTE_ARRAY data values assuming no encoding. This is exclusive of the bytes needed to store the length of each byte array. In other words, this field is equivalent to the `(size of PLAIN-ENCODING the byte array values) - (4 bytes * number of values written)`. To determine unencoded sizes of other types readers can use schema information multiplied by the number of non-null and null values. The number of null/non-null values can be inferred from the histograms below.  For example, if a column chunk is dictionary-encoded with dictionary [&quot;a&quot;, &quot;bc&quot;, &quot;cde&quot;], and a data page contains the indices [0, 0, 1, 2], then this value for that data page should be 7 (1 + 1 + 2 + 3).  This field should only be set for types that use BYTE_ARRAY as their physical type.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SizeStatistics.RepetitionLevelHistogram">
            <summary>
            When present, there is expected to be one element corresponding to each repetition (i.e. size=max repetition_level+1) where each element represents the number of times the repetition level was observed in the data.  This field may be omitted if max_repetition_level is 0 without loss of information.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SizeStatistics.DefinitionLevelHistogram">
            <summary>
            Same as repetition_level_histogram except for definition levels.  This field may be omitted if max_definition_level is 0 or 1 without loss of information.
            </summary>
        </member>
        <member name="T:Parquet.Meta.Statistics">
            <summary>
            Statistics per row group and per page All fields are optional.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.Max">
            <summary>
            DEPRECATED: min and max value of the column. Use min_value and max_value.  Values are encoded using PLAIN encoding, except that variable-length byte arrays do not include a length prefix.  These fields encode min and max values determined by signed comparison only. New files should use the correct order for a column&#39;s logical type and store the values in the min_value and max_value fields.  To support older readers, these may be set when the column order is signed.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.NullCount">
            <summary>
            Count of null values in the column.  Writers SHOULD always write this field even if it is zero (i.e. no null value) or the column is not nullable. Readers MUST distinguish between null_count not being present and null_count == 0. If null_count is not present, readers MUST NOT assume null_count == 0.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.DistinctCount">
            <summary>
            Count of distinct values occurring.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.MaxValue">
            <summary>
            Lower and upper bound values for the column, determined by its ColumnOrder.  These may be the actual minimum and maximum values found on a page or column chunk, but can also be (more compact) values that do not exist on a page or column chunk. For example, instead of storing &quot;Blart Versenwald III&quot;, a writer may set min_value=&quot;B&quot;, max_value=&quot;C&quot;. Such more compact values must still be valid values within the column&#39;s logical type.  Values are encoded using PLAIN encoding, except that variable-length byte arrays do not include a length prefix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.IsMaxValueExact">
            <summary>
            If true, max_value is the actual maximum value for a column.
            </summary>
        </member>
        <member name="P:Parquet.Meta.Statistics.IsMinValueExact">
            <summary>
            If true, min_value is the actual minimum value for a column.
            </summary>
        </member>
        <member name="T:Parquet.Meta.StringType">
            <summary>
            Empty structs to use as logical type annotations.
            </summary>
        </member>
        <member name="T:Parquet.Meta.NullType">
            <summary>
            Logical type to annotate a column that is always null.  Sometimes when discovering the schema of existing data, values are always null and the physical type can&#39;t be determined. This annotation signals the case where the physical type was guessed from all null values.
            </summary>
        </member>
        <member name="T:Parquet.Meta.DecimalType">
            <summary>
            Decimal logical type annotation  Scale must be zero or a positive integer less than or equal to the precision. Precision must be a non-zero positive integer.  To maintain forward-compatibility in v1, implementations using this logical type must also set scale and precision on the annotated SchemaElement.  Allowed for physical types: INT32, INT64, FIXED_LEN_BYTE_ARRAY, and BYTE_ARRAY.
            </summary>
        </member>
        <member name="T:Parquet.Meta.MilliSeconds">
            <summary>
            Time units for logical types.
            </summary>
        </member>
        <member name="T:Parquet.Meta.TimestampType">
            <summary>
            Timestamp logical type annotation  Allowed for physical types: INT64.
            </summary>
        </member>
        <member name="T:Parquet.Meta.TimeType">
            <summary>
            Time logical type annotation  Allowed for physical types: INT32 (millis), INT64 (micros, nanos).
            </summary>
        </member>
        <member name="T:Parquet.Meta.IntType">
            <summary>
            Integer logical type annotation  bitWidth must be 8, 16, 32, or 64.  Allowed for physical types: INT32, INT64.
            </summary>
        </member>
        <member name="T:Parquet.Meta.JsonType">
            <summary>
            Embedded JSON logical type annotation  Allowed for physical types: BYTE_ARRAY.
            </summary>
        </member>
        <member name="T:Parquet.Meta.BsonType">
            <summary>
            Embedded BSON logical type annotation  Allowed for physical types: BYTE_ARRAY.
            </summary>
        </member>
        <member name="T:Parquet.Meta.VariantType">
            <summary>
            Embedded Variant logical type annotation.
            </summary>
        </member>
        <member name="T:Parquet.Meta.LogicalType">
            <summary>
            LogicalType annotations to replace ConvertedType.  To maintain compatibility, implementations using LogicalType for a SchemaElement must also set the corresponding ConvertedType (if any) from the following table.
            </summary>
        </member>
        <member name="T:Parquet.Meta.SchemaElement">
            <summary>
            Represents a element inside a schema definition.  - if it is a group (inner node) then type is undefined and num_children is defined  - if it is a primitive type (leaf) then type is defined and num_children is undefined the nodes are listed in depth first traversal order.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.Type">
            <summary>
            Data type for this field. Not set if the current element is a non-leaf node.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.TypeLength">
            <summary>
            If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the values. Otherwise, if specified, this is the maximum bit length to store any of the values. (e.g. a low cardinality INT col could have this set to 3).  Note that this is in the schema, and therefore fixed for the entire file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.RepetitionType">
            <summary>
            Repetition of the field. The root of the schema does not have a repetition_type. All other nodes must have one.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.Name">
            <summary>
            Name of the field in the schema.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.NumChildren">
            <summary>
            Nested fields.  Since thrift does not support nested fields, the nesting is flattened to a single list by a depth-first traversal. The children count is used to construct the nested relationship. This field is not set when the element is a primitive type.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.ConvertedType">
            <summary>
            DEPRECATED: When the schema is the result of a conversion from another model. Used to record the original type to help with cross conversion.  This is superseded by logicalType.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.Scale">
            <summary>
            DEPRECATED: Used when this column contains decimal data. See the DECIMAL converted type for more details.  This is superseded by using the DecimalType annotation in logicalType.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.FieldId">
            <summary>
            When the original schema supports field ids, this will save the original field id in the parquet schema.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SchemaElement.LogicalType">
            <summary>
            The logical type of this SchemaElement  LogicalType replaces ConvertedType, but ConvertedType is still required for some logical types to ensure forward-compatibility in format v1.
            </summary>
        </member>
        <member name="T:Parquet.Meta.DataPageHeader">
            <summary>
            Data page header.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeader.NumValues">
            <summary>
            Number of values, including NULLs, in this data page.  If a OffsetIndex is present, a page must begin at a row boundary (repetition_level = 0). Otherwise, pages may begin within a row (repetition_level &gt; 0).
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeader.Encoding">
            <summary>
            Encoding used for this data page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeader.DefinitionLevelEncoding">
            <summary>
            Encoding used for definition levels.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeader.RepetitionLevelEncoding">
            <summary>
            Encoding used for repetition levels.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeader.Statistics">
            <summary>
            Optional statistics for the data in this page.
            </summary>
        </member>
        <member name="T:Parquet.Meta.DictionaryPageHeader">
            <summary>
            The dictionary page must be placed at the first position of the column chunk if it is partly or completely dictionary encoded. At most one dictionary page can be placed in a column chunk.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DictionaryPageHeader.NumValues">
            <summary>
            Number of values in the dictionary.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DictionaryPageHeader.Encoding">
            <summary>
            Encoding using this dictionary page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DictionaryPageHeader.IsSorted">
            <summary>
            If true, the entries in the dictionary are sorted in ascending order.
            </summary>
        </member>
        <member name="T:Parquet.Meta.DataPageHeaderV2">
            <summary>
            New page format allowing reading levels without decompressing the data Repetition and definition levels are uncompressed The remaining section containing the data is compressed if is_compressed is true.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.NumValues">
            <summary>
            Number of values, including NULLs, in this data page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.NumNulls">
            <summary>
            Number of NULL values, in this data page. Number of non-null = num_values - num_nulls which is also the number of values in the data section.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.NumRows">
            <summary>
            Number of rows in this data page. Every page must begin at a row boundary (repetition_level = 0): rows must **not** be split across page boundaries when using V2 data pages.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.Encoding">
            <summary>
            Encoding used for data in this page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.DefinitionLevelsByteLength">
            <summary>
            Length of the definition levels.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.RepetitionLevelsByteLength">
            <summary>
            Length of the repetition levels.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.IsCompressed">
            <summary>
            Whether the values are compressed. Which means the section of the page between definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included) is compressed with the compression_codec. If missing it is considered compressed.
            </summary>
        </member>
        <member name="P:Parquet.Meta.DataPageHeaderV2.Statistics">
            <summary>
            Optional statistics for the data in this page.
            </summary>
        </member>
        <member name="T:Parquet.Meta.SplitBlockAlgorithm">
            <summary>
            Block-based algorithm type annotation.
            </summary>
        </member>
        <member name="T:Parquet.Meta.BloomFilterAlgorithm">
            <summary>
            The algorithm used in Bloom filter.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterAlgorithm.BLOCK">
            <summary>
            Block-based Bloom filter.
            </summary>
        </member>
        <member name="T:Parquet.Meta.XxHash">
            <summary>
            Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash algorithm. It uses 64 bits version of xxHash.
            </summary>
        </member>
        <member name="T:Parquet.Meta.BloomFilterHash">
            <summary>
            The hash function used in Bloom filter. This function takes the hash of a column value using plain encoding.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterHash.XXHASH">
            <summary>
            XxHash Strategy.
            </summary>
        </member>
        <member name="T:Parquet.Meta.Uncompressed">
            <summary>
            The compression used in the Bloom filter.
            </summary>
        </member>
        <member name="T:Parquet.Meta.BloomFilterHeader">
            <summary>
            Bloom filter header is stored at beginning of Bloom filter data of each column and followed by its bitset.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterHeader.NumBytes">
            <summary>
            The size of bitset in bytes.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterHeader.Algorithm">
            <summary>
            The algorithm for setting bits.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterHeader.Hash">
            <summary>
            The hash function used for Bloom filter.
            </summary>
        </member>
        <member name="P:Parquet.Meta.BloomFilterHeader.Compression">
            <summary>
            The compression used in the Bloom filter.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageHeader.Type">
            <summary>
            The type of the page: indicates which of the *_header fields is set.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageHeader.UncompressedPageSize">
            <summary>
            Uncompressed page size in bytes (not including this header).
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageHeader.CompressedPageSize">
            <summary>
            Compressed (and potentially encrypted) page size in bytes, not including this header.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageHeader.Crc">
            <summary>
            The 32-bit CRC checksum for the page, to be be calculated as follows:  - The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,   the same as in e.g. GZip). - All page types can have a CRC (v1 and v2 data pages, dictionary pages,   etc.). - The CRC is computed on the serialization binary representation of the page   (as written to disk), excluding the page header. For example, for v1   data pages, the CRC is computed on the concatenation of repetition levels,   definition levels and column values (optionally compressed, optionally   encrypted). - The CRC computation therefore takes place after any compression   and encryption steps, if any.  If enabled, this allows for disabling checksumming in HDFS if only a few pages need to be read.
            </summary>
        </member>
        <member name="T:Parquet.Meta.KeyValue">
            <summary>
            Wrapper struct to store key values.
            </summary>
        </member>
        <member name="T:Parquet.Meta.SortingColumn">
            <summary>
            Sort order within a RowGroup of a leaf column.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SortingColumn.ColumnIdx">
            <summary>
            The ordinal position of the column (in this row group).
            </summary>
        </member>
        <member name="P:Parquet.Meta.SortingColumn.Descending">
            <summary>
            If true, indicates this column is sorted in descending order.
            </summary>
        </member>
        <member name="P:Parquet.Meta.SortingColumn.NullsFirst">
            <summary>
            If true, nulls will come before non-null values, otherwise, nulls go at the end.
            </summary>
        </member>
        <member name="T:Parquet.Meta.PageEncodingStats">
            <summary>
            Statistics of a given page type and encoding.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageEncodingStats.PageType">
            <summary>
            The page type (data/dic/...).
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageEncodingStats.Encoding">
            <summary>
            Encoding of the page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageEncodingStats.Count">
            <summary>
            Number of pages of this type with this encoding.
            </summary>
        </member>
        <member name="T:Parquet.Meta.ColumnMetaData">
            <summary>
            Description for column metadata.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.Type">
            <summary>
            Type of this column.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.Encodings">
            <summary>
            Set of all encodings used for this column. The purpose is to validate whether we can decode those pages.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.PathInSchema">
            <summary>
            Path in schema.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.Codec">
            <summary>
            Compression codec.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.NumValues">
            <summary>
            Number of values in this column.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.TotalUncompressedSize">
            <summary>
            Total byte size of all uncompressed pages in this column chunk (including the headers).
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.TotalCompressedSize">
            <summary>
            Total byte size of all compressed, and potentially encrypted, pages in this column chunk (including the headers).
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.KeyValueMetadata">
            <summary>
            Optional key/value metadata.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.DataPageOffset">
            <summary>
            Byte offset from beginning of file to first data page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.IndexPageOffset">
            <summary>
            Byte offset from beginning of file to root index page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.DictionaryPageOffset">
            <summary>
            Byte offset from the beginning of file to first (only) dictionary page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.Statistics">
            <summary>
            Optional statistics for this column chunk.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.EncodingStats">
            <summary>
            Set of all encodings used for pages in this column chunk. This information can be used to determine if all data pages are dictionary encoded for example.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.BloomFilterOffset">
            <summary>
            Byte offset from beginning of file to Bloom filter data.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.BloomFilterLength">
            <summary>
            Size of Bloom filter data including the serialized header, in bytes. Added in 2.10 so readers may not read this field from old files and it can be obtained after the BloomFilterHeader has been deserialized. Writers should write this field so readers can read the bloom filter in a single I/O.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnMetaData.SizeStatistics">
            <summary>
            Optional statistics to help estimate total memory when converted to in-memory representations. The histograms contained in these statistics can also be useful in some cases for more fine-grained nullability/list length filter pushdown.
            </summary>
        </member>
        <member name="P:Parquet.Meta.EncryptionWithColumnKey.PathInSchema">
            <summary>
            Column path in schema.
            </summary>
        </member>
        <member name="P:Parquet.Meta.EncryptionWithColumnKey.KeyMetadata">
            <summary>
            Retrieval metadata of column encryption key.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.FilePath">
            <summary>
            File where column data is stored.  If not set, assumed to be same file as metadata.  This path is relative to the current file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.FileOffset">
            <summary>
            Deprecated: Byte offset in file_path to the ColumnMetaData  Past use of this field has been inconsistent, with some implementations using it to point to the ColumnMetaData and some using it to point to the first page in the column chunk. In many cases, the ColumnMetaData at this location is wrong. This field is now deprecated and should not be used. Writers should set this field to 0 if no ColumnMetaData has been written outside the footer.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.MetaData">
            <summary>
            Column metadata for this chunk. Some writers may also replicate this at the location pointed to by file_path/file_offset. Note: while marked as optional, this field is in fact required by most major Parquet implementations. As such, writers MUST populate this field.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.OffsetIndexOffset">
            <summary>
            File offset of ColumnChunk&#39;s OffsetIndex.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.OffsetIndexLength">
            <summary>
            Size of ColumnChunk&#39;s OffsetIndex, in bytes.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.ColumnIndexOffset">
            <summary>
            File offset of ColumnChunk&#39;s ColumnIndex.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.ColumnIndexLength">
            <summary>
            Size of ColumnChunk&#39;s ColumnIndex, in bytes.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.CryptoMetadata">
            <summary>
            Crypto metadata of encrypted columns.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnChunk.EncryptedColumnMetadata">
            <summary>
            Encrypted column metadata for this chunk.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.Columns">
            <summary>
            Metadata for each column chunk in this row group. This list must have the same order as the SchemaElement list in FileMetaData.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.TotalByteSize">
            <summary>
            Total byte size of all the uncompressed column data in this row group.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.NumRows">
            <summary>
            Number of rows in this row group.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.SortingColumns">
            <summary>
            If set, specifies a sort ordering of the rows in this RowGroup. The sorting columns can be a subset of all the columns.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.FileOffset">
            <summary>
            Byte offset from beginning of file to first page (data or dictionary) in this row group.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.TotalCompressedSize">
            <summary>
            Total byte size of all compressed (and potentially encrypted) column data in this row group.
            </summary>
        </member>
        <member name="P:Parquet.Meta.RowGroup.Ordinal">
            <summary>
            Row group ordinal in the file.
            </summary>
        </member>
        <member name="T:Parquet.Meta.TypeDefinedOrder">
            <summary>
            Empty struct to signal the order defined by the physical or logical type.
            </summary>
        </member>
        <member name="T:Parquet.Meta.ColumnOrder">
            <summary>
            Union to specify the order used for the min_value and max_value fields for a column. This union takes the role of an enhanced enum that allows rich elements (which will be needed for a collation-based ordering in the future).  Possible values are: * TypeDefinedOrder - the column uses the order defined by its logical or                      physical type (if there is no logical type).  If the reader does not support the value of this union, min and max stats for this column should be ignored.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnOrder.TYPEORDER">
            <summary>
            The sort orders for logical types are:   UTF8 - unsigned byte-wise comparison   INT8 - signed comparison   INT16 - signed comparison   INT32 - signed comparison   INT64 - signed comparison   UINT8 - unsigned comparison   UINT16 - unsigned comparison   UINT32 - unsigned comparison   UINT64 - unsigned comparison   DECIMAL - signed comparison of the represented value   DATE - signed comparison   TIME_MILLIS - signed comparison   TIME_MICROS - signed comparison   TIMESTAMP_MILLIS - signed comparison   TIMESTAMP_MICROS - signed comparison   INTERVAL - undefined   JSON - unsigned byte-wise comparison   BSON - unsigned byte-wise comparison   ENUM - unsigned byte-wise comparison   LIST - undefined   MAP - undefined   VARIANT - undefined  In the absence of logical types, the sort order is determined by the physical type:   BOOLEAN - false, true   INT32 - signed comparison   INT64 - signed comparison   INT96 (only used for legacy timestamps) - undefined   FLOAT - signed comparison of the represented value (*)   DOUBLE - signed comparison of the represented value (*)   BYTE_ARRAY - unsigned byte-wise comparison   FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison  (*) Because the sorting order is not specified properly for floating     point values (relations vs. total ordering) the following     compatibility rules should be applied when reading statistics:     - If the min is a NaN, it should be ignored.     - If the max is a NaN, it should be ignored.     - If the min is +0, the row group may contain -0 values as well.     - If the max is -0, the row group may contain +0 values as well.     - When looking for NaN values, min and max should be ignored.      When writing statistics the following rules should be followed:     - NaNs should not be written to min or max statistics fields.     - If the computed max value is zero (whether negative or positive),       `+0.0` should be written into the max statistics field.     - If the computed min value is zero (whether negative or positive),       `-0.0` should be written into the min statistics field.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageLocation.Offset">
            <summary>
            Offset of the page in the file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageLocation.CompressedPageSize">
            <summary>
            Size of the page, including header. Sum of compressed_page_size and header length.
            </summary>
        </member>
        <member name="P:Parquet.Meta.PageLocation.FirstRowIndex">
            <summary>
            Index within the RowGroup of the first row of the page. When an OffsetIndex is present, pages must begin on row boundaries (repetition_level = 0).
            </summary>
        </member>
        <member name="T:Parquet.Meta.OffsetIndex">
            <summary>
            Optional offsets for each data page in a ColumnChunk.  Forms part of the page index, along with ColumnIndex.  OffsetIndex may be present even if ColumnIndex is not.
            </summary>
        </member>
        <member name="P:Parquet.Meta.OffsetIndex.PageLocations">
            <summary>
            PageLocations, ordered by increasing PageLocation.offset. It is required that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index.
            </summary>
        </member>
        <member name="P:Parquet.Meta.OffsetIndex.UnencodedByteArrayDataBytes">
            <summary>
            Unencoded/uncompressed size for BYTE_ARRAY types.  See documention for unencoded_byte_array_data_bytes in SizeStatistics for more details on this field.
            </summary>
        </member>
        <member name="T:Parquet.Meta.ColumnIndex">
            <summary>
            Optional statistics for each data page in a ColumnChunk.  Forms part the page index, along with OffsetIndex.  If this structure is present, OffsetIndex must also be present.  For each field in this structure, &lt;field&gt;[i] refers to the page at OffsetIndex.page_locations[i].
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.NullPages">
            <summary>
            A list of Boolean values to determine the validity of the corresponding min and max values. If true, a page contains only null values, and writers have to set the corresponding entries in min_values and max_values to byte[0], so that all lists have the same length. If false, the corresponding entries in min_values and max_values must be valid.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.MinValues">
            <summary>
            Two lists containing lower and upper bounds for the values of each page determined by the ColumnOrder of the column. These may be the actual minimum and maximum values found on a page, but can also be (more compact) values that do not exist on a page. For example, instead of storing &quot;&quot;Blart Versenwald III&quot;, a writer may set min_values[i]=&quot;B&quot;, max_values[i]=&quot;C&quot;. Such more compact values must still be valid values within the column&#39;s logical type. Readers must make sure that list entries are populated before using them by inspecting null_pages.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.BoundaryOrder">
            <summary>
            Stores whether both min_values and max_values are ordered and if so, in which direction. This allows readers to perform binary searches in both lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even if the lists are ordered.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.NullCounts">
            <summary>
            A list containing the number of null values for each page  Writers SHOULD always write this field even if no null values are present or the column is not nullable. Readers MUST distinguish between null_counts not being present and null_count being 0. If null_counts are not present, readers MUST NOT assume all null counts are 0.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.RepetitionLevelHistograms">
            <summary>
            Contains repetition level histograms for each page concatenated together.  The repetition_level_histogram field on SizeStatistics contains more details.  When present the length should always be (number of pages * (max_repetition_level + 1)) elements.  Element 0 is the first element of the histogram for the first page. Element (max_repetition_level + 1) is the first element of the histogram for the second page.
            </summary>
        </member>
        <member name="P:Parquet.Meta.ColumnIndex.DefinitionLevelHistograms">
            <summary>
            Same as repetition_level_histograms except for definitions levels.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmV1.AadPrefix">
            <summary>
            AAD prefix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmV1.AadFileUnique">
            <summary>
            Unique file identifier part of AAD suffix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmV1.SupplyAadPrefix">
            <summary>
            In files encrypted with AAD prefix without storing it, readers must supply the prefix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmCtrV1.AadPrefix">
            <summary>
            AAD prefix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmCtrV1.AadFileUnique">
            <summary>
            Unique file identifier part of AAD suffix.
            </summary>
        </member>
        <member name="P:Parquet.Meta.AesGcmCtrV1.SupplyAadPrefix">
            <summary>
            In files encrypted with AAD prefix without storing it, readers must supply the prefix.
            </summary>
        </member>
        <member name="T:Parquet.Meta.FileMetaData">
            <summary>
            Description for file metadata.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.Version">
            <summary>
            Version of this file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.Schema">
            <summary>
            Parquet schema for this file.  This schema contains metadata for all the columns. The schema is represented as a tree with a single root.  The nodes of the tree are flattened to a list by doing a depth-first traversal. The column metadata contains the path in the schema for that column which can be used to map columns to nodes in the schema. The first element is the root.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.NumRows">
            <summary>
            Number of rows in this file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.RowGroups">
            <summary>
            Row groups in this file.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.KeyValueMetadata">
            <summary>
            Optional key/value metadata.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.CreatedBy">
            <summary>
            String for application that wrote this file.  This should be in the format &lt;Application&gt; version &lt;App Version&gt; (build &lt;App Build Hash&gt;). e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55).
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.ColumnOrders">
            <summary>
            Sort order used for the min_value and max_value fields in the Statistics objects and the min_values and max_values fields in the ColumnIndex objects of each column in this file. Sort orders are listed in the order matching the columns in the schema. The indexes are not necessary the same though, because only leaf nodes of the schema are represented in the list of sort orders.  Without column_orders, the meaning of the min_value and max_value fields in the Statistics object and the ColumnIndex object is undefined. To ensure well-defined behaviour, if these fields are written to a Parquet file, column_orders must be written as well.  The obsolete min and max fields in the Statistics object are always sorted by signed comparison regardless of column_orders.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.EncryptionAlgorithm">
            <summary>
            Encryption algorithm. This field is set only in encrypted files with plaintext footer. Files with encrypted footer store algorithm id in FileCryptoMetaData structure.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileMetaData.FooterSigningKeyMetadata">
            <summary>
            Retrieval metadata of key used for signing the footer. Used only in encrypted files with plaintext footer.
            </summary>
        </member>
        <member name="T:Parquet.Meta.FileCryptoMetaData">
            <summary>
            Crypto metadata for files with encrypted footer.
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileCryptoMetaData.EncryptionAlgorithm">
            <summary>
            Encryption algorithm. This field is only used for files with encrypted footer. Files with plaintext footer store algorithm id inside footer (FileMetaData structure).
            </summary>
        </member>
        <member name="P:Parquet.Meta.FileCryptoMetaData.KeyMetadata">
            <summary>
            Retrieval metadata of key used for encryption of footer, and (possibly) columns.
            </summary>
        </member>
        <member name="M:Parquet.Meta.Proto.ThriftCompactProtocolWriter.WriteEmptyStruct">
            <summary>
            Optimisation to write an empty struct - avoid push/pop
            </summary>
        </member>
        <member name="T:Parquet.ParquetActor">
            <summary>
            Base class for reader and writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetActor.Stream">
            <summary>
            Original stream to write or read
            </summary>
        </member>
        <member name="M:Parquet.ParquetActor.ValidateFileAsync">
            <summary>
            Validates that this file is a valid parquet file by reading head and tail of it
            </summary>
            <returns></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Parquet.ParquetException">
            <summary>
            Parquet format specific
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="T:Parquet.TableReaderProgressCallback">
            <summary>
            Progress callback
            </summary>
        </member>
        <member name="T:Parquet.ParquetExtensions">
            <summary>
            Defines extension methods to simplify Parquet usage
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.WriteSingleRowGroupParquetFileAsync(System.IO.Stream,Parquet.Schema.ParquetSchema,Parquet.Data.DataColumn[])">
            <summary>
            Writes a file with a single row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.ReadSingleRowGroupParquetFile(System.IO.Stream)">
            <summary>
            Reads the first row group from a file
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:Parquet.ParquetOptions">
            <summary>
            Parquet options
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatByteArrayAsString">
            <summary>
            When true byte arrays will be treated as UTF-8 strings on read
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatBigIntegersAsDates">
            <summary>
            Gets or sets a value indicating whether big integers are always treated as dates on read
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.UseDictionaryEncoding">
            <summary>
            Whether to use dictionary encoding for columns if data meets <seealso cref="P:Parquet.ParquetOptions.DictionaryEncodingThreshold"/>
            The following CLR types are currently supported:
            <see cref="T:System.String"/>, <see cref="T:System.DateTime"/>, <see cref="T:System.Decimal"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Single"/>, <see cref="T:System.Double"/>"/>
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.DictionaryEncodingThreshold">
            <summary>
            Dictionary uniqueness threshold, which is a value from 0 (no unique values) 
            to 1 (all values are unique) indicating when dictionary encoding is applied.
            Uniqueness factor needs to be less or equal than this threshold.
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.UseDeltaBinaryPackedEncoding">
            <summary>
            When set, the default encoding for INT32 and INT64 is <see cref="F:Parquet.Meta.Encoding.DELTA_BINARY_PACKED"/>, otherwise
            it's reverted to <see cref="F:Parquet.Meta.Encoding.PLAIN"/>. You should only set this to <see langword="false"/> if
            your readers do not understand it.
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.MaximumSmallPoolFreeBytes">
            <summary>
            This option is passed to the <see cref="T:Microsoft.IO.RecyclableMemoryStreamManager"/> , 
            which keeps a pool of streams in memory for reuse. 
            By default when this option is unset, the RecyclableStreamManager 
            will keep an unbounded amount of memory, which is 
            "indistinguishable from a memory leak" per their documentation.
            
            This does not restrict the size of the pool, but just allows 
            the garbage collector to free unused memory over this limit.
            
            You may want to adjust this smaller to reduce max memory usage, 
            or larger to reduce garbage collection frequency.
            
            Defaults to 16MB.  
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.MaximumLargePoolFreeBytes">
            <summary>
            This option is passed to the <see cref="T:Microsoft.IO.RecyclableMemoryStreamManager"/> , 
            which keeps a pool of streams in memory for reuse. 
            By default when this option is unset, the RecyclableStreamManager 
            will keep an unbounded amount of memory, which is 
            "indistinguishable from a memory leak" per their documentation.
            
            This does not restrict the size of the pool, but just allows 
            the garbage collector to free unused memory over this limit.
            
            You may want to adjust this smaller to reduce max memory usage, 
            or larger to reduce garbage collection frequency.
            
            Defaults to 64MB.
            </summary>
        </member>
        <member name="T:Parquet.ParquetReader">
            <summary>
            Implements Apache Parquet format reader, experimental version for next major release.
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.CreateAsync(System.String,Parquet.ParquetOptions,System.Threading.CancellationToken)">
            <summary>
            Opens reader from a file on disk. When the reader is disposed the file handle is automatically closed.
            </summary>
            <param name="filePath"></param>
            <param name="parquetOptions"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.CreateAsync(System.IO.Stream,Parquet.ParquetOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an instance from input stream
            </summary>
            <param name="input">Input stream, must be readable and seekable</param>
            <param name="parquetOptions">Optional reader options</param>
            <param name="leaveStreamOpen">When true, leaves the stream passed in <paramref name="input"/> open after disposing the reader.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">input</exception>
            <exception cref="T:System.ArgumentException">stream must be readable and seekable - input</exception>
            <exception cref="T:System.IO.IOException">not a Parquet file (size too small)</exception>
        </member>
        <member name="P:Parquet.ParquetReader.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadSchemaAsync(System.String)">
            <summary>
            Opens file at specified path to read schema and return
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadSchemaAsync(System.IO.Stream)">
            <summary>
            Reads file stream and returns
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.RowGroupCount">
            <summary>
            Gets the number of rows groups in this file
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.Schema">
            <summary>
            Reader schema
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.Metadata">
            <summary>
            Internal parquet metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.OpenRowGroupReader(System.Int32)">
            <summary>
            Opens row group reader. Note that this operation is really cheap as all the metadata is already present.
            It only gets expensive when you read actual data, not the metadata itself.
            </summary>
            <param name="index">Row group index, starting from 0. See <see cref="P:Parquet.ParquetReader.RowGroupCount"/> to get number of row groups in this file.</param>
            <returns></returns>
        </member>
        <member name="P:Parquet.ParquetReader.RowGroups">
            <summary>
            Collection of row group readers, fast random access and enumeration
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadEntireRowGroupAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads entire row group's data columns in one go.
            </summary>
            <param name="rowGroupIndex">Index of the row group. Default to the first row group if not specified.</param>
            <param name="cancellationToken">A token to monitor for cancellation requests.</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.Dispose">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:Parquet.IParquetRowGroupReader">
            <summary>
            Operations available on a row group reader, omitting Dispose, which is 
            exposed on the implementing class for backward compatibility only.
            </summary>
        </member>
        <member name="P:Parquet.IParquetRowGroupReader.RowGroup">
            <summary>
            Exposes raw metadata about this row group
            </summary>
        </member>
        <member name="P:Parquet.IParquetRowGroupReader.RowCount">
            <summary>
            Gets the number of rows in this row group
            </summary>
        </member>
        <member name="M:Parquet.IParquetRowGroupReader.ColumnExists(Parquet.Schema.DataField)">
            <summary>
            Checks if this field exists in source schema
            </summary>
        </member>
        <member name="M:Parquet.IParquetRowGroupReader.ReadColumnAsync(Parquet.Schema.DataField,System.Threading.CancellationToken)">
            <summary>
            Reads a column from this row group. Unlike writing, columns can be read in any order.
            If the column is missing, an exception will be thrown.
            </summary>
        </member>
        <member name="M:Parquet.IParquetRowGroupReader.GetMetadata(Parquet.Schema.DataField)">
            <summary>
            Gets raw column chunk metadata for this field
            </summary>
        </member>
        <member name="M:Parquet.IParquetRowGroupReader.GetCustomMetadata(Parquet.Schema.DataField)">
            <summary>
            Get custom key-value metadata for a data field
            </summary>
        </member>
        <member name="M:Parquet.IParquetRowGroupReader.GetStatistics(Parquet.Schema.DataField)">
            <summary>
            Returns data column statistics for a particular data field
            </summary>
            <param name="field"></param>
            <returns></returns>
            <exception cref="T:Parquet.ParquetException"></exception>
        </member>
        <member name="T:Parquet.ParquetRowGroupReader">
            <summary>
            Reader for Parquet row groups
            </summary>
        </member>
        <member name="P:Parquet.ParquetRowGroupReader.RowGroup">
            <summary>
            Exposes raw metadata about this row group
            </summary>
        </member>
        <member name="P:Parquet.ParquetRowGroupReader.RowCount">
            <summary>
            Gets the number of rows in this row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.ColumnExists(Parquet.Schema.DataField)">
            <summary>
            Checks if this field exists in source schema
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.ReadColumnAsync(Parquet.Schema.DataField,System.Threading.CancellationToken)">
            <summary>
            Reads a column from this row group. Unlike writing, columns can be read in any order.
            If the column is missing, an exception will be thrown.
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.GetMetadata(Parquet.Schema.DataField)">
            <summary>
            Gets raw column chunk metadata for this field
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.GetCustomMetadata(Parquet.Schema.DataField)">
            <summary>
            Get custom key-value metadata for a data field
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.GetStatistics(Parquet.Schema.DataField)">
            <summary>
            Returns data column statistics for a particular data field
            </summary>
            <param name="field"></param>
            <returns></returns>
            <exception cref="T:Parquet.ParquetException"></exception>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.Dispose">
            <summary>
            Dispose isn't required, retained for backward compatibility
            </summary>
        </member>
        <member name="T:Parquet.ParquetRowGroupWriter">
            <summary>
            Writer for Parquet row groups
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.WriteColumnAsync(Parquet.Data.DataColumn,System.Threading.CancellationToken)">
            <summary>
            Writes next data column to parquet stream. Note that columns must be written in the order they are declared in the
            file schema.
            </summary>
            <param name="column"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.WriteColumnAsync(Parquet.Data.DataColumn,System.Collections.Generic.Dictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Writes next data column to parquet stream. Note that columns must be written in the order they are declared in the
            file schema.
            </summary>
            <param name="column"></param>
            <param name="customMetadata">If specified, adds custom column chunk metadata</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.CompleteValidate">
            <summary>
            Call to indicate that all columns have been written, to validate completeness.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when not all columns from the schema have been written.</exception>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.Dispose">
            <summary>
            Finalizes the row group writing by updating row count and size metadata.
            </summary>
        </member>
        <member name="T:Parquet.ParquetWriter">
            <summary>
            Implements Apache Parquet format writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CompressionMethod">
            <summary>
            Type of compression to use, defaults to <see cref="F:Parquet.CompressionMethod.Snappy"/>
            </summary>
        </member>
        <member name="F:Parquet.ParquetWriter.CompressionLevel">
            <summary>
            Level of compression
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.CreateAsync(Parquet.Schema.ParquetSchema,System.IO.Stream,Parquet.ParquetOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of parquet writer on top of a stream
            </summary>
            <param name="schema"></param>
            <param name="output">Writeable, seekable stream</param>
            <param name="formatOptions">Additional options</param>
            <param name="append"></param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Output is null.</exception>
            <exception cref="T:System.ArgumentException">Output stream is not writeable</exception>
        </member>
        <member name="M:Parquet.ParquetWriter.CreateRowGroup">
            <summary>
            Creates a new row group and a writer for it.
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.Dispose">
            <summary>
            Disposes the writer and writes the file footer.
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.DisposeAsync">
            <summary>
            Dispose the writer asynchronously
            </summary>
        </member>
        <member name="T:Parquet.Schema.DataField">
            <summary>
            Field containing actual data, unlike fields containing metadata.
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.IsNullable">
            <summary>
            When true, this element is allowed to have nulls. Bad naming, probably should be something like IsNullable.
            Changes <see cref="P:Parquet.Schema.DataField.ClrNullableIfHasNullsType"/> property accordingly.
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.HasNulls">
            <summary>
            When true, this element is allowed to have nulls. Bad naming, probably should be something like IsNullable.
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.IsArray">
            <summary>
            When true, the value is an array rather than a single value.
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.ClrType">
            <summary>
            CLR type of this column. For nullable columns this type is not nullable.
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.ClrNullableIfHasNullsType">
            <summary>
            Unsupported, use at your own risk!
            </summary>
        </member>
        <member name="P:Parquet.Schema.DataField.FieldId">
            <summary>
            Optional metadata integer, used in Lake implementations. See https://arrow.apache.org/docs/cpp/parquet.html#parquet-field-id
            </summary>
        </member>
        <member name="M:Parquet.Schema.DataField.#ctor(System.String,System.Type,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Schema.DataField"/> by name and CLR type.
            </summary>
            <param name="name">Field name</param>
            <param name="clrType">CLR type of this field. The type is internally discovered and expanded into appropriate Parquet flags.</param>
            <param name="isNullable">When set, will override <see cref="P:Parquet.Schema.DataField.IsNullable"/> attribute regardless whether passed type was nullable or not.</param>
            <param name="isArray">When set, will override <see cref="P:Parquet.Schema.DataField.IsArray"/> attribute regardless whether passed type was an array or not.</param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="M:Parquet.Schema.DataField.CreateArray(System.Int32)">
            <summary>
            Creates non-nullable uninitialised array to hold this data type.
            </summary>
            <param name="length">Exact array size</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Schema.DataField.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.DataField.Equals(System.Object)">
            <summary>
            Basic equality check
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Schema.DataField.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.DataField.Clone">
            <summary>
            Simple memberwise clone
            </summary>
            <returns></returns>
        </member>
        <member name="T:Parquet.Schema.DataField`1">
            <summary>
            Element of dataset's schema. Provides a helper way to construct a schema element with .NET generics.
            <typeparamref name="T">Type of element in the column</typeparamref>
            </summary>
        </member>
        <member name="M:Parquet.Schema.DataField`1.#ctor(System.String,System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Schema.Field"/> class.
            </summary>
            <param name="name">Column name</param>
            <param name="nullable">Indicates if column can contain null values</param>
        </member>
        <member name="T:Parquet.Schema.DateTimeDataField">
            <summary>
            Schema element for <see cref="T:System.DateTime"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Schema.DateTimeDataField.DateTimeFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="P:Parquet.Schema.DateTimeDataField.IsAdjustedToUTC">
            <summary>
            IsAdjustedToUTC
            </summary>
        </member>
        <member name="P:Parquet.Schema.DateTimeDataField.Unit">
            <summary>
            TimeUnit
            </summary>
        </member>
        <member name="M:Parquet.Schema.DateTimeDataField.#ctor(System.String,Parquet.Schema.DateTimeFormat,System.Boolean,System.Nullable{Parquet.Schema.DateTimeTimeUnit},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Schema.DateTimeDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="isAdjustedToUTC"></param>
            <param name="unit"></param>
            <param name="isNullable"></param>
            <param name="isArray"></param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="T:Parquet.Schema.DateTimeFormat">
            <summary>
            Choice of representing dates
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeFormat.Impala">
            <summary>
            The impala compatible date, which maps to INT96. This is the default datetime representation.
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeFormat.DateAndTime">
            <summary>
            This is the default Parquet datetime representation, but not default option for saving which is <see cref="F:Parquet.Schema.DateTimeFormat.Impala"/>.
            Stores date and time up to millisecond precision as INT64
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeFormat.Date">
            <summary>
            Only stores a date. Time portion is truncated. Internally stored as INT32
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeFormat.Timestamp">
            <summary>
            Logical Type Timestamp.
            </summary>
        </member>
        <member name="T:Parquet.Schema.DateTimeTimeUnit">
            <summary>
            Support Time/Timestamp Units
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeTimeUnit.Millis">
            <summary>
            Millisecond Precision
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeTimeUnit.Micros">
            <summary>
            Microsecond Precision
            </summary>
        </member>
        <member name="F:Parquet.Schema.DateTimeTimeUnit.Nanos">
            <summary>
            Nanosecond Precision, note dotnet does not support full Nano second precision for DateTime
            </summary>
        </member>
        <member name="T:Parquet.Schema.DecimalDataField">
            <summary>
            Maps to Parquet decimal type, allowing to specify custom scale and precision
            </summary>
        </member>
        <member name="P:Parquet.Schema.DecimalDataField.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="P:Parquet.Schema.DecimalDataField.Scale">
            <summary>
            Scale
            </summary>
        </member>
        <member name="P:Parquet.Schema.DecimalDataField.ForceByteArrayEncoding">
            <summary>
            Gets a flag indicating whether byte array encoding is forced.
            </summary>
        </member>
        <member name="M:Parquet.Schema.DecimalDataField.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
            Constructs class instance
            </summary>
            <param name="name">The name of the column</param>
            <param name="precision">Custom precision</param>
            <param name="scale">Custom scale</param>
            <param name="forceByteArrayEncoding">Whether to force decimal type encoding as fixed bytes. Hive and Impala only understands decimals when forced to true.</param>
            <param name="isNullable"></param>
            <param name="isArray"></param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="T:Parquet.Schema.Field">
            <summary>
            Element of dataset's schema
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.SchemaType">
            <summary>
            Type of schema in this field
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.Path">
            <summary>
            Gets Parquet column path. For non-nested columns always equals to column <see cref="P:Parquet.Schema.Field.Name"/> otherwise contains
            a dot (.) separated path to the column within Parquet file. Note that this is a physical path which depends on field
            schema and you shouldn't build any reasonable business logic based on it.
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.IsNullable">
            <summary>
            Original nullability.
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.MaxRepetitionLevel">
            <summary>
            Max repetition level
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.MaxDefinitionLevel">
            <summary>
            Max definition level
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.ClrPropName">
            <summary>
            Used internally for serialisation
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.SchemaElement">
            <summary>
            Low-level schema element corresponding to this high-level schema element.
            Only set when reading files.
            </summary>
        </member>
        <member name="M:Parquet.Schema.Field.#ctor(System.String,Parquet.Schema.SchemaType)">
            <summary>
            Constructs a field with only requiremd parameters
            </summary>
            <param name="name">Field name, required</param>
            <param name="schemaType">Type of schema of this field</param>
        </member>
        <member name="M:Parquet.Schema.Field.PropagateLevels(System.Int32,System.Int32)">
            <summary>
            Called by schema when field hierarchy is constructed, so that fields can calculate levels as this is
            done in reverse order of construction and needs to be done after schema data is ready
            </summary>
        </member>
        <member name="P:Parquet.Schema.Field.Children">
            <summary>
            Get child fields, which only makes sense for complex types
            </summary>
        </member>
        <member name="M:Parquet.Schema.Field.BuildClrPath(Parquet.Schema.ParquetSchema)">
            <summary>
            Builds the path to navigate inside the CLR type hierarchy, rather than the native Parquet schema.
            Used internally by the class serializer to map schema fields to CLR object properties.
            </summary>
            <param name="schema">The Parquet schema to use for path resolution.</param>
            <returns>A collection of <see cref="T:Parquet.Schema.Field"/> objects representing the CLR path.</returns>
        </member>
        <member name="M:Parquet.Schema.Field.Rename(System.String)">
            <summary>
            Rename this field. Renaming should also fix up the path in complex nested schemas.
            </summary>
            <param name="newName"></param>
        </member>
        <member name="M:Parquet.Schema.Field.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.Field.Equals(System.Object)">
            <summary>
            Basic equality check
            </summary>
        </member>
        <member name="M:Parquet.Schema.Field.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Parquet.Schema.FieldPath">
            <summary>
            Represents path in schema. Path is a dot-separated string, however path parts can also contain dots!
            Never use strings to represent path, prefer this class.
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.#ctor(System.String)">
            <summary>
            Construct path single part, which becomes the first part in the result path.
            </summary>
            <param name="firstPart"></param>
        </member>
        <member name="M:Parquet.Schema.FieldPath.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs path from parts (safe)
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.#ctor(System.String[])">
            <summary>
            Constructs path from parts (safe)
            </summary>
            <param name="parts"></param>
        </member>
        <member name="M:Parquet.Schema.FieldPath.Append(System.String)">
            <summary>
            Append an element to path
            </summary>
            <param name="value">Can be null or empty (ignored).</param>
        </member>
        <member name="M:Parquet.Schema.FieldPath.ToList">
            <summary>
            Convert to list
            </summary>
            <returns></returns>
        </member>
        <member name="P:Parquet.Schema.FieldPath.FirstPart">
            <summary>
            Returns first part of the path, or null if path is empty
            </summary>
        </member>
        <member name="P:Parquet.Schema.FieldPath.Item(System.Int32)">
            <summary>
            Gets part by index
            </summary>
        </member>
        <member name="P:Parquet.Schema.FieldPath.Length">
            <summary>
            Number of elements in path
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.Equals(Parquet.Schema.FieldPath)">
            <summary>
            Compares string path
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.FieldPath.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.FieldPath.ToString">
            <summary>
            String repr
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.ToString(System.String,System.IFormatProvider)">
            <summary>
            String representation, where format is used as separator for joining parts.
            </summary>
        </member>
        <member name="M:Parquet.Schema.FieldPath.op_Addition(Parquet.Schema.FieldPath,Parquet.Schema.FieldPath)">
            <summary>
            Combines two paths safely
            </summary>
        </member>
        <member name="T:Parquet.Schema.ListField">
            <summary>
            Represents a list of items. The list can contain either a normal data field or a complex structure.
            If you need to get a list of primitive data fields it's more efficient to use arrays.
            </summary>
        </member>
        <member name="F:Parquet.Schema.ListField.ElementName">
            <summary>
            Name of the element item for schema definition.
            </summary>
        </member>
        <member name="F:Parquet.Schema.ListField.DefaultContainerName">
            <summary>
            Default container name for a list
            </summary>
        </member>
        <member name="P:Parquet.Schema.ListField.Item">
            <summary>
            Item contained within this list
            </summary>
        </member>
        <member name="M:Parquet.Schema.ListField.#ctor(System.String,Parquet.Schema.Field,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Schema.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="item">Field representing list element</param>
            <param name="containerName">Container name</param>
        </member>
        <member name="M:Parquet.Schema.ListField.#ctor(System.String,System.Type,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Schema.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="itemDataType">Type of the item in the list</param>
            <param name="propertyName">When set, uses this property to get the list's data.  When not set, uses the property that matches the name parameter.</param>
            <param name="containerName">Container name</param>
            <param name="elementName">Element name</param>
        </member>
        <member name="M:Parquet.Schema.ListField.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.ListField.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Parquet.Schema.MapField">
            <summary>
            Implements a dictionary field
            </summary>
        </member>
        <member name="P:Parquet.Schema.MapField.Key">
            <summary>
            Data field used as a key
            </summary>
        </member>
        <member name="P:Parquet.Schema.MapField.Value">
            <summary>
            Data field used as a value
            </summary>
        </member>
        <member name="M:Parquet.Schema.MapField.#ctor(System.String,Parquet.Schema.Field,Parquet.Schema.Field)">
            <summary>
            Declares a map field
            </summary>
        </member>
        <member name="M:Parquet.Schema.MapField.CreateSimpleDictionary">
            <summary>
            Creates an empty dictionary to keep values for this map field. Only works when both key and value are <see cref="T:Parquet.Schema.DataField"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Schema.MapField.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Parquet.Schema.MapField.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Parquet.Schema.ParquetSchema">
            <summary>
            Represents dataset schema
            </summary>
        </member>
        <member name="F:Parquet.Schema.ParquetSchema.PathSeparator">
            <summary>
            Symbol used to separate path parts in schema element path
            </summary>
        </member>
        <member name="F:Parquet.Schema.ParquetSchema.PathSeparatorChar">
            <summary>
            Character used to separate path parts in schema element path
            </summary>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.#ctor(System.Collections.Generic.IEnumerable{Parquet.Schema.Field})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Schema.ParquetSchema"/> class from schema elements.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.#ctor(Parquet.Schema.Field[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Schema.ParquetSchema"/> class.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="P:Parquet.Schema.ParquetSchema.Fields">
            <summary>
            Gets the schema elements
            </summary>
        </member>
        <member name="P:Parquet.Schema.ParquetSchema.Item(System.Int32)">
            <summary>
            Get schema element by index
            </summary>
            <param name="i">Index of schema element</param>
            <returns>Schema element</returns>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.GetDataFields">
            <summary>
            Gets a flat list of all data fields in this schema. Traverses schema tree in order to do that.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Parquet.Schema.ParquetSchema.DataFields">
            <summary>
            Gets data fields in this schema, including from nested types. Equivalent to <see cref="M:Parquet.Schema.ParquetSchema.GetDataFields"/>
            </summary>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.FindDataField(Parquet.Schema.FieldPath)">
            <summary>
            Finds a data field by its path. If not found, throws <see cref="T:System.ArgumentException"/> exception.
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.FindDataField(System.String)">
            <summary>
            Finds a data field by its path. If not found, throws <see cref="T:System.ArgumentException"/> exception.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.Flatten">
            <summary>
            Flattens schema fields i.e. returns all of them in a single dimensional list in no particular order.
            </summary>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.Equals(Parquet.Schema.ParquetSchema)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.GetNotEqualsMessage(Parquet.Schema.ParquetSchema,System.String,System.String)">
            <summary>
            Compares this schema to <paramref name="other"/> and produces a human readable message describing the differences.
            </summary>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.Augment(Parquet.Schema.ParquetSchema)">
            <summary>
            Augments this schema with any information that can be taken from an external schema, to make it more complete.
            It's internal for now due to the fact that it's not clear whether it should be exposed and what are the full side effects.
            </summary>
            <param name="schema"></param>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Parquet.Schema.ParquetSchema.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Parquet.Schema.SchemaType">
            <summary>
            Type of schema
            </summary>
        </member>
        <member name="F:Parquet.Schema.SchemaType.Data">
            <summary>
            Contains actual values i.e. declared by a <see cref="T:Parquet.Schema.DataField"/>
            </summary>
        </member>
        <member name="F:Parquet.Schema.SchemaType.Map">
            <summary>
            Contains dictionary definition
            </summary>
        </member>
        <member name="F:Parquet.Schema.SchemaType.Struct">
            <summary>
            Contains structure definition
            </summary>
        </member>
        <member name="F:Parquet.Schema.SchemaType.List">
            <summary>
            Contains list definition
            </summary>
        </member>
        <member name="T:Parquet.Schema.StructField">
            <summary>
            Represents a structure i.e. a container for other fields.
            </summary>
        </member>
        <member name="M:Parquet.Schema.StructField.#ctor(System.String,Parquet.Schema.Field[])">
            <summary>
            Creates a new structure field 
            </summary>
            <param name="name">Structure name</param>
            <param name="elements">List of elements</param>
        </member>
        <member name="P:Parquet.Schema.StructField.Fields">
            <summary>
            Elements of this structure
            </summary>
        </member>
        <member name="M:Parquet.Schema.StructField.Equals(Parquet.Schema.StructField)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Schema.TimeSpanDataField">
            <summary>
            Schema element for <see cref="T:System.TimeSpan"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Schema.TimeSpanDataField.TimeSpanFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Schema.TimeSpanDataField.#ctor(System.String,Parquet.Schema.TimeSpanFormat,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Schema.TimeSpanDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="isNullable"></param>
            <param name="isArray"></param>
            <param name="propertyName"></param>
        </member>
        <member name="T:Parquet.Schema.TimeSpanFormat">
            <summary>
            Choice of representing time
            </summary>
        </member>
        <member name="F:Parquet.Schema.TimeSpanFormat.MilliSeconds">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Schema.TimeSpanFormat.MicroSeconds">
            <summary>
            A time.
            
            The total number of microseconds since midnight.  The value is stored as
            an INT64 physical type.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetDecimalAttribute">
            <summary>
            Annotates a <see cref="T:System.Decimal"/> property to allow customizing precision and scale
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Attributes.ParquetDecimalAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="precision"></param>
            <param name="scale"></param>
        </member>
        <member name="P:Parquet.Serialization.Attributes.ParquetDecimalAttribute.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="P:Parquet.Serialization.Attributes.ParquetDecimalAttribute.Scale">
            <summary>
            Scale
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetIgnoreAttribute">
            <summary>
            Attribute to Ignore Field in Serialization, some times need data in json but not need in parquet.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetListElementRequiredAttribute">
            <summary>
            Changes column optionality to "required" for a list element.
            Only applicable to list definition, and applies to the list elements themselves, not the list class properties.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetMicroSecondsTimeAttribute">
            <summary>
            Specifies that <see cref="T:System.TimeSpan"/> field should be serialised with microseconds precision (not default milliseconds).
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetRequiredAttribute">
            <summary>
            Changes column optionality to "required".
            This is used to make string properties non-nullable, as in .NET strings are nullable by default.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetSimpleRepeatableAttribute">
            <summary>
            Specifies that a property is a simple repeatable field (as opposed to a list).
            Used only for legacy compatibility.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetTimestampResolution">
            <summary>
            Resolution of Parquet timestamp
            </summary>
        </member>
        <member name="F:Parquet.Serialization.Attributes.ParquetTimestampResolution.Milliseconds">
            <summary>
            Milliseconds, maps to <see cref="F:Parquet.Schema.DateTimeFormat.DateAndTime"/>"
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Attributes.ParquetTimestampAttribute">
            <summary>
            Specifies that a property of type <see cref="T:System.DateTime"/> should be serialized as Parquet timestamp, which is internally
            an int64 number.
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Attributes.ParquetTimestampAttribute.#ctor(Parquet.Serialization.Attributes.ParquetTimestampResolution,System.Boolean,System.Boolean)">
            <summary>
            Creates an instance of the attribute
            </summary>
            <param name="resolution"></param>
            <param name="useLogicalTimestamp"></param>
            <param name="isAdjustedToUTC"></param>
        </member>
        <member name="P:Parquet.Serialization.Attributes.ParquetTimestampAttribute.Resolution">
            <summary>
            Resolution of Parquet timestamp
            </summary>
        </member>
        <member name="P:Parquet.Serialization.Attributes.ParquetTimestampAttribute.UseLogicalTimestamp">
            <summary>
            Resolution of Parquet timestamp
            </summary>
        </member>
        <member name="P:Parquet.Serialization.Attributes.ParquetTimestampAttribute.IsAdjustedToUTC">
            <summary>
            IsAdjustedToUTC
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Dremel.FieldAssemblerCompiler`1.TransitionRSM">
            <summary>
            Transitions RSM for current RL iteration
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Dremel.FieldAssemblerCompiler`1.RebuildArray(System.Linq.Expressions.Expression,System.Type,System.Linq.Expressions.Expression)">
            <summary>
            Re-creates array with one extra element and copies old elements into it, then adds new element at the end
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Dremel.FieldStriperCompiler`1.WriteValue(System.Linq.Expressions.ParameterExpression,System.Int32,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            
            </summary>
            <param name="valueVar"></param>
            <param name="dl">Definition level if value is defined. For optional atoms that are null it must be -1.</param>
            <param name="currentRlVar"></param>
            <param name="isLeaf"></param>
            <param name="isAtomic">Value is atomic i.e. having real data value and not just RLs and DLs</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.Dremel.FieldStriperCompiler`1.Decode(System.Linq.Expressions.Expression,System.Type,System.Boolean,System.Int32,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,Parquet.Schema.Field,System.Int32,System.Collections.Generic.IReadOnlyCollection{Parquet.Schema.Field})">
            <summary>
            Corresponds to L6-L20 of Dremel paper Appendix A (Column-Striping Algorithm)
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Dremel.ParquetMap`2">
            <summary>
            Dictionary that allows for the values and keys to be set independently. Parquet MAP is physically stored as LIST of structs
            with key and value fields. .NET dictionary does not 100% map to this structure so this class is used as an intermediary.
            </summary>
        </member>
        <member name="T:Parquet.Serialization.Dremel.Striper`1">
            <summary>
            Not a stripper
            </summary>
        </member>
        <member name="T:Parquet.Serialization.ParquetSerializer">
            <summary>
            High-level object serialisation.
            Comes as a rewrite of ParquetConvert/ClrBridge/MSILGenerator and supports nested types as well.
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.SerializeRowGroupAsync``1(Parquet.ParquetWriter,System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Serialize a collection into one row group using an existing writer.
            </summary>
            <param name="writer"></param>
            <param name="objectInstances"></param>
            <param name="cancellationToken"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.SerializeAsync``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serialize 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectInstances"></param>
            <param name="destination"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.SerializeAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serialize from an IAsyncEnumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectInstances"></param>
            <param name="destination"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.ApplicationException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.SerializeAsync(Parquet.Schema.ParquetSchema,System.Collections.Generic.IReadOnlyCollection{System.Collections.Generic.IDictionary{System.String,System.Object}},System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Experimental object serialisation
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.SerializeAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serialise
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectInstances"></param>
            <param name="filePath"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(System.IO.Stream,System.Int32,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialise row group
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="rowGroupIndex"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(System.IO.Stream,System.Int32,System.Collections.Generic.IList{``0},Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Deserialize row group into provided list
            </summary>
            <param name="source"></param>
            <param name="rowGroupIndex"></param>
            <param name="result"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <param name="resultsAlreadyAllocated">Set to true if provided result collection already contains allocated elements (like using a pool)</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(Parquet.ParquetReader,System.Int32,System.Collections.Generic.IList{``0},System.Threading.CancellationToken,System.Boolean,Parquet.Serialization.ParquetSerializerOptions)">
            <summary>
            Deserialize row group into provided list, using provided Parquet reader
            Useful to iterate over row group using a single parquet reader
            </summary>
            <param name="reader"></param>
            <param name="rowGroupIndex"></param>
            <param name="result"></param>
            <param name="cancellationToken"></param>
            <param name="resultsAlreadyAllocated">Set to true if provided result collection already contains allocated elements (like using a pool)</param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(System.String,System.Int32,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialize a specific row group from a local file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filePath">Local file path</param>
            <param name="rowGroupIndex">Zero-based row group index</param>
            <param name="options">Parquet options</param>
            <param name="cancellationToken">Optional cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialise
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(System.String,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialise from local file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filePath">File path</param>
            <param name="options">Options</param>
            <param name="cancellationToken">Optional cancellation token</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Serialization.ParquetSerializer.UntypedResult">
            <summary>
            Highly experimental
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.UntypedResult.#ctor(System.Collections.Generic.IList{System.Collections.Generic.Dictionary{System.String,System.Object}},Parquet.Schema.ParquetSchema)">
            <summary>
            Highly experimental
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync(System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Highly experimental
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAllAsync``1(System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialize as async enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAllByGroupsAsync``1(System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserialize row group per row group as IAsyncEnumerable
            </summary>
            <param name="source"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeAsync``1(Parquet.ParquetRowGroupReader,Parquet.Schema.ParquetSchema,System.Threading.CancellationToken)">
            <summary>
            Deserialise
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rowGroupReader"></param>
            <param name="schema"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Parquet.Serialization.ParquetSerializer.DeserializeRowGroupAsync``1(Parquet.ParquetRowGroupReader,Parquet.Schema.ParquetSchema,System.Collections.Generic.ICollection{``0},System.Threading.CancellationToken,System.Boolean,Parquet.Serialization.ParquetSerializerOptions)">
            <summary>
            Deserialize a single row group into a provided collection.
            </summary>
            <param name="rowGroupReader"></param>
            <param name="schema"></param>
            <param name="result"></param>
            <param name="cancellationToken"></param>
            <param name="resultsAlreadyAllocated">Set to true if provided result collection already contains allocated elements (like using a pool)</param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Parquet.Serialization.ParquetSerializerOptions">
            <summary>
            Parquet serializer options
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.Append">
            <summary>
            When set to true, appends to file by creating a new row group.
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.CompressionMethod">
            <summary>
            Page compression method
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.CompressionLevel">
            <summary>
            Page compression level
            </summary>
        </member>
        <member name="F:Parquet.Serialization.ParquetSerializerOptions.DefaultRowGroupSize">
            <summary>
            Default size of row groups if not specified
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.RowGroupSize">
            <summary>
            Custom row group size, if different from 
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.PropertyNameCaseInsensitive">
            <summary>
            Gets or sets a value that indicates whether a property's name uses a case-insensitive comparison during deserialization. The default value is false.
            Full credits to https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.propertynamecaseinsensitive?view=net-8.0#system-text-json-jsonserializeroptions-propertynamecaseinsensitive
            </summary>
        </member>
        <member name="P:Parquet.Serialization.ParquetSerializerOptions.ParquetOptions">
            <summary>
            Further customisations
            </summary>
        </member>
        <member name="T:Parquet.Serialization.TypeExtensions">
            <summary>
            Makes <see cref="T:Parquet.Schema.ParquetSchema"/> from type information.
            Migrated from SchemaReflector to better fit into C# design strategy.
            </summary>
        </member>
        <member name="P:Parquet.Serialization.TypeExtensions.ClassMember.ColumnName">
            <summary>
            Parquet column name for this member. Will check appropriate attribute to detect name.
            </summary>
        </member>
        <member name="M:Parquet.Serialization.TypeExtensions.GetParquetSchema(System.Type,System.Boolean)">
            <summary>
            Reflects this type to get <see cref="T:Parquet.Schema.ParquetSchema"/>
            </summary>
            <param name="t"></param>
            <param name="forWriting">
            Set to true to get schema when deserialising into classes (writing to classes), otherwise false.
            The result will differ if for instance some properties are read-only and some write-only.
            </param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.TypeExtensions.MakeField(System.Type,System.String,System.String,Parquet.Serialization.TypeExtensions.ClassMember,System.Boolean)">
            <summary>
            Makes field from property. 
            </summary>
            <param name="t">Type of property</param>
            <param name="columnName">Parquet file column name</param>
            <param name="propertyName">Class property name</param>
            <param name="member">Optional <see cref="T:System.Reflection.PropertyInfo"/> that can be used to get attribute metadata.</param>
            <param name="forWriting"></param>
            <returns><see cref="T:Parquet.Schema.DataField"/> or complex field (recursively scans class). Can return null if property is explicitly marked to be ignored.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Parquet.Serialization.TypeExtensions.Convert(Parquet.Serialization.Attributes.ParquetTimestampResolution)">
            <summary>
            Convert Resolution to TimeUnit
            </summary>
            <param name="resolution"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.TypeExtensions.Convert(Parquet.Meta.TimeUnit)">
            <summary>
            Convert Parquet TimeUnit to TimeUnit
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Utils.FileMerger">
            <summary>
            Concatenates multiple files into a single file. The resulting file will contain all the data and row groups from the original files.
            Schemas in all the files must match.
            </summary>
        </member>
        <member name="M:Parquet.Utils.FileMerger.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Specifies the directory containing the files to concatenate.
            All the files with ".parquet" extension will be concatenated recursively.
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:Parquet.Utils.FileMerger.#ctor(System.Collections.Generic.IEnumerable{System.IO.FileInfo})">
            <summary>
            Specifies the files to concatenate. All the files must have the same schema due to parquet file format restrictions.
            </summary>
            <param name="files"></param>
        </member>
        <member name="P:Parquet.Utils.FileMerger.InputStreams">
            <summary>
            All the input streams to concatenate.
            </summary>
        </member>
        <member name="P:Parquet.Utils.FileMerger.InputFiles">
            <summary>
            All the input files to concatenate, if this instance was created using <see cref="T:System.IO.DirectoryInfo"/> or <see cref="T:System.IO.FileInfo"/> constructor.
            </summary>
        </member>
        <member name="M:Parquet.Utils.FileMerger.MergeFilesAsync(System.IO.Stream,Parquet.ParquetOptions,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{Parquet.CompressionMethod})">
            <summary>
            Merges all the files into a single file by copying row groups from each file into the resulting file.
            The resulting file will end up having as many row groups as the sum of row groups in all the files.
            </summary>
        </member>
        <member name="M:Parquet.Utils.FileMerger.MergeRowGroups(System.IO.Stream,Parquet.ParquetOptions,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{Parquet.CompressionMethod})">
            <summary>
            Merges all the row groups in the files into a single row group in the resulting file.
            If source files have more than one row group, they will be stil merged into one
            row group in the destination file, therefore you can use this method even on a single file if you
            want to just merge all the row groups into one.
            </summary>
            <param name="destination"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <param name="metadata"></param>
            <param name="compressionMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Utils.FileMerger.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Parquet.Utils.FlatTableConverter">
            <summary>
            Converts Parquet to a flat table. This class needs to be inherited to inject a specific
            target format implementation.
            </summary>
        </member>
        <member name="P:Parquet.Utils.FlatTableConverter.ListSeparator">
            <summary>
            When writing list values, this character is used to separate the values.
            </summary>
        </member>
        <member name="E:Parquet.Utils.FlatTableConverter.OnFileOpened">
            <summary>
            Invoked when a file is fully loaded. First argument is the number of rows in the file.
            </summary>
        </member>
        <member name="E:Parquet.Utils.FlatTableConverter.OnRowConverted">
            <summary>
            Invoked when a row is converted. First argument is the row number, second argument is the total number of rows.
            </summary>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.#ctor(System.IO.Stream,Parquet.Serialization.ParquetSerializerOptions)">
            <summary>
            Constructs a new instance of the converter
            </summary>
            <param name="parquetInputStream"></param>
            <param name="options"></param>
        </member>
        <member name="P:Parquet.Utils.FlatTableConverter.TotalRows">
            <summary>
            Gets the total number of rows in the Parquet file
            </summary>
        </member>
        <member name="P:Parquet.Utils.FlatTableConverter.ConvertedRows">
            <summary>
            Gets the number of rows converted so far
            </summary>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.ConvertAsync(System.Threading.CancellationToken)">
            <summary>
            Converts Parquet to a flat table
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.WriteHeaderAsync(Parquet.Schema.ParquetSchema,System.Threading.CancellationToken)">
            <summary>
            Invoked when the header should be written
            </summary>
            <param name="schema"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.NewRow">
            <summary>
            Invoked when a new row should be written
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.WriteCellAsync(Parquet.Schema.Field,System.Object,System.Threading.CancellationToken)">
            <summary>
            Invoked when a cell should be written
            </summary>
            <param name="df"></param>
            <param name="value"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Utils.FlatTableConverter.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:NetBox.TempFile">
            <summary>
            Represents a temporary file that is deleted on dispose. The files are created in user's temp directory.
            </summary>
        </member>
        <member name="M:NetBox.TempFile.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="ext">Optional extension, defaults to .tmp</param>
        </member>
        <member name="P:NetBox.TempFile.FullPath">
            <summary>
            Full path to the temp file. It's not created by this class.
            </summary>
        </member>
        <member name="M:NetBox.TempFile.op_Implicit(NetBox.TempFile)~System.String">
            <summary>
            Implicit conversion to string (full path).
            </summary>
            <param name="tf"></param>
        </member>
        <member name="M:NetBox.TempFile.ToString">
            <summary>
            Returns full path value
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetBox.WebUtility">
            <summary>
            This class is ported from .NET 4.6 to support URL encoding/decoding functionality which is missing in .NET Standard
            </summary>
        </member>
        <member name="T:NetBox.Ascii85">
            <summary>
            C# implementation of ASCII85 encoding. 
            Based on C code from http://www.stillhq.com/cgi-bin/cvsweb/ascii85/
            </summary>
            <remarks>
            Jeff Atwood
            http://www.codinghorror.com/blog/archives/000410.html
            </remarks>
        </member>
        <member name="F:NetBox.Ascii85.PrefixMark">
            <summary>
            Prefix mark that identifies an encoded ASCII85 string
            </summary>
        </member>
        <member name="F:NetBox.Ascii85.SuffixMark">
            <summary>
            Suffix mark that identifies an encoded ASCII85 string
            </summary>
        </member>
        <member name="F:NetBox.Ascii85.LineLength">
            <summary>
            Maximum line length for encoded ASCII85 string; 
            set to zero for one unbroken line.
            </summary>
        </member>
        <member name="M:NetBox.Ascii85.Decode(System.String,System.Boolean)">
            <summary>
            Decodes an ASCII85 encoded string into the original binary data
            </summary>
            <param name="s">ASCII85 encoded string</param>
            <param name="enforceMarks">enforce marks</param>
            <returns>byte array of decoded binary data</returns>
        </member>
        <member name="M:NetBox.Ascii85.Encode(System.Byte[],System.Boolean)">
            <summary>
            Encodes binary data into a plaintext ASCII85 format string
            </summary>
            <param name="ba">binary data to encode</param>
            <param name="enforceMarks">enforce marks</param>
            <returns>ASCII85 encoded string</returns>
        </member>
        <member name="F:NetBox.ByteFormat.Standard.Si">
            <summary>
             International System of Units
            </summary>
        </member>
        <member name="F:NetBox.ByteFormat.Standard.Iec">
            <summary>
            International Electrotechnical Commission
            </summary>
        </member>
        <member name="M:NetBox.ByteFormat.ToString(System.Int64,NetBox.ByteFormat.Standard)">
            <summary>
            Returns the best formatted string representation of a byte value
            </summary>
            <param name="bytes">number of bytes</param>
            <param name="st"></param>
            <returns>formatted string</returns>
        </member>
        <member name="M:NetBox.ByteFormat.ToString(System.Int64,NetBox.ByteFormat.Standard,System.String)">
            <summary>
            Returns the best formatted string representation of a byte value
            </summary>
            <param name="bytes">number of bytes</param>
            <param name="st"></param>
            <param name="customFormat">Defines a custom numerical format for the conversion.
            If this parameters is null or empty the default format will be used 0.00</param>
            <returns>formatted string</returns>
        </member>
        <member name="T:NetBox.Performance.TimeMeasure">
            <summary>
            Measures a time slice as precisely as possible
            </summary>
        </member>
        <member name="M:NetBox.Performance.TimeMeasure.#ctor">
            <summary>
            Creates the measure object
            </summary>
        </member>
        <member name="P:NetBox.Performance.TimeMeasure.ElapsedTicks">
            <summary>
            Returns number of elapsed ticks since the start of measure.
            The measuring process will continue running.
            </summary>
        </member>
        <member name="P:NetBox.Performance.TimeMeasure.ElapsedMilliseconds">
            <summary>
            Returns number of elapsed milliseconds since the start of measure.
            The measuring process will continue running.
            </summary>
        </member>
        <member name="P:NetBox.Performance.TimeMeasure.Elapsed">
            <summary>
            Gets time elapsed from the time this measure was created
            </summary>
        </member>
        <member name="M:NetBox.Performance.TimeMeasure.Dispose">
            <summary>
            Stops measure object if still running
            </summary>
        </member>
        <member name="T:NetBox.Generator.RandomGenerator">
            <summary>
            Generates random data using <see cref="T:System.Security.Cryptography.RandomNumberGenerator"/> for increased security
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomBool">
            <summary>
            Generates a random boolean
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomLong">
            <summary>
            Generates a random long number between 0 and max
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomInt">
            <summary>
            Generates a random integer between 0 and max
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomDouble">
            <summary>
            Returns random double
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomInt(System.Int32)">
            <summary>
            Generates a random integer until max parameter
            </summary>
            <param name="max">Maximum integer value, excluding</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomInt(System.Int32,System.Int32)">
            <summary>
            Generates a random integer number in range
            </summary>
            <param name="min">Minimum value, including</param>
            <param name="max">Maximum value, excluding</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomLong(System.Int64,System.Int64)">
            <summary>
            Generates a random long number in range
            </summary>
            <param name="min">Minimum value, including</param>
            <param name="max">Maximum value, excluding</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.RandomEnum(System.Type)">
            <summary>
            Generates a random enum value by type
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomEnum``1">
            <summary>
            Generates a random enum value
            </summary>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomDate(System.DateTime,System.DateTime)">
            <summary>
            Generates a random date in range
            </summary>
            <param name="minValue">Minimum date, including</param>
            <param name="maxValue">Maximum date, excluding</param>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomDate">
            <summary>
            Generates a random date value
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomString">
            <summary>
            Generates a random string. Never returns null.
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomString(System.Int32,System.Boolean)">
            <summary>
            Generates a random string
            </summary>
            <param name="length">string length</param>
            <param name="allowNulls">Whether to allow to return null values</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomUri(System.Boolean)">
            <summary>
            Generates a random URL in format "http://random.com/random.random
            </summary>
            <param name="allowNulls">Whether to allow to return nulls</param>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomUri">
            <summary>
            Generates a random URL in format "http://random.com/random.random. Never returns null values.
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomBytes(System.Int32,System.Int32)">
            <summary>
            Generates a random sequence of bytes of a specified size
            </summary>
        </member>
        <member name="T:NetBox.IO.NonCloseableStream">
            <summary>
            Represents a stream that ignores <see cref="T:System.IDisposable"/> operations i.e. cannot be closed by the client
            </summary>
        </member>
        <member name="M:NetBox.IO.NonCloseableStream.#ctor(System.IO.Stream)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="master">Master stream to delegate operations to</param>
        </member>
        <member name="M:NetBox.IO.NonCloseableStream.Dispose(System.Boolean)">
            <summary>
            Overrides this call to do nothing
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NetBox.IO.DelegatedStream">
            <summary>
            Makes stream members virtual instead of abstract, allowing to override only specific behaviors.
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.#ctor(System.IO.Stream)">
            <summary>
            Creates an instance of non-closeable stream
            </summary>
            <param name="master"></param>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanRead">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanRead"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanRead">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanSeek">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanSeek"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanSeek">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanWrite">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanWrite"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanWrite">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.Length">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetLength"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetLength">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.Position">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Flush">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.SetLength(System.Int64)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetBox.FileFormats.Csv.CsvReader">
            <summary>
            Reads data from a CSV file. Fast and reliable, supports:
            - newline characters
            - double quotes
            - commas
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates an instance from an open stream and encoding
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvReader.ReadAllFromContent(System.String,System.Boolean)">
            <summary>
            Reads all file as a dictionary of column name to list of values
            </summary>
            <param name="content">File content</param>
            <param name="hasColumns">When true, the first line of the file includes columns</param>
            <returns>Dictionary mapping the column name to the list of values</returns>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvReader.ReadNextRow">
            <summary>
            Reads next row of data if available.
            </summary>
            <returns>Null when end of file is reached, or array of strings for each column.</returns>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvFormat.EscapeValue(System.String)">
            <summary>
            Implemented according to RFC4180 http://tools.ietf.org/html/rfc4180
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NetBox.FileFormats.Csv.CsvWriter">
            <summary>
            Writes data to a CSV file. Fast and reliable, supports:
            - newline characters
            - double quotes
            - commas
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates a new instance of CsvWriter which uses UTF8 encoding
            </summary>
            <param name="destination"></param>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvWriter.#ctor(System.String)">
            <summary>
            Creates a new instance of CsvWriter on disk with UTF8 encoding
            </summary>
            <param name="fileName">File name or path</param>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates a new instance of CsvWriter and allows to specify the writer encoding
            </summary>
            <param name="destination"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvWriter.Write(System.String[])">
            <summary>
            Writes a row of data
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.Csv.CsvWriter.Write(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Writes a row of data
            </summary>
        </member>
        <member name="P:NetBox.FileFormats.Ini.IniSection.Name">
            <summary>
            Section name. Null name indicates global section (or no section, depending on the context)
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.Ini.IniSection.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name">Pass null to work with global section</param>
        </member>
        <member name="P:NetBox.FileFormats.Ini.IniSection.Keys">
            <summary>
            Get key names in this section
            </summary>
        </member>
    </members>
</doc>
