//
// $Id$
//
//
// Original author: Barbara Frewen <frewen@u.washington.edu>
//
// Copyright 2012 University of Washington - Seattle, WA 98195
//
// Licensed under the Apache License, Version 2.0 (the "License"); 
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License.
//

#include "pwiz/utility/misc/Std.hpp"
#include "pwiz/utility/misc/Filesystem.hpp"
#include <sqlite3.h>
#include <time.h>
#include "zlib.h"
#include "BlibMaker.h"
#include "SqliteRoutine.h"
#include <boost/log/detail/snprintf.hpp>
#include "SmallMolMetadata.h"
#include <boost/algorithm/string/classification.hpp>

namespace BiblioSpec {

    static const char ERROR_GENERIC[] = "Unexpected failure.";

// SQLite uses 1.5K pages, and PRAGMA cache_size is specified in these pages
//     see http://www.sqlite.org/pragma.html
const int BlibMaker::pages_per_meg = (int) (1024.0 / 1.5);
void BlibMaker::usage() {}


BlibMaker::BlibMaker(void)
: message(ERROR_GENERIC)
{
    db = NULL;
    scoreLookupMode_ = false;
    lib_name = NULL;
    lib_id = NULL;
    authority = "proteome.gs.washington.edu";
    cache_size = 250 * pages_per_meg;

    redundant = true;
    overwrite = false;
    verbose = false;
    unknown_file_id = -1; // none entered yet
    ambiguityMessages_ = false;
    keepAmbiguous_ = false;
    highPrecisionModifications_ = false;
}

BlibMaker::~BlibMaker(void)
{
    if (db != NULL)
        sqlite3_close(db);
}

int BlibMaker::parseCommandArgs(int argc, char* argv[])
{
    // Consume all options switches
    int i = 1;
    while (i < argc) {
        char* arg = argv[i];
        if (arg[0] != '-' || strlen(arg) != 2)
            break;
        else
            i = parseNextSwitch(i, argc, argv);
    }

    if (!isScoreLookupMode()) {
        // Must at least have the library name left
        if (argc - i < 1)
            usage();

        lib_name = argv[argc - 1];
        if (lib_id == NULL)
            lib_id = libIdFromName(lib_name);
    }

    return i;
}

int BlibMaker::parseNextSwitch(int i, int argc, char* argv[])
{
    char* arg = argv[i];
    char switchName = arg[1];

    if (switchName == 'v')
        verbose = true;
    else if (switchName == 'm' && ++i < argc) {
        cache_size = atoi(argv[i]) * pages_per_meg;
        if (cache_size == 0) {
            Verbosity::error("Invalid cache size specified.");
        }
    } else if (switchName == 'a' && ++i < argc) {
        authority = argv[i];
    } else if (switchName == 'i' && ++i < argc) {
        lib_id = argv[i];
    } else if (switchName == 'd') {
        // Generate table creation script, then exit
        vector<string> commands;
        lib_id = "example";
        createTables(commands, false);
        const char* fname = (++i < argc) ? argv[i] : NULL;
        ofstream fout;
        if (fname != NULL) {
            fout.open(fname);
        }
        ostream &out = (fname != NULL) ? (ostream&) fout : cout;
        out << "-- BiblioSpec format documentation" << endl;
        out << "-- These commands will create an empty BiblioSpec library when used with SQLite3. You can use them as a starting point for your own files." << endl;
        out << "-- This file was generated by the \"blibbuild -d\" command during the ProteoWizard build process. Do not edit, it may be overwritten and your changes will be lost." << endl;
        out << endl;
        for (int c = 0; c < commands.size(); c++) {
            out << endl << commands[c] << endl;
        }
        if (fname != NULL) {
            fout.close();
        }
        exit(0);
    } else if (switchName == 't') {
        scoreLookupMode_ = true;
    } else {
        usage();
    }
    
    return min(argc, i + 1);
}

void BlibMaker::verifyFileExists(string file) {
    if (!bfs::exists(file)) {
        throw BlibException(true, "Library file '%s' cannot be opened: file does not exist", bfs::absolute(file).string().c_str());
    }
    ifstream test(file);
    if (!test) {
        throw BlibException(true, "Library file '%s' cannot be opened", file.c_str());
    }
}

void BlibMaker::openDb(const char* file) {
    if (sqlite3_open(file, &db) != SQLITE_OK){
        Verbosity::error("Failed to create '%s'. Make sure the directory exists with write permissions.", file);
    }
}

void BlibMaker::init()
{
    if (scoreLookupMode_) {
        return;
    }

    // Check whether library already exists
    ifstream libName(lib_name);
    if(!libName.good()) {
        overwrite = true; // No library exists to append to
    } else {
        // Remove it, if this is to be an overwrite
        if (overwrite) {
            libName.close();
            bfs::remove(lib_name);
            ifstream libName2(lib_name);
            if (libName2.good()) {
                Verbosity::error("Failed to remove existing redundant "
                                 "library '%s'.", lib_name);
            }
        } else {
            // Overwrite, if it is a zero length file
            char ch;
            libName.get(ch);
            if (!libName.good())
                overwrite = true;
        }
    }
    
    if(libName.is_open())
        libName.close();
    
    openDb(lib_name);
    
    message = "Failed to initialize ";
    message += lib_name;
    
    sql_stmt("PRAGMA synchronous=OFF");
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "PRAGMA cache_size=%d", cache_size);
    sql_stmt(zSql);
    sql_stmt("PRAGMA temp_store=MEMORY");
    
    attachAll();
    vector<string> commands;
    if (overwrite){
        createTables(commands, true);
    } else {
        // Drop indexes for large numbers of insertions
        sql_stmt("DROP INDEX idxPeptide", true);
        sql_stmt("DROP INDEX idxPeptideMod", true);
        sql_stmt("DROP INDEX idxRefIdPeaks", true);
        sql_stmt("DROP INDEX idxRefIdPeakAnnotations", true);
        sql_stmt("DROP INDEX idxMoleculeName", true);
        sql_stmt("DROP INDEX idxInChiKey", true);

        // Add any missing tables or columns
        updateTables();
    }

    // these sql statments succeeded, return message to default    
    message = ERROR_GENERIC;
}

/**
 * Return true if there are no spectra in the current library.
 */
bool BlibMaker::is_empty(){
    if( getSpectrumCount() == 0 ){
        return true;
    }
    return false;
}

/**
 * Close the open library and delete the file.
 */
void BlibMaker::abort_current_library(){
    Verbosity::debug("Deleting current library.");

    // close db
    if (db != NULL){
        sqlite3_close(db);
        db = NULL;
    }

    // delete file
    bfs::remove(lib_name);
}

/**
 * Marks the beginning of a transaction, a set of statements to be
 * committed together.  Explicit transitions cannot be nested.  Commits
 * any open transactions.  Beginning a transaction tursn off
 * autocommit mode.
 */
void BlibMaker::beginTransaction(){

    // use autocommit mode to check for existing explicit transaction
    // autocommit mode is on by default, turned off by a BEGIN
    if( sqlite3_get_autocommit(db) == 0 ){ // auto commit off
        sql_stmt("COMMIT");
    }

    sql_stmt("BEGIN");
}

/**
 * Marks the end of the transaction by committing any active
 * statements submitted since the last "BEGIN" statement.  If no
 * active statements (autocommit mode is on), no action is taken.
 */
void BlibMaker::endTransaction(){

    if( sqlite3_get_autocommit(db) != 0 ){
        Verbosity::debug("No open transaction to end.");
        return;
    }

    sql_stmt("COMMIT");
}

/**
 * Rolls back any active transaction.  If no transaction is active
 * (i.e. the most recent changes were committed), no action is taken.
 */
void BlibMaker::undoActiveTransaction(){
    if( sqlite3_get_autocommit(db) != 0 ){
        Verbosity::debug("No open transaction to roll back.");
        return;
    }
    // else
    sql_stmt("ROLLBACK");
}

void BlibMaker::commit()
{
    updateLibInfo();

    sql_stmt("BEGIN");

    // Add indexes
    sql_stmt("CREATE INDEX idxPeptide ON RefSpectra (peptideSeq, precursorCharge)");
    sql_stmt("CREATE INDEX idxPeptideMod ON RefSpectra (peptideModSeq, precursorCharge)");
    sql_stmt("CREATE INDEX idxRefIdPeaks ON RefSpectraPeaks (RefSpectraID)");
    sql_stmt("CREATE INDEX idxRefIdPeakAnnotations ON RefSpectraPeakAnnotations (RefSpectraID)");
    sql_stmt("CREATE INDEX idxMoleculeName ON RefSpectra (moleculeName, precursorAdduct)");
    sql_stmt("CREATE INDEX idxInChiKey ON RefSpectra (inchiKey, precursorAdduct)");

    // And commit all changes
    sql_stmt("COMMIT");
}

string BlibMaker::getLSID()
{
    char blibLSID[2048];
    const char* libType = (redundant ? "redundant" : "nr");
    sprintf(blibLSID,"urn:lsid:%s:spectral_library:bibliospec:%s:%s",
            authority,libType,lib_id);
    string result(blibLSID);
    return result;
}

/**
 * Generates all the "CREATE TABLE" commands and optionally executes them in the current open
 * library.  Adds information to LibInfo and to SpectrumScoreTypes and IonMobilityTypes.
 */
void BlibMaker::createTables(vector<string> &commands, bool execute)
{
    commands.push_back(string("CREATE TABLE LibInfo( -- gives top level information about library, including whether it is redundant or non-redundant (nr). Redundant libraries may have more than one spectrum per precursor.\n"
        "libLSID TEXT, -- LSID of form urn:lsid:<authority>:spectral_library:bibliospec:<type:redundant|nr>:<library name> e.g. urn:lsid:proteome.gs.washington.edu:spectral_library:bibliospec:redundant:byonic.blib\n"
        "createTime TEXT, -- local creation time in ctime() format e.g. Thu Nov 16 17:02:18 2017\n"
        "numSpecs INTEGER, -- number of spectra in this library (-1 means not yet counted)\n"
        "majorVersion INTEGER, -- revision number for this library (count starts at 1)\n"
        "minorVersion INTEGER ") + version_history_comment +
        ")");

    //fill in the LibInfo first
    time_t t= time(NULL);
    char* date = ctime(&t);

    string blibLSID = getLSID();
    char zSql[ZSQLBUFLEN + 1];
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "INSERT INTO LibInfo values('%s','%.24s',%i,%i,%i)",  // %.24s drops the \n from ctime output
            blibLSID.c_str(), date, 
            -1, // init count as -1 to mean 'not counted', 0 could be 'no spec'
            MAJOR_VERSION_CURRENT, MINOR_VERSION_CURRENT);
    commands.push_back(zSql);
    string cols =
           "CREATE TABLE RefSpectra ( -- spectrum metadata - actual mz/intensity pairs in RefSpectraPeaks\n"
           "id INTEGER primary key autoincrement not null, -- lookup key for RefSpectraPeaks\n"
           "peptideSeq VARCHAR(150), -- unmodified peptide sequence, can be left blank for small molecule use\n"
           "precursorMZ REAL, -- mz of the precursor that produced this spectrum\n"
           "precursorCharge INTEGER, -- should agree with adduct if provided\n" 
           "peptideModSeq VARCHAR(200), -- modified peptide sequence, can be left blank for small molecule use\n"
           "prevAA CHAR(1), -- position of peptide in its parent protein (can be left blank)\n"
           "nextAA CHAR(1),  -- position of peptide in its parent protein (can be left blank)\n"
           "copies INTEGER, -- number of copies this spectrum was chosen from if it is in a filtered library\n"
           "numPeaks INTEGER, -- number of peaks, should agree with corresponding entry in RefSpectraPeaks\n"
           "ionMobility REAL, -- ion mobility value, if known (see ionMobilityType for units)\n"
           "collisionalCrossSectionSqA REAL, -- precursor CCS in square Angstroms for ion mobility, if known\n"
           "ionMobilityHighEnergyOffset REAL, -- ion mobility value increment for fragments (see ionMobilityType for units)\n"
           "ionMobilityType TINYINT, -- ion mobility units (required if ionMobility is used, see IonMobilityTypes table for key)\n"
           "retentionTime REAL, -- chromatographic retention time in minutes, if known\n"
           "startTime REAL, -- start retention time in minutes, if known\n"
           "endTime REAL, -- end retention time in minutes, if known\n"
           "totalIonCurrent REAL, -- total ion current of spectrum\n";
    cols += SmallMolMetadata::sql_col_decls();
    cols += "fileID INTEGER, -- index into SpectrumSourceFiles table for source file information\n"
           "SpecIDinFile VARCHAR(256), -- original spectrum label, id, or description in source file\n"
           "score REAL, -- spectrum score, typically a probability score (see scoreType)\n"
           "scoreType TINYINT -- spectrum score type, see ScoreTypes table for meaning\n"
           ")";
    commands.push_back(cols);

    commands.push_back("CREATE TABLE Modifications ( -- modification masses and positions (peptide use only)\n"
           "id INTEGER primary key autoincrement not null,\n"
           "RefSpectraID INTEGER, -- the RefSpectra in which this modification occurs\n"
           "position INTEGER, -- position of the modified AA in the peptide (1-based)\n"
           "mass REAL -- incremental mass of the modification\n"
           ")");

    commands.push_back("CREATE TABLE RefSpectraPeaks( -- mz and intensity values\n"
        "RefSpectraID INTEGER, -- ID of the RefSpectra containing these peaks\n"
        "peakMZ BLOB, -- mz values encoded as little-endian 64 bit doubles, length is determined by the numPeaks value in the corresponding RefSpectra. Usually zlib-compressed if compressed size is less than original size.\n"
        "peakIntensity BLOB -- mz values encoded as little-endian 32 bit floats, length is determined by the numPeaks value in the corresponding RefSpectra.  Usually zlib-compressed if compressed size is less than original size.\n"
        ")");

    createTable("Proteins", commands, false);
    createTable("RefSpectraProteins", commands, false);
    createTable("RefSpectraPeakAnnotations", commands, false);
    createTable("SpectrumSourceFiles", commands, false);
    createTable("ScoreTypes", commands, false);
    createTable("IonMobilityTypes", commands, false);

    if (execute)
    {
        for (int i = 0; i < commands.size(); i++)
        {
            sql_stmt(commands[i].c_str());
        }
    }

}

/**
 * Generates the SQLite commands to create and initialize the named table, and optionally execute them while doing so
 * May be added to new libraries (as part of createTables()) or to existing libraries (as part of updateTables()).
 */
void BlibMaker::createTable(const char* tableName, vector<string> &commands, bool execute){

   int initial_count = commands.size();
    if( strcmp(tableName, "SpectrumSourceFiles") == 0 ){
        commands.push_back(
            "CREATE TABLE SpectrumSourceFiles ( -- information about the file or files from which this spectral library was derived\n"
               "id INTEGER PRIMARY KEY autoincrement not null,\n"
               "fileName VARCHAR(512), -- source spectrum file; same as idFilename if embedded spectra were used, otherwise the path to the external spectrum file (mzML/mzXML)\n"
               "idFileName VARCHAR(512), -- identification file, typically some kind of search tool output\n"
               "cutoffScore REAL -- filter threshold used when converting the source file to a BiblioSpec library. See RefSpectra scoreType field for information about the type of cutoff.\n"
               ")");

    } else if( strcmp(tableName, "ScoreTypes") == 0 ){
        // set key = enum value of score type; don't autoincrement
        commands.push_back(
               "CREATE TABLE ScoreTypes ( -- information about the various kinds of cutoff scores understood by BiblioSpec\n"
               "id INTEGER PRIMARY KEY,  -- as used in scoreType field of RefSpectra\n"
               "scoreType VARCHAR(128), -- name of the score type, \n"
               "probabilityType VARCHAR(128) -- detail about the cutoff logic used by each score type, PROBABILITY_THAT_IDENTIFICATION_IS_CORRECT, PROBABILITY_THAT_IDENTIFICATION_IS_INCORRECT, or NOT_A_PROBABILITY_VALUE\n"
               ")");
        // insert all score types
        for(int i=0; i < NUM_PSM_SCORE_TYPES; i++){
            boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
                    "INSERT INTO ScoreTypes(id, scoreType, probabilityType) VALUES(%d, '%s', '%s')",
                    i, scoreTypeToString((PSM_SCORE_TYPE)i), scoreTypeToProbabilityTypeString((PSM_SCORE_TYPE)i));
            commands.push_back(zSql);
        }
    }
    else if (strcmp(tableName, "IonMobilityTypes") == 0){
        // set key = enum value of score type; don't autoincrement
        commands.push_back(
            "CREATE TABLE IonMobilityTypes ( -- table of known ion mobility units\n"
            "id INTEGER PRIMARY KEY, -- as used in ionMobilityType field of RefSpectra\n"
            "ionMobilityType VARCHAR(128) -- text description of ion mobility units\n"
            ")");
        // insert all ionMobility types
        for (int i = 0; i < NUM_IONMOBILITY_TYPES; i++){
            boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
                "INSERT INTO IonMobilityTypes(id, ionMobilityType) VALUES(%d, '%s')",
                i, ionMobilityTypeToString((IONMOBILITY_TYPE)i));
            commands.push_back(zSql);
        }
    }
    else if (strcmp(tableName, "RefSpectraPeakAnnotations") == 0){
        strncpy(zSql,
            "CREATE TABLE RefSpectraPeakAnnotations -- optional annotations for peaks in RefSpectra. There may be more than one annotation per peak, and not every peak in a RefSpectra has to be annotated.\n"
            "(id INTEGER primary key autoincrement not null,\n"
            "RefSpectraID INTEGER not null, -- the RefSpectra containing the peak being annotated\n"
            "peakIndex INTEGER not null, -- index into the mz/intensity list for the RefSpectra\n"
            "name VARCHAR(256), -- fragment molecule name\n"
            "formula VARCHAR(256), -- fragment neutral chemical formula\n"
            "inchiKey VARCHAR(256), -- fragment molecular identifier for structure retrieval\n"
            "otherKeys VARCHAR(256), -- alternative molecular identifiers for fragment structure retrieval, tab separated e.g. cas:58-08-2\\thmdb:01847 \n"
            "charge INTEGER, -- integer charge value, must agree with fragment adduct\n"
            "adduct VARCHAR(256), -- fragment adduct description, can include neutral loss e.g. [M+H] or [M-H2O+] \n"
            "comment VARCHAR(256), -- freetext comment\n"
            "mzTheoretical REAL not null, -- calculated mz, should agree with formula and adduct if any\n"
            "mzObserved REAL not null -- actual measured mz, should agree with the indexed mz found in the RefSpectra\n)",
            ZSQLBUFLEN);
        commands.push_back(zSql);
    } else if (strcmp(tableName, "Proteins") == 0) {
        commands.push_back(
            "CREATE TABLE Proteins -- protein information for RefSpectra.\n"
            "(id INTEGER primary key autoincrement not null,\n"
            "accession VARCHAR(200) -- protein accession number\n)");
    } else if (strcmp(tableName, "RefSpectraProteins") == 0) {
        commands.push_back(
            "CREATE TABLE RefSpectraProteins -- mapping of proteins between RefSpectra and Proteins tables.\n"
            "(RefSpectraId INTEGER not null, -- the RefSpectra being mapped to a protein\n"
            "ProteinId INTEGER not null -- the Protein for the RefSpectra\n)");
    } else {
        Verbosity::error("Cannot create '%s' table. Unknown name.",
                         tableName);
    }

    if (execute)
    {
        for (int i = initial_count; i < commands.size(); i++)
        {
            sql_stmt(commands[i].c_str());
        }
    }
}

/**
 * Checks the schema of the library in which we are saving spectra and
 * adds any missing tables and columns.
 */
void BlibMaker::updateTables(){
    vector<string> commands;
    // SpectrumSourceFiles table
    if( !tableExists("main", "SpectrumSourceFiles") ){
        createTable("SpectrumSourceFiles", commands, true);

        // add an unknown source file id
        strncpy(zSql, "INSERT INTO SpectrumSourceFiles (fileName, cutoffScore) "
            "VALUES ('UNKNOWN', -1)",
            ZSQLBUFLEN);
        sql_stmt(zSql); 
        unknown_file_id = (int)sqlite3_last_insert_rowid(db);

    } else {
        // if the table already exists, look for the UNKNOWN file
        unknown_file_id = getUnknownFileId();
    }
    
    // ScoreTypes table
    if (!tableExists("main", "ScoreTypes")){
        createTable("ScoreTypes", commands, true);
    }

    if (!tableExists("main", "RefSpectraPeakAnnotations")){
        createTable("RefSpectraPeakAnnotations", commands, true);
    }

    if (!tableExists("main", "Proteins")) {
        createTable("Proteins", commands, true);
    }

    if (!tableExists("main", "RefSpectraProteins")) {
        createTable("RefSpectraProteins", commands, true);
    }

    vector< pair<string, string> > newColumns;
    newColumns.push_back(make_pair("retentionTime", "REAL"));
    newColumns.push_back(make_pair("startTime", "REAL"));
    newColumns.push_back(make_pair("endTime", "REAL"));
    newColumns.push_back(make_pair("fileID", "INTEGER"));
    newColumns.push_back(make_pair("SpecIDinFile", "VARCHAR(256)"));
    newColumns.push_back(make_pair("score", "REAL"));
    newColumns.push_back(make_pair("scoreType", "TINYINT"));

    // Ion mobility
    newColumns.push_back(make_pair("collisionalCrossSectionSqA", "REAL"));
    newColumns.push_back(make_pair("ionMobility", "REAL"));
    newColumns.push_back(make_pair("ionMobilityHighEnergyOffset", "REAL"));
    newColumns.push_back(make_pair("ionMobilityType", "TINYINT"));

    newColumns.push_back(make_pair("totalIonCurrent", "REAL"));
    
    vector <string> smallMolCols = SmallMolMetadata::sql_col_names();
    vector <string> smallMolTypes = SmallMolMetadata::sql_col_types();
    int col = 0;
    for (vector<string>::const_iterator s = smallMolCols.begin(); s != smallMolCols.end(); ++s)
    {
        newColumns.push_back(make_pair(*s, smallMolTypes[col++]));
    }

    for (vector< pair<string, string> >::const_iterator i = newColumns.begin(); i != newColumns.end(); ++i) {
        if (!tableColumnExists("main", "RefSpectra", i->first.c_str())) {
            boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "ALTER TABLE RefSpectra ADD %s %s", i->first.c_str(), i->second.c_str());
            sql_stmt(zSql);
        }
    }

    if (!tableColumnExists("main", "SpectrumSourceFiles", "idFileName")) {
        sql_stmt("ALTER TABLE SpectrumSourceFiles ADD COLUMN idFileName TEXT");
    }

    // update fileID and scoreType to be unknown in all existing spec
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "UPDATE RefSpectra SET fileID = '%d' "
            "WHERE fileID IS NULL", unknown_file_id );
    sql_stmt(zSql);
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "UPDATE RefSpectra SET scoreType = '%d' "
            "WHERE scoreType IS NULL", UNKNOWN_SCORE_TYPE );
    sql_stmt(zSql);
}

/**
 * Query the SpectrumSourceFiles table for the entry 'UNKNOWN'.
 * Return its id if present, else -1.
 */
int BlibMaker::getUnknownFileId(){
    if( ! tableExists("main", "SpectrumSourceFiles") ){
        return -1;
    }

    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT id FROM SpectrumSourceFiles "
            "WHERE fileName = 'UNKNOWN'");
    smart_stmt pStmt;
    int return_code = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
    check_rc(return_code, zSql, "Failed looking for spectrum file 'UNKNOWN'");
    return_code = sqlite3_step(pStmt);
    if( return_code != SQLITE_ROW ){ // then it's not there
        return -1;
    } // else
    return sqlite3_column_int(pStmt, 0);
}

namespace {
    struct SchemaColumnInfo
    {
        const char* currentName;
        vector<const char*> previousNames;
        const char* defaultValue;
    };

    vector<SchemaColumnInfo> schemaColumnInfo =
    {
        { "SpecIDinFile", {}, "NULL" },
        { "retentionTime", {}, "0" },
        { "ionMobility", {"driftTimeMsec", "ionMobilityValue"}, "0" },
        { "ionMobilityType", {}, "1" }, // drift time is default
        { "collisionalCrossSectionSqA", {}, "0" },
        { "ionMobilityHighEnergyOffset", {"driftTimeHighEnergyOffsetMsec", "ionMobilityHighEnergyDriftTimeOffsetMsec"}, "0" },
        { "startTime", {}, "NULL" },
        { "endTime", {}, "NULL" },
        { "totalIonCurrent", {}, "NULL" },
        { "moleculeName", {}, "NULL" },
        { "chemicalFormula", {}, "NULL" },
        { "inchiKey", {}, "NULL" },
        { "otherKeys", {}, "NULL" },
        { "precursorAdduct", {}, "NULL" }
    };
}

/// create a temporary view of the attached file with an up-to-date schema, substituting previous column names or default values where necessary
void BlibMaker::createUpdatedRefSpectraView(const char* sourceDbName) {

    string viewSql = "CREATE TEMP VIEW RefSpectraTransfer AS SELECT id, peptideSeq, precursorMZ, precursorCharge, peptideModSeq, "
                     "prevAA, nextAA, copies, numPeaks, fileID, score, scoreType";
    for (const auto& columnInfo : schemaColumnInfo)
    {
        if (tableColumnExists(sourceDbName, "RefSpectra", columnInfo.currentName))
            viewSql += string(", ") + columnInfo.currentName;
        else
        {
            string substituteValue;
            for (const auto& previousName : columnInfo.previousNames)
                if (tableColumnExists(sourceDbName, "RefSpectra", previousName))
                {
                    substituteValue = previousName; // forward previous column name to current one
                    break;
                }
            if (substituteValue.empty())
                substituteValue = columnInfo.defaultValue; // use default value

            viewSql += ", " + substituteValue + " AS " + columnInfo.currentName;
        }
    }
    viewSql += string(" FROM ") + sourceDbName + ".RefSpectra";
    sql_stmt(viewSql.c_str());
}

/**
 * Check if the incoming library contains the given table name.
 * \returns True if table exists or false if it does not.
 */
bool BlibMaker::tableExists(const char* schemaTmp, const char* tableName){
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "SELECT name FROM %s.sqlite_master WHERE name = \"%s\"",
            schemaTmp, tableName);
    smart_stmt pStmt;
    int return_code = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
    check_rc(return_code, zSql, "Failed checking for the existance of a table");
    return_code = sqlite3_step(pStmt);
    // if a row exists, the table exists
    return ( return_code == SQLITE_ROW );
}

/**
 * Check if the given table in the incoming library contains the given
 * column name.
 * \returns True if the column exists or false if it does not.
 */
bool BlibMaker::tableColumnExists(const char* schemaTmp, 
                                  const char* tableName, 
                                  const char* columnName){
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "PRAGMA %s.table_info(%s)",
            schemaTmp, tableName);
    smart_stmt pStmt;
    int return_code = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
    check_rc(return_code, zSql, "Failed checking for existance of a column");
    return_code = sqlite3_step(pStmt);

    while(return_code == SQLITE_ROW){
        string cur_col = 
            reinterpret_cast<const char*>(sqlite3_column_text(pStmt,1));
        if( cur_col.compare(columnName) == 0 ){
            return true;
        }
        return_code = sqlite3_step(pStmt);
    }
    return false;
}

/**
 * Copy all of the spectrum source files from the incoming library to
 * the new library.  Create a map from the old fileID to the new one
 * for future spectrum inserts.
 */
// todo if multiple tmp dbs are attached, make a map for each
// schemaTmp name.  map of maps?  map of vectors?
void BlibMaker::transferSpectrumFiles(const char* schemaTmp){ //i.e. db name

    // first check to see if the incoming library has spectrum source files
    if( ! tableExists(schemaTmp, "SpectrumSourceFiles") ){
        // add "unknown" source file if we haven't already
        if( unknown_file_id == -1 ){
            Verbosity::warn("Orignal library does not contain filenames for "
                            "the  library spectra");
            strncpy(zSql, "INSERT INTO SpectrumSourceFiles (fileName, cutoffScore) "
                "VALUES ('UNKNOWN', -1)",
                ZSQLBUFLEN);
            sql_stmt(zSql); 
            unknown_file_id = (int)sqlite3_last_insert_rowid(db);
        }

        return;
    }

    string cutoffSelect = tableColumnExists(schemaTmp, "SpectrumSourceFiles", "cutoffScore") ? "cutoffScore" : "-1";
    string idFileSelect = tableColumnExists(schemaTmp, "SpectrumSourceFiles", "idFileName") ? "idFileName" : "fileName";
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT id, fileName, %s, %s FROM %s.SpectrumSourceFiles", idFileSelect.c_str(), cutoffSelect.c_str(), schemaTmp);
    smart_stmt pStmt;
    int rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
    check_rc(rc, zSql, "Failed selecting file names from tmp db.");
    rc = sqlite3_step(pStmt);
    while( rc == SQLITE_ROW ){
        // if fileName doesn't exist in main db...
        string fileName(reinterpret_cast<const char*>(sqlite3_column_text(pStmt, 1)));
        string idFileName(reinterpret_cast<const char*>(sqlite3_column_text(pStmt, 2)));
        double cutoff = sqlite3_column_double(pStmt, 3);

        int existingFileId = getFileId(fileName, cutoff);
        if (existingFileId >= 0) {
            oldToNewFileID_[sqlite3_column_int(pStmt, 0)] = existingFileId;
            rc = sqlite3_step(pStmt);
            continue;
        }

        int newFileId = addFile(fileName, cutoff, idFileName);

        // map old id (looked up) to new (current row number)
        oldToNewFileID_[sqlite3_column_int(pStmt, 0)] = newFileId;

        // else oldToNewFileID_[sqlite3_column_int(pStmt, 0)] = id of existing entry
        rc = sqlite3_step(pStmt);
    }
}

void BlibMaker::transferProteins(const char* schemaTmp) {
    // first check to see if the incoming library has spectrum source files
    if (!tableExists(schemaTmp, "Proteins")) {
        return;
    }

    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO main.Proteins (id, accession) SELECT id, accession FROM %s.Proteins", schemaTmp);
    sql_stmt(zSql);
}

/**
 * In preparation for transfering spectra from one library to another,
 * get what will be the fileID for the new library.  Look up the
 * fileID of the given spectrum in the temp library.  From that look
 * up the id of the same file in the new library in the cached map of
 * file IDs.  If not in the cache, add this file to the new library.
 * \returns The fileID field to be used when entering this spectrum in
 * the new library.
 */
int BlibMaker::getNewFileId(const char* libName, int specID){
    // get the fileID in the temp library
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT fileID FROM %s.RefSpectra WHERE id = %d", 
            libName, specID);

    smart_stmt pStmt;
    int rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
    if( ! check_rc(rc, zSql, "", false)) { // false=don't die on failure
        return unknown_file_id; // assume failure b/c fileID doesn't exist
    } // else, find the new id from the old

    rc = sqlite3_step(pStmt);
    int oldFileID = sqlite3_column_int(pStmt, 0);

    int newID = -1;

    // first look for the newID in the map
    map<int,int>::iterator it = oldToNewFileID_.find(oldFileID);
    if( it != oldToNewFileID_.end() ){
        newID = it->second;
    } else {
        // insert it into the new db
        string cutoffSelect = tableColumnExists(libName, "SpectrumSourceFiles", "cutoffScore") ? "cutoffScore" : "-1";
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "INSERT INTO main.SpectrumSourceFiles(fileName, cutoffScore) "
                "SELECT fileName, %s FROM %s.SpectrumSourceFiles "
                "WHERE %s.SpectrumSourceFiles.id = %d",
                cutoffSelect.c_str(), libName, libName, oldFileID);
        sql_stmt(zSql);
        newID = (int)sqlite3_last_insert_rowid(getDb());

        // add it to map
        oldToNewFileID_[oldFileID] = newID;
    }


    return newID;
}

/**
 * Extract a spectrum from the given database name (i.e. schemaTmp) (must
 * currently be attached) and insert it into the default database.
 * \returns ID of spectrum in new table (db into which it was transfered).
 */
int BlibMaker::transferSpectrum(const char* schemaTmp, 
                                int spectraTmpID, 
                                int copies,
                                int tableVersion)
{
    int newFileID = getNewFileId(schemaTmp, spectraTmpID);

    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO RefSpectra(peptideSeq, precursorMZ, precursorCharge, peptideModSeq, prevAA, nextAA, copies, numPeaks, fileID, "
        "ionMobility, collisionalCrossSectionSqA, ionMobilityHighEnergyOffset, ionMobilityType, "
        "moleculeName, chemicalFormula, inchiKey, otherKeys, precursorAdduct, "
        "startTime, endTime, totalIonCurrent, retentionTime, specIDinFile, score, scoreType) "

        "SELECT peptideSeq, precursorMZ, precursorCharge, peptideModSeq, prevAA, nextAA, %d, numPeaks, %d, "
        "ionMobility, collisionalCrossSectionSqA, ionMobilityHighEnergyOffset, ionMobilityType, "
        "moleculeName, chemicalFormula, inchiKey, otherKeys, precursorAdduct, "
        "startTime, endTime, totalIonCurrent, retentionTime, specIDinFile, score, scoreType "
        "FROM RefSpectraTransfer WHERE id = %d",
        copies, newFileID, spectraTmpID);
    sql_stmt(zSql);

    int spectraID = (int)sqlite3_last_insert_rowid(getDb());

    transferPeaks(schemaTmp, spectraID, spectraTmpID);
    transferModifications(schemaTmp, spectraID, spectraTmpID);
    if (tableVersion >= MIN_VERSION_PEAK_ANNOT) {
        transferPeakAnnotations(schemaTmp, spectraID, spectraTmpID);
    }
    if (tableVersion >= MIN_VERSION_PROTEINS) {
        transferRefSpectraProteins(schemaTmp, spectraID, spectraTmpID);
    }
    return spectraID;
}

int BlibMaker::transferSpectra(const char* schemaTmp,
                               vector<pair<int, int>>& bestSpectraIdAndCount,
                               int tableVersion)
{
    // create temp table for copies column
    sql_stmt("CREATE TEMP TABLE TempSpectrumCopies (Id INTEGER PRIMARY KEY, copies INT)");
    const char* insertSpectrumCopy = "INSERT INTO TempSpectrumCopies VALUES (?,?)";
    sqlite3_stmt* insertSpectrumCopyStmt;
    sqlite3_prepare(getDb(), insertSpectrumCopy, -1, &insertSpectrumCopyStmt, NULL);
    for (const auto& idCopiesPair : bestSpectraIdAndCount)
    {
        sqlite3_bind_int(insertSpectrumCopyStmt, 1, idCopiesPair.first);
        sqlite3_bind_int(insertSpectrumCopyStmt, 2, idCopiesPair.second);
        if (sqlite3_step(insertSpectrumCopyStmt) != SQLITE_DONE)
            throw BlibException(false, "Error inserting row into TempSpectrumCopies: %s", sqlite3_errmsg(getDb()));
        else if (sqlite3_reset(insertSpectrumCopyStmt) != SQLITE_OK)
            throw BlibException(false, "Error resetting insert TempSpectrumCopies: %s", sqlite3_errmsg(getDb()));
    }
    sqlite3_finalize(insertSpectrumCopyStmt);

    // transfer spectra from source db to filtered db

    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO RefSpectra(id, peptideSeq, precursorMZ, precursorCharge, "
        "peptideModSeq, prevAA, nextAA, copies, numPeaks, fileID, "
        "ionMobility, collisionalCrossSectionSqA, ionMobilityHighEnergyOffset, ionMobilityType, "
        "moleculeName, chemicalFormula, inchiKey, otherKeys, precursorAdduct, "
        "startTime, endTime, totalIonCurrent, retentionTime, specIDinFile, score, scoreType) "

        "SELECT ref.id, peptideSeq, precursorMZ, precursorCharge, "
        "peptideModSeq, prevAA, nextAA, tmp.copies, numPeaks, fileID, "
        "ionMobility, collisionalCrossSectionSqA, ionMobilityHighEnergyOffset, ionMobilityType, "
        "moleculeName, chemicalFormula, inchiKey, otherKeys, precursorAdduct, "
        "startTime, endTime, totalIonCurrent, retentionTime, specIDinFile, score, scoreType "
        "FROM RefSpectraTransfer ref "
        "JOIN TempSpectrumCopies tmp ON ref.id=tmp.id "
        "GROUP BY ref.id");
    sql_stmt(zSql);

    // transfer peaks
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO RefSpectraPeaks(RefSpectraID,peakMZ,peakIntensity) "
        "SELECT RefSpectraID, peakMZ, peakIntensity "
        "FROM %s.RefSpectraPeaks peaks "
        "WHERE peaks.RefSpectraID IN (SELECT id FROM RefSpectra)", schemaTmp);
    sql_stmt(zSql);

    // transfer modifications
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO Modifications (RefSpectraID, position, mass) "
        "SELECT RefSpectraID, position, mass "
        "FROM %s.Modifications mods "
        "WHERE mods.RefSpectraID IN (SELECT id FROM RefSpectra)", schemaTmp);
    sql_stmt(zSql);

    if (tableVersion >= MIN_VERSION_PEAK_ANNOT) {
        // transfer peak annotations
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "INSERT INTO RefSpectraPeakAnnotations (RefSpectraID, peakIndex, name, formula, inchiKey, otherKeys, charge, adduct, comment, mzTheoretical, mzObserved) "
            "SELECT RefSpectraID, peakIndex, name, formula, ann.inchiKey, ann.otherKeys, charge, adduct, comment, mzTheoretical, mzObserved "
            "FROM %s.RefSpectraPeakAnnotations ann "
            "WHERE ann.RefSpectraID IN (SELECT id FROM RefSpectra)", schemaTmp);
        sql_stmt(zSql);
    }

    if (tableVersion >= MIN_VERSION_PROTEINS) {
        // transfer proteins
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "INSERT INTO RefSpectraProteins (RefSpectraId, ProteinId) "
            "SELECT RefSpectraID, ProteinId "
            "FROM %s.RefSpectraProteins pro "
            "WHERE pro.RefSpectraID IN (SELECT id FROM RefSpectra)", schemaTmp);
        sql_stmt(zSql);
    }

    return 0;
}

void BlibMaker::transferModifications(const char* schemaTmp, 
                                      int spectraID, 
                                      int spectraTmpID)
{
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "SELECT RefSpectraID, position, mass "
            "FROM %s.Modifications "
            "WHERE RefSpectraID=%d "
            "ORDER BY id", schemaTmp, spectraTmpID);
    smart_stmt pStmt;
    int rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);

    check_rc(rc, zSql, "Failed getting modifications.");

    rc = sqlite3_step(pStmt);

    while(rc==SQLITE_ROW) {
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
                "INSERT INTO Modifications(RefSpectraID, position,mass) "
                "VALUES(%d, %d, %f)",
                spectraID,
                sqlite3_column_int(pStmt,1),
                sqlite3_column_double(pStmt,2));
        sql_stmt(zSql);
        
        rc = sqlite3_step(pStmt);
    }
}

void BlibMaker::transferPeaks(const char* schemaTmp, 
                              int spectraID, 
                              int spectraTmpID)
{
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "INSERT INTO RefSpectraPeaks(RefSpectraID,peakMZ,peakIntensity) "
            "SELECT %d, peakMZ, peakIntensity "
            "FROM %s.RefSpectraPeaks "
            "WHERE RefSpectraID=%d", spectraID, schemaTmp, spectraTmpID);
    sql_stmt(zSql);
}

void BlibMaker::transferPeakAnnotations(const char* schemaTmp,
    int spectraID,
    int spectraTmpID)
{
    const char *cols = "RefSpectraID, peakIndex, name, formula, inchiKey, otherKeys, charge, adduct, comment, mzTheoretical, mzObserved";
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "SELECT %s "
        "FROM %s.RefSpectraPeakAnnotations "
        "WHERE RefSpectraID=%d "
        "ORDER BY id", cols, schemaTmp, spectraTmpID);
    smart_stmt pStmt;
    int rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);

    check_rc(rc, zSql, "Failed getting peak annotations.");

    rc = sqlite3_step(pStmt);
    while (rc == SQLITE_ROW) {
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
            "INSERT INTO RefSpectraPeakAnnotations(%s) "
            "VALUES(%d, %s,  %s,  %s, %s, %s, %d, %s,  %s,  %f,  %f)",
            cols,
            spectraID,
            sqlite3_column_int(pStmt, 1),
            sqlite3_column_text(pStmt, 2),
            sqlite3_column_text(pStmt, 3),
            sqlite3_column_text(pStmt, 4),
            sqlite3_column_text(pStmt, 5),
            sqlite3_column_int(pStmt, 6),
            sqlite3_column_text(pStmt, 7),
            sqlite3_column_text(pStmt, 8),
            sqlite3_column_double(pStmt, 9),
            sqlite3_column_double(pStmt, 10));
        sql_stmt(zSql);

        rc = sqlite3_step(pStmt);
    }
}

void BlibMaker::transferRefSpectraProteins(const char* schemaTmp, int spectraID, int spectraTmpID) {
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN,
        "INSERT INTO RefSpectraProteins (RefSpectraId, ProteinId) "
        "SELECT %d, ProteinId FROM %s.RefSpectraProteins WHERE RefSpectraId = %d",
        spectraID, schemaTmp, spectraTmpID);
    sql_stmt(zSql);
}

int BlibMaker::getFileId(const string& file, double cutoffScore) {
    map< string, pair<int, double> >::const_iterator i = fileIdCache_.find(file);
    if (i != fileIdCache_.end()) {
        if (cutoffScore != i->second.second && tableColumnExists("main", "SpectrumSourceFiles", "cutoffScore")) {
            string sql_statement =
                "UPDATE SpectrumSourceFiles SET cutoffScore = -1 WHERE id = " + boost::lexical_cast<string>(i->second.first);
            sql_stmt(sql_statement.c_str());
        }
        return i->second.first;
    }

    string cutoffSelect = tableColumnExists("main", "SpectrumSourceFiles", "cutoffScore") ? "cutoffScore" : "-1";
    string statement = "SELECT id, " + cutoffSelect + " FROM SpectrumSourceFiles WHERE filename = '";
    statement += SqliteRoutine::ESCAPE_APOSTROPHES(file);
    statement += "'";

    int iRow, iCol;
    char** result;
    int returnCode = sqlite3_get_table(getDb(), statement.c_str(), &result, &iRow, &iCol, 0);
    check_rc(returnCode, statement.c_str());
    if (iRow > 0) {
        sqlite3_int64 fileId = atol(result[1]);
        fileIdCache_[file] = make_pair(fileId, atof(result[2]));
        sqlite3_free_table(result);
        return fileId;
    }
    sqlite3_free_table(result);
    return -1;
}

int BlibMaker::addFile(const string& specFile, double cutoffScore, const string& idFile) {
    string sql_statement;
    if (tableColumnExists("main", "SpectrumSourceFiles", "cutoffScore")) {
        sql_statement = "INSERT INTO SpectrumSourceFiles(fileName, idFileName, cutoffScore) VALUES('";
        sql_statement += SqliteRoutine::ESCAPE_APOSTROPHES(specFile);
        sql_statement += "', '" + SqliteRoutine::ESCAPE_APOSTROPHES(idFile);
        sql_statement += "', " + boost::lexical_cast<string>(cutoffScore) + ")";
    } else {
        sql_statement = "INSERT INTO SpectrumSourceFiles(filename, idFileName) VALUES('";
        sql_statement += SqliteRoutine::ESCAPE_APOSTROPHES(specFile);
        sql_statement += "', '" + SqliteRoutine::ESCAPE_APOSTROPHES(idFile);
        sql_statement += "')";
    }
    sql_stmt(sql_statement.c_str());
    int newFileId = sqlite3_last_insert_rowid(getDb());
    fileIdCache_[specFile] = make_pair(newFileId, cutoffScore);
    return newFileId;
}

void BlibMaker::insertPeaks(int spectraID, int levelCompress, int peaksCount, 
                            double* pM, float* pI)
{
    const uLong sizeM = (uLong) peaksCount*sizeof(double);
    const uLong sizeI = (uLong) peaksCount*sizeof(float);

    Byte *comprM, *comprI;
    uLong comprLenM, comprLenI;

    if (levelCompress == 0) {
        // No compression
        comprM = (Byte*)pM;
        comprLenM = sizeM;
        
        comprI = (Byte*)pI;
        comprLenI = sizeI;
    } else {
        // compress mz
        comprLenM = compressBound(sizeM);
        comprM = (Byte*)calloc((uInt)comprLenM, 1);
        int err = compress(comprM, &comprLenM, (const Bytef*)pM, sizeM);
        if (comprLenM >= sizeM) {
            // no mz compression
            free(comprM);
            comprM = (Byte*)pM;
            comprLenM = sizeM;
        }
        
        // compress intensity
        comprLenI = compressBound(sizeI);
        comprI = (Byte*)calloc((uInt)comprLenI, 1);
        err = compress(comprI, &comprLenI, (const Bytef*)pI, sizeI);
        if (comprLenI >= sizeI) {
            // no intensity compression
            free(comprI);
            comprI = (Byte*)pI;
            comprLenI = sizeI;
        }
    }
    
    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "INSERT INTO RefSpectraPeaks VALUES(%d, ?,?)", spectraID);
    
    smart_stmt pStmt;
    int rc = sqlite3_prepare(getDb(), zSql, -1, &pStmt, 0);
    
    check_rc(rc, zSql, "Failed importing peaks.");
    
    sqlite3_bind_blob(pStmt, 1, comprM, (int)comprLenM, SQLITE_STATIC);
    sqlite3_bind_blob(pStmt, 2, comprI, (int)comprLenI, SQLITE_STATIC);
    
    rc = sqlite3_step(pStmt);
    
    if (rc != SQLITE_DONE)
        fail_sql(rc, zSql, NULL, "Failed importing peaks.");
    
    if (comprLenM != sizeM)
        free(comprM);
    if (comprLenI != sizeI)
        free(comprI);
}

void BlibMaker::updateLibInfo()
{
    int dataRev;
    getNextRevision(&dataRev);
    int spectrum_count = countSpectra();

    boost::log::aux::snprintf(zSql, ZSQLBUFLEN, 
            "UPDATE LibInfo SET numSpecs=%d, majorVersion=%d",
            spectrum_count, dataRev);
    sql_stmt(zSql);
}

/**
 * Get the number of spectra in the given database name or in the
 * default database (the one least recently attached).  First tries to 
 * look up the value in the LibInfo table and if it is not available,
 * counts the spectra.
 * \returns The number of spectra in the database.
 */
int BlibMaker::getSpectrumCount(const char* databaseName /* = null */)
{
    // first try getting the count
    if (databaseName != NULL && *databaseName != '\0')
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT numSpecs FROM %s.LibInfo", databaseName);
    else
        strncpy(zSql, "SELECT numSpecs FROM LibInfo", ZSQLBUFLEN);
    smart_stmt pStmt1;
    int rc1 = sqlite3_prepare(getDb(), zSql, -1, &pStmt1, 0);
    int numSpec = -1;

    if( !just_check_step(rc1, pStmt1, zSql, "") ){
        Verbosity::debug("Failed to get spectrum count, so count them.");
    } else {
        numSpec = sqlite3_column_int(pStmt1,0);// table init to -1
    }

    if( numSpec == -1 ){
        numSpec = countSpectra(databaseName);
    }

    return numSpec;
}

/**
 * Query the given database name or the default database (the one
 * least recently attached) for the number of spectra in the
 * RefSpectra table.  Does not check the value in LibInfo.
 * \returns The number of spectra in the database.
 */
int BlibMaker::countSpectra(const char* databaseName /* = NULL */)
{
    if (databaseName != NULL && *databaseName != '\0')
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT count(*) FROM %s.RefSpectra", databaseName);
    else
        strncpy(zSql, "SELECT count(*) FROM RefSpectra", ZSQLBUFLEN);

    Verbosity::debug("About to submit count statement.");
    smart_stmt pStmt;
    int rc = sqlite3_prepare(getDb(), zSql, -1, &pStmt, 0);
    Verbosity::debug("Done counting.");
    check_step(rc, pStmt, zSql, "Failed getting spectrum count.");

    return sqlite3_column_int(pStmt,0);
}

void BlibMaker::getNextRevision(int* dataRev)
{
    int schemaVer;
    getRevisionInfo(NULL, dataRev, &schemaVer);

    // Increment revision by one.
    (*dataRev)++;
}

void BlibMaker::getRevisionInfo(const char* schemaName, int* dataRev, int* schemaVer)
{
    // Due to original omission of a schema version number, and the unused
    // integer values minorVersion, the minorVersion field has been taken
    // for use as a schemaVersion
    if (schemaName == NULL)
        strncpy(zSql, "SELECT majorVersion, minorVersion FROM LibInfo", ZSQLBUFLEN);
    else
        boost::log::aux::snprintf(zSql, ZSQLBUFLEN, "SELECT majorVersion, minorVersion FROM %s.LibInfo", 
                schemaName);

    int iRow, iCol;
    char** result;

    int rc = sqlite3_get_table(db, zSql, &result, &iRow, &iCol, 0);

    check_rc(rc, zSql, message.c_str());

    *dataRev = atoi(result[2]);
    *schemaVer = atoi(result[3]);

    sqlite3_free_table(result);
}

double BlibMaker::getCutoffScore() const {
    return -1;
}

const char* BlibMaker::libIdFromName(const char* name)
{
    const char* slash = max(strrchr(name, '/'), strrchr(name, '\\'));
    if (slash == NULL)
        return name;

    return (slash + 1);
}

void BlibMaker::setLibName(const string& name)
{
    lib_name = name.c_str();
    lib_id = libIdFromName(name.c_str());
}

/**
 * Look at the return code and either die on failure with a detailed
 * message or return false on failure.
 */
bool BlibMaker::check_rc(int rc,             // return code
                         const char* stmt,   // statement attempted
                         const char* msg,    // additional message
                         bool die_on_failure // die or return
                         ) const
{
    if(rc != SQLITE_OK && die_on_failure)
        fail_sql(rc, stmt, NULL, msg);

    return (rc == SQLITE_OK);
}

/**
 * Process and check the statement.  If it was not processed
 * successfully, fail.
 */
void BlibMaker::check_step(int rc, sqlite3_stmt *pStmt, 
                           const char* stmt, const char* msg) const
{
    check_rc(rc, stmt, msg);
    if (sqlite3_step(pStmt) != SQLITE_ROW)
        fail_sql(rc, stmt, NULL, msg);
}

/**
 * Process and check the statement, but just return the value, don't
 * fail.
 */
bool BlibMaker::just_check_step(int rc, sqlite3_stmt *pStmt, 
                           const char* stmt, const char* msg) const
{
    check_rc(rc, stmt, msg);
    if (sqlite3_step(pStmt) != SQLITE_ROW)
        return false;
    else 
        return true;
}

/**
 * Execute the given SQL statement and check the return code.  If
 * ignoreFailure is true, return regardless of outcome.  Otherwise,
 * if an error was encountered, exit with a detailed message.  Use for
 * statements for which you do not need the results (i.e. not SELECT
 * statements). 
 */
void BlibMaker::sql_stmt(const char* stmt, bool ignoreFailure) const
{
    char *err = NULL;
    int rc = sqlite3_exec(db, stmt, 0, 0, &err);

    if (!ignoreFailure && rc != SQLITE_OK)
        fail_sql(rc, stmt, err);
}

/**
 * Exit after printing a detailed message about the return code, the
 * statment that generated the error and any additional message passed
 * by the caller.
 */
void BlibMaker::fail_sql(int rc,                // sqlite return code
                         const char* stmt,      // sql statement attempted
                         const char* err,       // sqlite generated error
                         const char* msg) const // additional message
{
    const char* first_msg = (msg == NULL? "SQL failure. " : msg);
    const char* sql_msg = (err == NULL? " " : err);

    Verbosity::error("%s %s [SQL statement '%s', return code %d]", 
                     first_msg, sql_msg, stmt, rc);
}

} // namespace

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * End:
 */
