//
// $Id$
//
//
// Original author: Jarrett Egertson <jegertso    uw  edu>
//
// Copyright 2012 University of Washington - Seattle, WA 98195
//
// Licensed under the Apache License, Version 2.0 (the "License"); 
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License.
//

#include "BlibUtils.h"
#include "SQTversion.h"
#include <typeinfo>
#include "pwiz/utility/misc/Std.hpp"

namespace bxp = boost::xpressive;

namespace BiblioSpec {

SequestVersion::SequestVersion()
    : _majorVersion(0), _minorVersion(0)
{
    _versionParser = bxp::sregex::compile("^(?P<major>[0-9]+)([.](?P<minor>[0-9]+))?[[:blank:]]*$");
}

SequestVersion::SequestVersion(string versionString)
    : _majorVersion(0), _minorVersion(0)
{
    _versionParser = bxp::sregex::compile("^(?P<major>[0-9]+)([.](?P<minor>[0-9]+))?[[:blank:]]*$");

    if (!trySetVersion(versionString))
        throw BlibException(false, "Error initializing with an improperly formatted sequest version string: %s", versionString.c_str());
}

bool SequestVersion::trySetVersion(string versionString)
{
    if (versionString.length() <= 0)
    {
        return false;
    }
    // try getting the major and minor versions using the regex
    string::const_iterator start, end;
    start = versionString.begin();
    end = versionString.end();
    bxp::smatch match;
    if (!bxp::regex_search(start, end, match, _versionParser))
    {
        return false;
    }
    _majorVersion = _minorVersion = 0;
    if (match["major"].length() > 0)
    {
        _majorVersion = atoi(match["major"].str().c_str());
    }
    if (match["minor"].length() > 0)
    {
        _minorVersion = atoi(match["minor"].str().c_str());
    }
    return true;
}

bool SequestVersion::operator< (const SQTversion& rhs) const
{
   if(typeid(rhs) != typeid(*this))
   {
        throw BlibException(false, "Tried to compare an SQT version between a file generated from sequest, and a file"
           "generated by a different software");
   }
   const SequestVersion& rhsComp = static_cast<const SequestVersion&>(rhs);
   if (_majorVersion == rhsComp._majorVersion)
        return _minorVersion < rhsComp._minorVersion;
   return _majorVersion < rhsComp._majorVersion;
}

bool SequestVersion::operator== (const SQTversion& rhs) const
{
   if(typeid(rhs) != typeid(*this))
   {
        throw BlibException(false, "Tried to compare an SQT version between a file generated from sequest, and a file"
           "generated by a different software");
   }
   const SequestVersion& rhsComp = static_cast<const SequestVersion&>(rhs);
   return _majorVersion == rhsComp._majorVersion && _minorVersion == rhsComp._minorVersion;
}

CometVersion::CometVersion()
: _majorVersion(0), _minorVersion(0), _revision(0)
{
    _versionParser = bxp::sregex::compile("^(?P<major>[0-9]+)([.](?P<minor>[0-9]+))?[[:blank:]]*(rev[.][[:blank:]]*(?P<rev>[0-9]+)?)?[[:blank:]]*$");
}

CometVersion::CometVersion(string versionString)
: _majorVersion(0), _minorVersion(0), _revision(0)
{
    _versionParser = bxp::sregex::compile("^(?P<major>[0-9]+)([.](?P<minor>[0-9]+))?[[:blank:]]*(rev[.][[:blank:]]*(?P<rev>[0-9]+)?)?[[:blank:]]*$");

    if (!trySetVersion(versionString))
        throw BlibException(false, "Error initializing with an improperly formatted comet version string: %s", versionString.c_str());
}

bool CometVersion::trySetVersion(string versionString)
{
    if (versionString.length() <= 0)
    {
        return false;
    }
    // try getting the major, minor and revision versions using the regex
    string::const_iterator start, end;
    start = versionString.begin();
    end = versionString.end();
    bxp::smatch match;
    if (!bxp::regex_search(start, end, match, _versionParser))
    {
        return false;
    }
    _majorVersion = _minorVersion = _revision = 0;
    if (match["major"].length() > 0)
    {
        _majorVersion = atoi(match["major"].str().c_str());
    }
    if (match["minor"].length() > 0)
    {
        _minorVersion = atoi(match["minor"].str().c_str());
    }
    if (match["rev"].length() > 0)
    {
        _revision = atoi(match["rev"].str().c_str());
    }
    return true;
}

bool CometVersion::operator< (const SQTversion& rhs) const
{
   if(typeid(rhs) != typeid(*this))
   {
        throw BlibException(false, "Tried to compare an SQT version between a file generated from comet, and a file"
           "generated by a different software");
   }
   const CometVersion& rhsComp = static_cast<const CometVersion&>(rhs);
   if (_majorVersion == rhsComp._majorVersion)
   {
       if (_minorVersion == rhsComp._minorVersion)
           return _revision < rhsComp._revision;
       return _minorVersion < rhsComp._minorVersion;
   }
   return _majorVersion < rhsComp._majorVersion;
}

bool CometVersion::operator== (const SQTversion& rhs) const
{
   if(typeid(rhs) != typeid(*this))
   {
        throw BlibException(false, "Tried to compare an SQT version between a file generated from comet, and a file"
           "generated by a different software");
   }
   const CometVersion& rhsComp = static_cast<const CometVersion&>(rhs);
   return _majorVersion == rhsComp._majorVersion 
       && _minorVersion == rhsComp._minorVersion
       && _revision == rhsComp._revision;
}
}   // namespace
