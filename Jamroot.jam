#
# $Id$
#
#
# Original author: Darren Kessner <darren@proteowizard.org>
#
# Copyright 2008 Spielberg Family Center for Applied Proteomics
#   Cedars-Sinai Medical Center, Los Angeles, California  90048
#
# Licensed under the Apache License, Version 2.0 (the "License"); 
# you may not use this file except in compliance with the License. 
# You may obtain a copy of the License at 
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software 
# distributed under the License is distributed on an "AS IS" BASIS, 
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
# See the License for the specific language governing permissions and 
# limitations under the License.

if ( "--help" in [ modules.peek : ARGV ] ) 
{      # slip our own help text in here
ECHO 
################################
## Targets and Related Options #
################################
#   build                   Build ProteoWizard applications
#   =====
#   --libraries-path=<DIR>  Find libraries directory here.
#                           Default: "./libraries"
#
#   --boost-src=<DIR>       Find Boost source distribution here.
#                           Default: "<libraries-path>/boost_*"
#
#   --zlib-src=<DIR>        Find zlib source distribution here.
#                           Default: "<libraries-path>/zlib-1.23.0"
#
#   --i-agree-to-the-vendor-licenses  For windows builds, indicates
#                                     your willingness to comply with
#                                     license terms of the vendor DLLs
#                                     that enable reading of proprietary
#                                     binary data formats.  Without this 
#                                     switch your build will not include
#                                     support for reading vendor binary 
#                                     files.
#
#   --incremental           Skip the checks for extracting external library
#                           tarballs - useful after your initial build
#
#   --without-mz5           Build without mz5 support
#   --without-agilent       Build without Agilent support
#   --without-bruker        Build without Bruker support
#   --without-sciex         Build without Sciex support
#   --without-shimadzu      Build without Shimadzu support
#   --without-thermo        Build without Thermo support
#   --without-waters        Build without Waters support
#
#   --without-binary-msdata Build with support for mass spec text formats only
#                           (mzML, mzXML, MGF, etc - no binary formats
#                           like mz5 or vendor-specifics )
#
#   There are some aliases to build commonly used subsets of pwiz:
#
#   msconvert (just the command-line executable, copied to <BUILD_DIR>/<TOOLSET_DIR>)
#   executables (all the pwiz core tools, copied to <BUILD_DIR>/<TOOLSET_DIR>)
#
#   If you just want to build a specific subset of pwiz, add a target to 
# your command line.  For example to build just the msdata file 
# read/write stuff, add:
#
#   pwiz/data/msdata
#
#   Or to build a particular item of that subset, such as a test,
# you could add (note the double slashes!) :
#
#   pwiz/data/msdata//MSDataFileTest
#
; # end of our own help text
}

import errors ;

.os = [ modules.peek : OS ] ; # NT, LINUX, MACOSX
.platform = [ modules.peek : OSPLAT ] ; # X86, X86_64, POWERPC

# set up explicit 32-bit or 64-bit builds
if "address-model=64" in [ modules.peek : ARGV ]
{
    constant PROCESSOR_ARCHITECTURE : "AMD64" ;
    constant PLATFORM : "x64" ;
    if "address-model=32" in [ modules.peek : ARGV ] { errors.user-error "Pick either address-model=32 or address-model=64, not both." ; }
}
else if "address-model=32" in [ modules.peek : ARGV ]
{
    constant PROCESSOR_ARCHITECTURE : "x86" ;
    constant PLATFORM : "x86" ;
    if "address-model=64" in [ modules.peek : ARGV ] { errors.user-error "Pick either address-model=32 or address-model=64, not both." ; }
}
else if [ modules.peek : NT ] # require address-model to be specified on Windows
{
    errors.user-error "No address-model specified. Command-line must specify address-model=32 or address-model=64 (because B2 apparently changed the default MSVC address-model, breaking many pwiz assumptions)." ;
}

local default_libraries_path = "./libraries" ;
local libraries_path = [ MATCH --libraries-path=(.*) : [ modules.peek : ARGV ] ] ;
libraries_path ?= $(default_libraries_path) ; # set default path in absence of command-line path

local default_boost_src = "$(libraries_path)/boost_1_76_0" ;
local boost_src = [ MATCH --boost-src=(.*) : [ modules.peek : ARGV ] ] ;
boost_src ?= $(default_boost_src) ; # set default path in absence of command-line path

local default_zlib_src = "$(libraries_path)/zlib-1.2.3" ;
local zlib_src = [ MATCH --zlib-src=(.*) : [ modules.peek : ARGV ] ] ;
zlib_src ?= $(default_zlib_src) ; # set default path in absence of command-line path


# TODO: get version from boost/version.hpp
import regex ;
local boost_version_suffix = [ MATCH "boost_(._..(_.)?)" : $(boost_src:L) ] ;
if ! $(boost_version_suffix) { errors.user-error "Unable to determine version from external Boost source; expected x_xx[_xx] format." ; }
constant BOOST_VERSION : [ regex.split $(boost_version_suffix[1]) _ ] ;


import path ;
import feature ;

# declare a feature indicating vendor API support is desired (but not necessarily possible on the current platform)
if [ modules.peek : NT ] && --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ]
{
    feature.feature vendor-api-support : on off : incidental propagated ; # on is the default
}
else
{
    feature.feature vendor-api-support : off on : incidental propagated ; # off is the default
}

rule vendor-api-support ( properties * )
{
    if [ modules.peek : NT ] && --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ]
    {
        return <vendor-api-support>on ;
    }
    else
    {
        return <vendor-api-support>off ;
    }
}


if ( "--without-binary-msdata" in  [ modules.peek : ARGV ] ) # support only text formats like mzML, mzXML, MGF etc
{
    echo "NOTICE: building without support for binary msdata formats as requested" ;
}
else if ( "--without-mz5" in  [ modules.peek : ARGV ] )
{
    echo "NOTICE: building without mz5 support as requested" ;
}

# do we want to skip mz5 support?
rule without-mz5 ( properties * )
{
   if --without-mz5 in [ modules.peek : ARGV ]
   {
       return <location-prefix>without-mz5 <define>WITHOUT_MZ5 ;
   }
   else 
   {
       return [ without-binary-msdata $(properties) ] ;
   }
}

# do we want to skip all binary file formats (vendors and mz5)?
rule without-binary-msdata ( properties * )
{
   if --without-binary-msdata in [ modules.peek : ARGV ]
   {
       return <location-prefix>without-binary-msdata <define>WITHOUT_MZ5 <vendor-api-support>off ;
   }
}

local default_build_path = [ MATCH --build-path=(.*) : [ modules.peek : ARGV ] ] ;
if $(default_build_path)
{
    path-constant PWIZ_BUILD_PATH : $(default_build_path) ;
}
else if [ modules.peek : NT ]
{
    path-constant PWIZ_BUILD_PATH : build-nt-x86 ; # force x86 since .NET projects assume that location
}
else
{
    path-constant PWIZ_BUILD_PATH : build-$(.os:L)-$(.platform:L) ;
}

path-constant PWIZ_ROOT_PATH : . ;
path-constant PWIZ_LIBRARIES_PATH : $(libraries_path) ;


import testing ; # needed to enable unit-test rule
import package ; # needed for package install
import path ; # needed for glob, exists, etc.
import project ; # needed for project.current
import errors ;

modules.poke : BOOST_BUILD_PATH : [ modules.peek : BOOST_BUILD_PATH ] $(PWIZ_LIBRARIES_PATH)/predef/check ;
import $(PWIZ_LIBRARIES_PATH)/predef/check/predef : require check : predef-require predef-check ;


if --teamcity-test-decoration in [ modules.peek : ARGV ]
{
    if [ modules.peek : NT ]
    {
        TEST_PRECOMMAND = "set pp=##\necho %pp%teamcity[testStarted name='%name%']" ;
        TEST_POSTCOMMAND =
            "set pp=##\n"
            "IF %status% NEQ 0"
                "(echo %pp%teamcity[testFailed name='%name%' message='Exit status: %status%'] )\n" # TODO: does testFailed go to stderr? 1>&2
            "echo %pp%teamcity[testFinished name='%name%']" ;
        TEST_POSTCOMMAND = $(TEST_POSTCOMMAND:J=" ") ;
    }
    else
    {
        TEST_PRECOMMAND = "pp=##\necho $pp\"teamcity[testStarted name='$name']\"" ;
        TEST_POSTCOMMAND = 
            "pp=##"
            "if test $status -ne 0 ; then"
                "echo $pp\"teamcity[testFailed name='$name' message='Exit status: $status']\" ;"
            "fi"
            "echo $pp\"teamcity[testFinished name='$name']\"" ;
        TEST_POSTCOMMAND = $(TEST_POSTCOMMAND:J=\n) ;
    }
    
    # put raw commands in global module
    modules.poke : TEST_PRECOMMAND : $(TEST_PRECOMMAND) ;
    modules.poke : TEST_POSTCOMMAND : $(TEST_POSTCOMMAND) ;

    TEAMCITY_TEST_DECORATION = <testing.arg>--teamcity-test-decoration ;
}


# return the itemname if textonly build is off (the default)
rule binary-readers-build ( itemname )  
{
    if ( ! [ without-binary-msdata ] )
    {
        return $(itemname) ; # do build binary readers
    }
}


# return the itemname if mz5 build is on (the default)
rule mz5-build ( itemname )  
{
    if ( ! [ without-mz5 ] )
    {
        return $(itemname) ; # do build mz5
    }
}


if ! [ modules.peek : NT ]
{
    # make msbuild targets a no-op
    rule msbuild ( name : sources * : requirements * : default-build * : usage-requirements * )
    {
    }

    PREDEF_CHECKS = 
    # starting with gcc 4.8, gcc is extremely verbose about unused typedefs; heavily used in Boost concept checks
    [ predef-check "BOOST_COMP_GNUC >= 4.8" : : <cxxflags>-Wno-unused-local-typedefs ]

    # starting with gcc 4.9, gcc offers colored diagnostic messages, helpful when looking for an elusive "error" message in a sea of warning spam
    [ predef-check "BOOST_COMP_GNUC >= 4.9" : : <cxxflags>-fdiagnostics-color=always ]
    ;
}
else
{
    # SEH exceptions crossing native/managed boundaries are problematic with this set to off;
    # also, catch(...) will catch SEH exceptions with this on
    DEFAULT_ASYNCH_EXCEPTIONS = <asynch-exceptions>on ;
}


project pwiz 
    : requirements 
        <include>$(PWIZ_ROOT_PATH)
        <include>$(PWIZ_LIBRARIES_PATH)/boost_aux
        <include>$(boost_src)
        <include>$(zlib_src)

        <toolset>gcc,<link>shared:<runtime-link>shared
        <toolset>darwin:<runtime-link>shared

        # any module which links with .NET (either dynamically or statically) must use the shared runtime
        <toolset>msvc:<runtime-link>shared

        # avoid deprecation warnings
        <define>BOOST_NO_AUTO_PTR
        <define>BOOST_BIND_GLOBAL_PLACEHOLDERS

        <define>BOOST_REGEX_MATCH_EXTRA                 # enable access to all captures

        # special msvc hacks
        <toolset>msvc:<define>WIN32                     # windows
        <toolset>msvc:<define>_CRT_SECURE_NO_DEPRECATE  # don't deprecate the standard library 
        <toolset>msvc:<define>_SCL_SECURE_NO_DEPRECATE  # don't deprecate the standard library 
        <toolset>msvc:<define>_USE_MATH_DEFINES         # for M_PI in <cmath>
        <toolset>msvc:<define>BOOST_ALL_NO_LIB          # disable auto-link
        <toolset>msvc:<cxxflags>/wd4100                 # warning: unreferenced formal parameter
        <toolset>msvc:<cxxflags>/wd4512                 # warning: assignment operator could not be generated
        <toolset>msvc:<cxxflags>/wd4127                 # warning: conditional expression is constant (boost::lexical_cast)
        <toolset>msvc:<cxxflags>/wd4701                 # warning: potentially uninitialized local variable 'result' used (boost::lexical_cast, debug)
        <toolset>msvc:<cxxflags>/wd4245                 # warning: conversion from 'type1' to 'type2', signed/unsigned mismatch (boost/filesystem/convenience.hpp)
        <toolset>msvc:<cxxflags>/wd4251                 # warning: class needs to have dll-interface to be used by clients of class
        <toolset>msvc:<cxxflags>/wd4267                 # warning: conversion from 'type1' to 'type2', possible loss of data (boost::lexical_cast)
        <toolset>msvc:<cxxflags>/wd4244                 # warning: conversion from 'int' to 'unsigned short', possible loss of data (boost/date_time/microsec_time_clock.hpp)
        <toolset>msvc:<cxxflags>/wd4275                 # warning: non dll-interface class 'base' used as base for dll-interface class 'derived'
        <toolset>msvc:<cxxflags>/wd4702                 # warning: unreachable code (boost::lexical_cast)
        <toolset>msvc:<cxxflags>/wd4714                 # warning: marked as __forceinline not inlined (boost::spirit::karma::sequence)
        <toolset>msvc:<cxxflags>/wd4456                 # warning: declaration of 'type' hides previous local declaration
        <toolset>msvc:<cxxflags>/wd4459                 # warning: declaration of 'type' hides global declaration
        <toolset>msvc:<cxxflags>/wd4458                 # warning: declaration of 'type' hides class member
        <toolset>msvc,<debug-symbols>off:<linkflags>"/OPT:REF,ICF"
        <toolset>msvc,<toolset-msvc:version>12.0:<define>_HAS_TR1
        <toolset>msvc,<toolset-msvc:version>14.0:<define>_HAS_TR1
        <toolset>msvc,<toolset-msvc:version>14.1:<define>_HAS_TR1
        <toolset>msvc,<toolset-msvc:version>14.2:<define>_HAS_TR1
        <toolset>msvc,<toolset-msvc:version>14.3:<define>_HAS_TR1

        # link-time optimization for release builds
        #<variant>release:<lto>on

        # target Windows 7 or later
        <toolset>msvc:<define>_WIN32_WINNT=_WIN32_WINNT_WIN7
        <toolset>msvc:<define>NTDDI_VERSION=NTDDI_WIN7
        
        <conditional>@secure-scl-throws

        # TODO: figure out a way to only apply this to 3rd party headers
        #<toolset>gcc:<cxxflags>-Wno-uninitialized       # warning: '__cur' might be used uninitialized in this function 

        <toolset>gcc:<define>_DEFAULT_SOURCE
        <toolset>clang:<define>_DEFAULT_SOURCE

        # msparser uses old libstd++ API, so with GCC 5+, the entire project has to use it as well
        <toolset>gcc:<define>_GLIBCXX_USE_CXX11_ABI=0

        # set standard to C++14
        <toolset>gcc:<cxxflags>-std=c++14
        <toolset>darwin:<cxxflags>-std=c++14
        <toolset>clang:<cxxflags>-std=c++14

        # prevent warning about _BSD_SOURCE deprecation
        <toolset>gcc:<define>_DEFAULT_SOURCE

        # disable "warning: suggest parentheses around '&&' within '||'"
        <toolset>gcc:<cxxflags>-Wno-parentheses
        <toolset>clang:<cxxflags>-Wno-parentheses
        <toolset>darwin:<cxxflags>-Wno-parentheses

        # avoid warnings like concept_check.hpp ... warning: unused typedef 'boost_concept_check'
        <toolset>clang:<cxxflags>-Wno-unused-local-typedef
        <toolset>darwin:<cxxflags>-Wno-unused-local-typedef

        # avoid unused parameter warnings (especially annoying for stub functions)
        <toolset>clang:<cxxflags>-Wunused-parameter

        # avoid C++1x deprecation warnings
        <toolset>gcc:<cxxflags>-Wno-deprecated-declarations
        <toolset>clang:<cxxflags>-Wno-deprecated-declarations

        # allow MSVC region pragmas
        <toolset>gcc:<cxxflags>-Wno-unknown-pragmas
        <toolset>clang:<cxxflags>-Wno-unknown-pragmas
        <toolset>darwin:<cxxflags>-Wno-unknown-pragmas

        $(PREDEF_CHECKS)
        
        # special Cygwin gcc-3.4.4 hack
        # linker "multiple definition" error on inclusion of boost-1.34.1 filesystem headers  
        <toolset>gcc-3.4.4:<linkflags>-Wl,--allow-multiple-definition
        <toolset>gcc-mingw-3.4.5:<linkflags>-Wl,--allow-multiple-definition
        <toolset-gcc:flavor>mingw:<linkflags>-Wl,--allow-multiple-definition

        # allow "long long" even with -pedantic
        <toolset>gcc:<cxxflags>-Wno-long-long
        <toolset>darwin:<cxxflags>-Wno-long-long

        # any GCC executable that uses shared libraries must have all its code built with -fPIC
        <conditional>@static-with-fpic
        
        # mz5 support?
        <conditional>@without-mz5 
        
        # msdata text only?
        <conditional>@without-binary-msdata 

        # don't call 'strip' -- causes 'Bus error' in some cases
        #  e.g. find_if with inline predicate
        <toolset>darwin:<debug-symbols>on
        
        # use of boost::thread requires multithreaded runtime
        <threading>multi

        # change boost debug assertions to exceptions by force including Exception.hpp
        <variant>debug,<toolset>msvc:<cxxflags>/FIpwiz/utility/misc/Exception.hpp
        <variant>debug,<toolset>gcc:<cxxflags>"-include pwiz/utility/misc/Exception.hpp"
        <variant>debug,<toolset>darwin:<cxxflags>"-include pwiz/utility/misc/Exception.hpp"

        <conditional>@msvc-runtime-dlls

        $(TEAMCITY_TEST_DECORATION)

    : build-dir $(PWIZ_BUILD_PATH)
    : usage-requirements
        <include>.
    : default-build
        release
        <link>static
        <runtime-link>static
        #<warnings-as-errors>on
        <warnings>all
        <threading>multi
        <response-file>file               # auto-detection of max command-line length broken on Windows Server?
        $(DEFAULT_ASYNCH_EXCEPTIONS)
    ;


# external library declarations

lib pthread 
    : # sources
    : # requirements
        <name>pthread  
        <link>shared
        <toolset>gcc:<linkflags>-pthread # sometimes segfault without this -- dk
    : # default-build
    : # usage-requirements
        <toolset>gcc:<linkflags>-pthread # sometimes segfault without this -- dk
    ;

lib fftw3 : : <threading>multi <search>$(PWIZ_LIBRARIES_PATH)/fftw-3.1.2/.libs : : <include>$(PWIZ_LIBRARIES_PATH)/fftw-3.1.2/api ;
lib fftw3 : : <threading>multi <toolset>msvc <name>libfftw3-3 <search>$(PWIZ_LIBRARIES_PATH) : : <include>$(PWIZ_LIBRARIES_PATH)/fftw-3.1.2/api ;

alias svm : $(PWIZ_LIBRARIES_PATH)/libsvm-3.0//svm ;

modules.poke : BOOST_BUILD_PATH : [ modules.peek : BOOST_BUILD_PATH ] $(PWIZ_LIBRARIES_PATH) ;

import numbers ;

rule is_leap_year ( year )
{
    if [ CALC $(year) % 100 ] = 0
    {
        if [ CALC $(year) % 400 ] = 0 { return 1 ; }
        else { return 0 ; }
    }
    else
    {
        if [ CALC $(year) % 4 ] = 0 { return 1 ; }
        else { return 0 ; }
    }
}

# given year, month, day return day of year
# Astronomical Algorithms, Jean Meeus, 2d ed, 1998, chap 7
rule day_of_year ( Y M D )
{
    local K ;
    if [ is_leap_year $(Y) ] = 1 { K = 1 ; }
    else { K = 2 ; }
    local a = [ CALC 275 * $(M) ] ;
    local b = [ CALC $(M) + 9 ] ;
    local c = [ CALC $(b) / 12 ] ;
    local d = [ CALC $(K) * $(c) ] ;
    local e = [ CALC $(a) / 9 ] ;
    local f = [ CALC $(e) - $(d) ] ;
    local g = [ CALC $(f) + $(D) ] ;
    local N = [ CALC $(g) - 30 ] ;
    if [ numbers.less $(N) 10 ]
    {
        N = "00" $(N) ;
        return $(N:J=) ;
    }
    else if [ numbers.less $(N) 100 ]
    {
        N = "0" $(N) ;
        return $(N:J=) ;
    }
    else
    {
        return $(N) ;
    }
}

# YMMDD in UTC where Y is number of years since 2016, optionally suffixed with HH (hour)
rule MAKE_BUILD_TIMESTAMP ( )
{
    local utc = [ modules.peek : JAMDATE ] ;
    local ymd = [ MATCH "([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])" : $(utc) ] ;
    local d = [ MATCH "[0-9][0-9]([0-9][0-9])" : $(ymd[0]) ] [ day_of_year $(ymd) ] ;
    return $(d:J=) ;
}

local rev = [ MATCH "([a-f0-9]*)" : [ SHELL "git rev-parse --short HEAD" ] ] ;
local branch = [ MATCH "\\* ([^\r\n]*)" : [ SHELL "git branch" ] ] ;
local args = [ modules.peek : ARGV ] ;

constant PWIZ_MAJOR : 3 ;
constant PWIZ_MINOR : 0 ;
constant PWIZ_BUILD_TIMESTAMP : [ MAKE_BUILD_TIMESTAMP ] ;
constant PWIZ_GIT_REV : $(rev:E=0) ;
constant PWIZ_GIT_BRANCH : $(branch:E=master) ;

numeric-version-tag = $(PWIZ_MAJOR) $(PWIZ_MINOR) $(PWIZ_BUILD_TIMESTAMP) ;
version-tag = $(numeric-version-tag) $(PWIZ_GIT_REV) ;

constant PWIZ_NUMERIC_VERSION_TAG : $(numeric-version-tag:J=.) ;
constant PWIZ_VERSION_TAG : $(version-tag:J=.) ;

echo ProteoWizard $(version-tag:J=.) $(PWIZ_GIT_BRANCH) $(PLATFORM) $(PROCESSOR_ARCHITECTURE) $(.os) ;

import generate-version ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/data/msdata/Version.cpp : pwiz msdata : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/analysis/Version.cpp : pwiz analysis : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/data/identdata/Version.cpp : pwiz identdata : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/data/tradata/Version.cpp : pwiz tradata : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/data/proteome/Version.cpp : pwiz proteome : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;
generate-version.cpp $(PWIZ_ROOT_PATH)/pwiz/Version.cpp : pwiz : $(PWIZ_MAJOR) : $(PWIZ_MINOR) : $(PWIZ_BUILD_TIMESTAMP) : $(PWIZ_GIT_REV) : $(PWIZ_GIT_BRANCH) ;

# create a VERSION file which can be used by TC to parse the canonical pwiz version
make VERSION : : @make_VERSION : <location>$(PWIZ_BUILD_PATH) ;
actions make_VERSION { @($(STDOUT):E=$(version-tag:]=.)) > "$(<)" }
#actions make_VERSION { @($(STDOUT):E=$(version-tag:]=.)) > "$(<)" ; @($(STDOUT):E=<version>$(version-tag:J=.)</version>) > "$(PWIZ_BUILD_PATH)/VERSION.xml" }

import tar ;
using tar ;

if ! [ without-mz5 ]
{
    tar.extract $(PWIZ_LIBRARIES_PATH)/hdf5-1.8.7.tar.bz2 : *.c* *.h* *.jam *.settings : <location>$(PWIZ_LIBRARIES_PATH) ;
}

path-constant BOOST_SOURCE : $(boost_src) ;
path-constant ZLIB_SOURCE : $(zlib_src) ;
path-constant GD_SOURCE : $(PWIZ_LIBRARIES_PATH)/libgd-2.1.0alpha ;
path-constant PNG_SOURCE : $(PWIZ_LIBRARIES_PATH)/libpng-1.5.6 ;
path-constant FREETYPE_SOURCE : $(PWIZ_LIBRARIES_PATH)/freetype-2.4.7 ;
path-constant EXPAT_SOURCE : $(PWIZ_LIBRARIES_PATH)/expat-2.0.1 ;

using ext-boost : $(BOOST_VERSION:J=.) : $(BOOST_SOURCE) : <zlib-src-location>$(ZLIB_SOURCE) ;

if [ modules.peek : NT ]
{
    import path ;

    if ( ! --incremental in $(args) ) && ! [ without-binary-msdata ]
    {
        # extract the vendor APIs if the user agrees to the licenses
        if --i-agree-to-the-vendor-licenses in $(args)
        {
            echo "Extracting vendor APIs..." ;
            if ! --without-sciex in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_ABI.7z" ; }
            if ! --without-agilent in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Agilent.7z" ; }
            if ! --without-bruker in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Bruker.7z" ; }
# Waiting for CCS<->DT support in .mbi reader #            if ! --without-mobilion in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Mobilion.7z" ; }
            if ! --without-shimadzu in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Shimadzu.7z" ; }
            if ! --without-thermo in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Thermo.7z" ; }
            #if ! --without-unifi in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_UNIFI.7z" ; }
            if ! --without-waters in $(args) { SHELL "$(PWIZ_LIBRARIES_PATH)\\7za.exe x -aoa -pi-agree-to-the-vendor-licenses -o$(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility $(PWIZ_ROOT_PATH)\\pwiz_aux\\msrc\\utility\\vendor_api_Waters.7z" ; }
            RESCAN ;
        }
        else
        {
            echo "NOTICE: not extracting vendor APIs; use --i-agree-to-the-vendor-licenses to extract and use them." ;
        }
     }

    # overwrite the original header files because of MSVC looking in the current header's path with #include "foo"

    # HACK: bug in boost::interprocess (up to at least 1.55) requires a patch to support opening memory-mapped files with UTF-8 filenames
    # Boost bug ticket: https://svn.boost.org/trac/boost/ticket/4335
    #SHELL "@IF NOT EXIST $(BOOST_SOURCE)\\boost\\interprocess\\detail\\os_file_functions.hpp.bak rename $(BOOST_SOURCE)\\boost\\interprocess\\detail\\os_file_functions.hpp os_file_functions.hpp.bak" ;
    #SHELL "@IF NOT EXIST $(BOOST_SOURCE)\\boost\\interprocess\\detail\\win32_api.hpp.bak rename $(BOOST_SOURCE)\\boost\\interprocess\\detail\\win32_api.hpp win32_api.hpp.bak" ;
    #SHELL "@copy /Y $(PWIZ_LIBRARIES_PATH)\\boost_aux\\boost\\interprocess\\detail\\os_file_functions.hpp $(BOOST_SOURCE)\\boost\\interprocess\\detail" ;
    #SHELL "@copy /Y $(PWIZ_LIBRARIES_PATH)\\boost_aux\\boost\\interprocess\\detail\\win32_api.hpp $(BOOST_SOURCE)\\boost\\interprocess\\detail" ;
}


rule project-exists ( project-path )
{
    if [ path.exists $(project-path) ] &&
       [ path.glob $(project-path) : "[Jj]amroot.jam" "[Jj]amfile.jam" "[Jj]amroot" "[Jj]amfile" ]
    {
        return true ;
    }
    else
    {
        return ;
    }
}


# simplify calling rules/variables from other projects/modules
rule get-project-expression ( project-path : expression args * : * )
{
    if [ project-exists $(project-path) ]
    {
        import project ;
        import modules ;
        # support that full set of parameters that can be used (19).
        # Example in Boost Build source file src/kernel/modules.jam, with rule call-locally
        # Must load the project before we can 'call-in' to it, because projects are loaded differently than modules
        return [ modules.call-in [ project.load $(project-path) ] : $(expression) $(args) : $(2) : $(3) :
            $(4) : $(5) : $(6) : $(7) : $(8) : $(9) : $(10) : $(11) : $(12) : $(13)
            $(14) : $(15) : $(16) : $(17) : $(18) : $(19) ] ;
    }
    else
    {
        return ;
    }
}


# to make subsetting the source tree much easier,
# use these rules to test that a sub-project path exists before building it
rule build-project-if-exists ( project-path )
{
    local project = [ project.current ] ;
    local p = [ path.native [ path.join [ $(project).location ] $(project-path) ] ] ;
    if [ project-exists $(p) ]
    {
        local attributes = [ project.attributes [ $(project).name ] ] ;
        local now = [ $(attributes).get projects-to-build ] ;
        $(attributes).set projects-to-build : $(now) $(project-path) ;
    }
}

rule run-if-exists ( sources + : args * : input-files * : requirements * : target-name ? : default-build * )
{
    local project = [ project.current ] ;
    local full-path = [ path.native [ path.join [ $(project).location ] $(project-path) $(sources[1]) ] ] ;
    if [ path.exists $(full-path) ]
    {
        return [ run $(sources) : $(args) : $(input-files) : $(requirements) : $(target-name) : $(default-build) ] ;
    }
}

rule run-fail-if-exists ( sources + : args * : input-files * : requirements * : target-name ? : default-build * )
{
    local project = [ project.current ] ;
    local full-path = [ path.native [ path.join [ $(project).location ] $(project-path) $(sources[1]) ] ] ;
    if [ path.exists $(full-path) ]
    {
        return [ run-fail $(sources) : $(args) : $(input-files) : $(requirements) : $(target-name) : $(default-build) ] ;
    }
}


rule unit-test-if-exists ( target : sources + : properties * )
{
    local project = [ project.current ] ;
    local full-path = [ path.native [ path.join [ $(project).location ] $(project-path) $(sources[1]) ] ] ;
    if [ path.exists $(full-path) ]
    {
        return [ unit-test $(target) : $(sources) : $(properties) ] ;
    }
}


rule doctest ( name : sources + : requirements * )
{
    unit-test-if-exists $(name) : $(sources) : $(requirements) <define>PWIZ_DOCTEST <location-prefix>doctest ;
}


# build/install

build-project-if-exists pwiz ;
build-project-if-exists pwiz_aux ;
build-project-if-exists pwiz_tools ;


rule install-location ( properties * )
{
    local toolsets = [ feature.get-values <toolset> : $(properties) ] ;
    local variants = [ feature.get-values <variant> : $(properties) ] ;
    local location = [ path.make $(PWIZ_BUILD_PATH)/$(toolsets[1])-$(variants[1]) ] ;
    if <link>shared in $(properties) { location = $(location)-shared ; }
    if <address-model>64 in $(properties) { location = $(location)-x86_64 ; }

    return <location>$(location) ;
}

rule install-type ( properties * )
{
    local result = <install-type>EXE ;
    if <link>shared in $(properties)
    {
        result += <install-dependencies>on <install-type>SHARED_LIB <install-type>MANIFEST ;
    }
    return $(result) ;
}

import string ;
rule install-vendor-api-dependencies ( properties * )
{
    properties = $(properties) [ vendor-api-support $(properties) ] ;
    local location = [ feature.get-values <location> : $(properties) ] ;
    if $(location) { location = [ string.join <location> [ path.make $(location[1]) ] ] ; }
    location ?= [ install-location $(properties) ] ;

    local dependencies ;
    if <toolset>msvc in $(properties) && <link>static in $(properties) && ! [ without-binary-msdata ]
    {
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/ABI ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/ABI//install_pwiz_vendor_api_abi_dlls/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/ABI ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/ABI//install_pwiz_vendor_api_abi_sqlite/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/ABI/T2D ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/ABI/T2D//install_pwiz_vendor_api_abi_t2d/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Agilent ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/Agilent//install_pwiz_vendor_api_agilent/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Bruker ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/Bruker//install_pwiz_vendor_api_bruker/$(location) ; }
# wait for CCS<->DT support in Mobllion #         if [ path.exists pwiz_aux/msrc/utility/vendor_api/Mobilion ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/Mobilion//install_pwiz_vendor_api_mbi/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Shimadzu ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/Shimadzu//install_pwiz_vendor_api_shimadzu/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/thermo ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/thermo//install_pwiz_vendor_api_thermo/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/UIMF ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/UIMF//install_pwiz_vendor_api_uimf/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/UNIFI ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/UNIFI//install_pwiz_vendor_api_unifi/$(location) ; }
        if [ path.exists pwiz_aux/msrc/utility/vendor_api/Waters ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_aux/msrc/utility/vendor_api/Waters//install_pwiz_vendor_api_waters/$(location) ; }
        if <vendor-api-support>on in $(properties) { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz_tools/prototype//ThermoRawMetaDumpInstall/$(location) ; }
    }
    return $(dependencies) ;
}

rule install-identdata-dependencies ( properties * )
{
    local location = [ feature.get-values <location> : $(properties) ] ;
    if $(location) { location = [ string.join <location> [ path.make $(location[1]) ] ] ; }
    location ?= [ install-location $(properties) ] ;
    local dependencies ;
    if [ path.exists pwiz/data/identdata ] { dependencies += <dependency>$(PWIZ_ROOT_PATH)/pwiz/data/identdata//install_pwiz_identdata/$(location) ; }
    return $(dependencies) ;
}

rule pwiz-bindings-dependency ( properties * )
{
    if <toolset>msvc in $(properties)
    {
        local variants = [ feature.get-values <variant> : $(properties) ] ;
        local location = <location>$(PWIZ_BUILD_PATH)/obj/$(PLATFORM)/$(variants[1]) ;
        return <assembly>$(PWIZ_ROOT_PATH)/pwiz/utility/bindings/CLI//pwiz_bindings_cli
               <dependency>$(PWIZ_ROOT_PATH)/pwiz/utility/bindings/CLI//pwiz_bindings_cli/$(location)
               <dependency>$(PWIZ_ROOT_PATH)/pwiz/utility/bindings/CLI//pwiz_bindings_cli.xml/$(location) ;
    }
}

rule dotNET-dependencies ( properties * )
{
    if [ msvc-has-current-dotnet $(properties) ]
    {
        local location = [ install-location $(properties) ] ;
        return <dependency>$(PWIZ_ROOT_PATH)/pwiz_tools/MSConvertGUI//MSConvertGUI.exe/$(location)
               <dependency>$(PWIZ_ROOT_PATH)/pwiz_tools/SeeMS//seems/$(location) ;
    }
}

rule gcc-install-dll-path ( properties * )
{
    if <toolset>gcc in $(properties) && <link>shared in $(properties) && <target-os>linux in $(properties)
    {
        return <dll-path>'$ORIGIN' ;
    }
}


install executables
    : pwiz_tools/commandline
      pwiz_tools/sld//sldout
      pwiz_tools/examples//example_tools
    : <conditional>@install-type
      <conditional>@install-location
      <conditional>@install-identdata-dependencies
      <conditional>@install-vendor-api-dependencies
      <conditional>@dotNET-dependencies
      <conditional>@gcc-install-dll-path
      <toolset>msvc:<dependency>install-msvc-runtime-dlls
      <dependency>VERSION
    ;

install gui_tools
    : pwiz_tools/commandline//msconvert
    : <conditional>@install-type
      <conditional>@install-location
      <conditional>@install-identdata-dependencies
      <conditional>@install-vendor-api-dependencies
      <conditional>@dotNET-dependencies
      <conditional>@gcc-install-dll-path
      <toolset>msvc:<dependency>install-msvc-runtime-dlls
      <dependency>VERSION
    ;

install package_docs
    : doc/package/readme.txt
    : <conditional>@install-location
    ;


# convenient test targets
install msconvert
    : pwiz_tools/commandline//msconvert
    : <conditional>@install-type
      <conditional>@install-location
      <conditional>@install-identdata-dependencies
      <conditional>@install-vendor-api-dependencies
      <conditional>@gcc-install-dll-path
      <toolset>msvc:<dependency>install-msvc-runtime-dlls
    ;
explicit msconvert ;

install msbenchmark
    : pwiz_tools/examples//msbenchmark
    : <conditional>@install-type
      <conditional>@install-location
      <conditional>@install-vendor-api-dependencies
      <conditional>@gcc-install-dll-path
      <toolset>msvc:<dependency>install-msvc-runtime-dlls
    ;
explicit msbenchmark ;

install idconvert
    : pwiz_tools/commandline//idconvert
    : <conditional>@install-type
      <conditional>@install-location
      <conditional>@install-identdata-dependencies
      <conditional>@install-vendor-api-dependencies
      <conditional>@gcc-install-dll-path
      <toolset>msvc:<dependency>install-msvc-runtime-dlls
    ;
explicit idconvert ;

alias all-tests : pwiz pwiz_tools pwiz_aux ;


if ! --without-compassxtract in [ modules.peek : ARGV ]
{
    .installer-vendor-files-location = $(PWIZ_BUILD_PATH)/$(PLATFORM) ;
}
else
{
    .installer-vendor-files-location = $(PWIZ_BUILD_PATH)/without-cxt/$(PLATFORM) ;
}

rule make_INSTALLER_VENDOR_FILES ( targets * : sources * : properties * )
{
    # enumerate .NET assemblies and their native DLL dependencies
    local assemblies = [ feature.get-values <assembly> : $(properties) ] ;
    assemblies += [ feature.get-values <assembly-dependency> : $(properties) ] ;
    if $(assemblies)
    {
        for local assembly in $(assemblies)
        {
            local assembly-path = [ path.basename [ $(assembly).name ] ] ;
            if ! $(assembly-path:L) in $(.unique-vendor-files:L)
            {
                .unique-vendor-files += $(assembly-path) ;
            }
        }
    }
    
    # TODO: figure out a better way to specify subdirectories for assembly-dependencies
    local assemblies-ex = [ feature.get-values <assembly-dependency-ex> : $(properties) ] ;
    if $(assemblies-ex)
    {
        for local assembly in $(assemblies-ex)
        {
            local assembly-parts = [ SPLIT_BY_CHARACTERS $(assembly) : "|" ] ;
            local assembly-path = [ path.basename $(assembly-parts[1]) ] ;
            if ( $(assembly-parts[2]) )
            {
                local features = [ feature.split $(assembly-parts[2]) ] ;
                assembly-path = [ path.join [ feature.get-values <location-prefix> : $(features) ] $(assembly-path) ] ;
            }

            if ! $(assembly-path:L) in $(.unique-vendor-files:L)
            {
                .unique-vendor-files += $(assembly-path) ;
            }
        }
    }

    local rule case-insensitive-compare ( a b ) { if $(a:L) < $(b:L) { return true ; } }
    local sorted-vendor-files = [ sequence.insertion-sort $(.unique-vendor-files) : case-insensitive-compare ] ;
    local .nl = [ common.newline-char ] ;
    TARGETS on $(<) = $(sorted-vendor-files:J=$(.nl)) ;
}

actions make_INSTALLER_VENDOR_FILES bind TARGETS
{
@($(STDOUT):E=$(TARGETS)
) > "$(<)"
}

make INSTALLER_VENDOR_FILES.txt : msconvert : @make_INSTALLER_VENDOR_FILES : <location>$(.installer-vendor-files-location) ;
explicit INSTALLER_VENDOR_FILES.txt ;


# for copying all libraries and headers to one dir each
alias libraries : install-pwiz-lib install-boost-headers ;
explicit libraries ;

# default install location
local default-prefix = /usr/local ; # LINUX, MACOS
if [ modules.peek : NT ] { default-prefix = "C:\\" ; }
# set the default option value to be used when building the lib tarball
option.set prefix : $(default-prefix) ;

local headers = [ path.glob-tree pwiz : *.h *.hpp : .svn ] ;
package.install install-pwiz-lib
    : <install-source-root>$(PWIZ_ROOT_PATH) 
    : # executables
    : pwiz
    : $(headers) 
    ;
explicit install-pwiz-lib ;

# move boost headers separately because install-source-root is different
local boost_headers = [ path.glob-tree $(BOOST_SOURCE)/boost : *.h *.hpp : .svn ] ;
package.install install-boost-headers
    : <install-source-root>$(BOOST_SOURCE) 
    : # exe
    : # lib
    : $(boost_headers)
    ;
explicit install-boost-headers ;


# warning: _SECURE_SCL_THROWS is deprecated
# checked iterators throw instead of crash  
rule secure-scl-throws ( properties * )
{
    if <toolset>msvc in $(properties) &&
       ! ( <toolset-msvc:version>11.0 in $(properties) ) &&
       ! ( <toolset-msvc:version>12.0 in $(properties) ) &&
       ! ( <toolset-msvc:version>14.0 in $(properties) ) &&
       ! ( <toolset-msvc:version>14.1 in $(properties) ) &&
       ! ( <toolset-msvc:version>14.2 in $(properties) ) &&
       ! ( <toolset-msvc:version>14.3 in $(properties) )
    {
        return <define>_SILENCE_DEPRECATION_OF_SECURE_SCL_THROWS
               <define>_SECURE_SCL_THROWS=1 ;
    }
}

# newer OS/GCC versions have PIE enabled by default, but msparser was compiled without PIE, so we must also compile without PIE
obj has-pie : $(PWIZ_ROOT_PATH)/pwiz/Version.cpp : <cflags>-fno-pie <cxxflags>-fno-pie <linkflags>-no-pie ;
explicit has-pie ;

if [ check-target-builds has-pie "GCC has -no-pie" : <cflags>-no-pie <cxxflags>-no-pie <linkflags>-no-pie ]
{
    .pic-options = -fPIC -no-pie -fno-pie ;
}
else
{
    .pic-options = -fPIC ;
}

# any GCC executable that uses shared libraries must have all its code built with -fPIC
rule static-with-fpic ( properties * )
{
    if ( <toolset>gcc in $(properties) || <toolset>darwin in $(properties) ) &&
       <link>static in $(properties)
    {
        return <cflags>$(.pic-options) <cxxflags>$(.pic-options) <linkflags>$(.pic-options) ;
    }
}


# predicate for use as a <conditional> requirement of targets that must only build with MSVC
rule msvc-requirement ( properties * )
{
    if ! <toolset>msvc in $(properties) { return <build>no ; }
}

rule msvc-has-current-dotnet ( properties * )
{
    # require VS 2017 or higher because of .NET Framework version
    if <toolset>msvc in $(properties) && 
       [ feature.get-values <toolset-msvc:version> : $(properties) ] in "14.1" "14.2" "14.3"
    {
        return 1 ;
    }
}

# predicate for use as a <conditional> requirement of targets that must only build with MSVC and current .NET Framework
rule msvc-dotnet-requirement ( properties * )
{
    if ! [ msvc-has-current-dotnet $(properties) ] { return <build>no ; }
}

# predicate for use as a <conditional> requirement of targets that must only build with non-express version of MSVC
rule no-express-requirement ( properties * )
{
    # only non-express version of MSVC since 2017
    if ! [ msvc-has-current-dotnet $(properties) ] { return <build>no ; }
    if 12.0express in $(properties:G=) { return <build>no ; }
}

# CONSIDER: would be nice to access msvc.jam's setup logic, but that would seem to require significant refactoring
rule get-current-msvc-setup-script ( properties * )
{
    local platformToolsetVersion = [ regex.replace [ feature.get-values <toolset-msvc:version> : $(properties) ] "\\." "" ] ;
    return "CALL $(PWIZ_ROOT_PATH)\\libraries\\msvc_setup_script.bat $(PROCESSOR_ARCHITECTURE:L) $(platformToolsetVersion) >nul" ;
}

# special support for MSFileReader on Windows
if [ modules.peek : NT ]
{
    # can't build or run 64-bit version on Windows 32-bit OS
    import os ;
    local ProgramFiles = [ os.environ ProgramFiles ] ;
    local ProgramFilesX86 = [ os.environ "ProgramFiles(x86)" ] ;
    ProgramFilesX86 = $(ProgramFilesX86:E=$(ProgramFiles)) ;

    if ( [ MATCH (x64) : $(PLATFORM) ] )
    {
        constant ProgramFilesLibs : "C:\\Program Files" ; # still needed for MascotParser
    }
    else
    {
        # MSFileReader install directory
        constant ProgramFilesLibs : "$(ProgramFilesX86)" ;
        constant MSFILEREADER_SUFFIX : "" ;
        constant MSFILEREADER_INSTALL_DIR : "$(ProgramFilesLibs)\\Thermo\\MSFileReader" ;
    }
} # if NT

# HACK: find location of WiffFileDataReader DLLs (it must be in Jamroot so both vendor_readers and vendor_api can use it)
rule wiff-dll-location ( api-path : properties * )
{
    # .NET 4 DLLs should work for anything .NET 4 or greater (hopefully); there's no Boost.Build property for .NET version
    local result = $(api-path) ;
    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       [ path.exists $(result)\\Clearcore2.Data.dll ]
    {
        return $(result) ;
    }
}

rule unifi-dll-location ( api-path : properties * )
{
    # .NET 4.5 DLLs should work for anything .NET 4 or greater (hopefully); there's no Boost.Build property for .NET version
    local result = $(api-path) ;
    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       [ path.exists $(result)\\unifi-protobuf-net.dll ]
    {
        return $(result) ;
    }
}

rule mbi-dll-location ( api-path : properties * )
{
    local result = $(api-path) ;
    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       [ path.exists $(api-path)\\MBICore.dll ]
    {
        return $(result) ;
    }
}

rule bruker-dll-location ( api-path : properties * )
{
    local result ;

    if ( [ MATCH (x64) : $(PLATFORM) ] )
    {
        result = $(api-path)\\x64 ;
    }
    else
    {
        result = $(api-path)\\x86 ;
    }

    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       $(result) &&
       [ path.exists $(result)\\CompassXtractMS.dll ]            
    {
        return $(result) ;
    }
}

rule shimadzu-dll-location ( api-path : properties * )
{
    local result ;

    if ( [ MATCH (x64) : $(PLATFORM) ] )
    {
        result = $(api-path)\\x64 ;
    }
    else
    {
        result = $(api-path)\\x86 ;
    }

    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       $(result) &&
       [ path.exists $(result)\\CompressedTLMRawDataReader.dll ]
    {
        return $(result) ;
    }
}

rule mhdac-dll-location ( api-path : properties * )
{
    local result ;

    if ( [ MATCH (x64) : $(PLATFORM) ] )
    {
        result = $(api-path)\\x64 ;
    }
    else
    {
        result = $(api-path)\\x86 ;
    }

    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       $(result) &&
       [ path.exists $(result)\\MassSpecDataReader.dll ]            
    {
        return $(result) ;
    }
}

rule masslynxraw-dll-location ( api-path : properties * )
{
    local result ;
    if <toolset>msvc in $(properties) 
    {
        if ( [ MATCH (x64) : $(PLATFORM) ] )
        {
            result = $(api-path)\\vc12_x64 ;
        }
        else
        {
            result = $(api-path)\\vc12_x86 ;
        }
    }

    if --i-agree-to-the-vendor-licenses in [ modules.peek : ARGV ] &&
       $(result) &&
       [ path.exists $(result)\\MassLynxRaw.dll ]            
    {
        return $(result) ;
    }
}


rule msparser-path ( properties * )
{
    # Assign the most likely msparser library path
    local msparser_path_arg = [ MATCH --msparser-path=(.*) : [ modules.peek : ARGV ] ] ;

    local lib-location ;
    if $(msparser_path_arg)
    {
        lib-location = $(msparser_path_arg) ;
    }
    else if <toolset>msvc in $(properties)
    {
        if [ feature.get-values <toolset-msvc:version> : $(properties) ] in "9.0" "9.0express"
        {
            lib-location = "$(ProgramFilesLibs)\\Matrix Science\\Mascot Parser\\vs2008" ;
        }
        else if [ feature.get-values <toolset-msvc:version> : $(properties) ] in "10.0" "10.0express"
        {
            lib-location = "$(ProgramFilesLibs)\\Matrix Science\\Mascot Parser\\vs2010" ;
        }
        else if [ feature.get-values <toolset-msvc:version> : $(properties) ] in "11.0" "11.0express"
        {
            lib-location = "$(ProgramFilesLibs)\\Matrix Science\\Mascot Parser\\vs2012" ;
        }
        else if [ feature.get-values <toolset-msvc:version> : $(properties) ] in "12.0" "12.0express"
        {
            lib-location = "$(ProgramFilesLibs)\\Matrix Science\\Mascot Parser\\vs2013" ;
        }
        else if [ feature.get-values <toolset-msvc:version> : $(properties) ] in "14.0" "14.1" "14.2" "14.3"
        {
            lib-location = "$(ProgramFilesLibs)\\Matrix Science\\Mascot Parser\\vs2015" ;
        }
        else
        {
            if ! $(.warn-once)
            {
                .warn-once = true ;
                echo "Warning: Not using Mascot Parser due to unsupported version of MSVC." ;
            }
            lib-location = "" ;
        }
    } 
    else if <toolset>gcc in $(properties)
    {
        lib-location = "/usr/local/msparser/gnu" ;
    }
    else
    {
        if ! $(.warn-once)
        {
            .warn-once = true ;
            echo "Note: Not using Mascot Parser due to unsupported compiler." ;
        }
        lib-location = "" ;
    }

    if [ without-binary-msdata ] 
    {
        if ! $(.warn-once)
        {
            .warn-once = true ;
            echo "Note: Not using Mascot Parser due to --without-binary-msdata ." ;
        }
    }
    # Check for msparser existence.
    else if <toolset>msvc in $(properties) && [ path.exists $(lib-location)/lib/msparser.lib ]
    {
        if ! $(.warn-once)
        {
            .warn-once = true ;
            echo "Using Mascot Parser in $(lib-location)" ;
        }
        return $(lib-location) ;
    }
    else if <toolset>gcc in $(properties) && [ path.exists $(lib-location)/lib/libmsparser.a ]
    {
        if ! $(.warn-once)
        {
            .warn-once = true ;
            echo "Using Mascot Parser in $(lib-location)" ;
        }
        return $(lib-location) ;
    }
    else if ! $(.warn-once)
    {
        .warn-once = true ;
        
        if $(lib-location)
        {
            echo "Warning: No Mascot Parser found at $(lib-location)." ;
        }
        else
        {
            echo "Warning: No Mascot Parser found." ;
        }
        echo "         Mascot support will be disabled." ;
    }
}

rule msparser-requirements ( properties * )
{
    local msparser_path = [ msparser-path $(properties) ] ;
    local result = <search>$(msparser_path)/lib ;
    if <toolset>msvc in $(properties)
    {
        if <runtime-debugging>on in $(properties)
        {
            result += <name>msparserD ;
        }
    }
    return $(result) [ msparser-usage-requirements $(properties) ] ;
}

rule msparser-usage-requirements ( properties * )
{
    local msparser_path = [ msparser-path $(properties) ] ;
    local result = <include>$(msparser_path)/include ;
    if <toolset>msvc in $(properties)
    {
        result += <assembly-dependency>$(msparser_path)/../config/unimod_2.xsd <assembly-dependency>$(msparser_path)/../config/quantitation_1.xsd <assembly-dependency>$(msparser_path)/../config/quantitation_2.xsd ;
        if <runtime-debugging>on in $(properties)
        {
            result += <assembly-dependency>$(msparser_path)/lib/msparserD.dll ;
        }
        else
        {
            result += <assembly-dependency>$(msparser_path)/lib/msparser.dll ;
        }
    }
    return $(result) ;
}

searched-lib msparser : : <conditional>@msparser-requirements : : <conditional>@msparser-usage-requirements ;


.msvcrt-x86 = 
    Microsoft.VC110.CRT/x86/msvcp110.dll 
    Microsoft.VC110.CRT/x86/msvcr110.dll 
    Microsoft.VC110.CRT/x86/vcomp110.dll 
    Microsoft.VC120.CRT/x86/msvcp120.dll 
    Microsoft.VC120.CRT/x86/msvcr120.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-console-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-datetime-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-debug-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-errorhandling-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-file-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-file-l1-2-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-file-l2-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-handle-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-heap-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-interlocked-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-libraryloader-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-localization-l1-2-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-memory-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-namedpipe-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-processenvironment-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-processthreads-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-processthreads-l1-1-1.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-profile-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-rtlsupport-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-string-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-synch-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-synch-l1-2-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-sysinfo-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-timezone-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-core-util-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-conio-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-convert-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-environment-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-filesystem-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-heap-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-locale-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-math-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-multibyte-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-private-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-process-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-runtime-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-stdio-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-string-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-time-l1-1-0.dll 
    Microsoft.VC140.CRT/x86/api-ms-win-crt-utility-l1-1-0.dll 
    #Microsoft.VC140.CRT/x86/concrt140.dll
    #Microsoft.VC140.CRT/x86/mfc140.dll 
    Microsoft.VC140.CRT/x86/msvcp140.dll 
    Microsoft.VC140.CRT/x86/ucrtbase.dll 
    Microsoft.VC140.CRT/x86/vcomp140.dll 
    Microsoft.VC140.CRT/x86/vcruntime140.dll 
    #Microsoft.VC140.CRT/x86/msvcp140_1.dll
    #Microsoft.VC140.CRT/x86/msvcp140_2.dll
    #Microsoft.VC140.CRT/x86/msvcp140_atomic_wait.dll
    #Microsoft.VC140.CRT/x86/msvcp140_codecvt_ids.dll
    #Microsoft.VC140.CRT/x86/vccorlib140.dll
    Microsoft.VC90.MFC/x86/Microsoft.VC90.MFC.manifest
    Microsoft.VC90.MFC/x86/mfc90u.dll 
    Microsoft.VC90.CRT/x86/msvcp90.dll # used by MSFileReader
    Microsoft.VC90.CRT/x86/msvcr90.dll # used by MSFileReader
    ;

.msvcrt-x64 =
    Microsoft.VC110.CRT/x64/msvcp110.dll
    Microsoft.VC110.CRT/x64/msvcr110.dll
    Microsoft.VC110.CRT/x64/vcomp110.dll
    Microsoft.VC120.CRT/x64/msvcp120.dll
    Microsoft.VC120.CRT/x64/msvcr120.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-console-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-datetime-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-debug-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-errorhandling-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-file-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-file-l1-2-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-file-l2-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-handle-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-heap-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-interlocked-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-libraryloader-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-localization-l1-2-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-memory-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-namedpipe-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-processenvironment-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-processthreads-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-processthreads-l1-1-1.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-profile-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-rtlsupport-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-string-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-synch-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-synch-l1-2-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-sysinfo-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-timezone-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-core-util-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-conio-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-convert-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-environment-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-filesystem-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-heap-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-locale-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-math-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-multibyte-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-private-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-process-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-runtime-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-stdio-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-string-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-time-l1-1-0.dll
    Microsoft.VC140.CRT/x64/api-ms-win-crt-utility-l1-1-0.dll
    #Microsoft.VC140.CRT/x64/concrt140.dll
    #Microsoft.VC140.CRT/x64/mfc140.dll
    Microsoft.VC140.CRT/x64/msvcp140.dll
    Microsoft.VC140.CRT/x64/ucrtbase.dll
    Microsoft.VC140.CRT/x64/vcomp140.dll
    Microsoft.VC140.CRT/x64/vcruntime140.dll
    #Microsoft.VC140.CRT/x64/msvcp140_1.dll
    #Microsoft.VC140.CRT/x64/msvcp140_2.dll
    #Microsoft.VC140.CRT/x64/msvcp140_atomic_wait.dll
    #Microsoft.VC140.CRT/x64/msvcp140_codecvt_ids.dll
    Microsoft.VC140.CRT/x64/vcruntime140_1.dll
    #Microsoft.VC140.CRT/x64/vccorlib140.dll
    ;

.msvcrt-x86-cxt =    
    Microsoft.VC90.CRT/x86/msvcm90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x86/vcomp90.dll # used by CompassXtract
    Microsoft.VC90.MFC/x86/mfc90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x86/Microsoft.VC90.CRT.manifest
    Microsoft.VC90.CRT/x86/Microsoft.VC90.OpenMP.manifest
    ;

.msvcrt-x64-cxt =
    Microsoft.VC90.CRT/x64/msvcm90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x64/msvcp90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x64/msvcr90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x64/vcomp90.dll # used by CompassXtract
    Microsoft.VC90.MFC/x64/mfc90.dll # used by CompassXtract
    Microsoft.VC90.CRT/x64/Microsoft.VC90.CRT.manifest
    Microsoft.VC90.CRT/x64/Microsoft.VC90.OpenMP.manifest
    Microsoft.VC90.MFC/x64/Microsoft.VC90.MFC.manifest
    ;

rule msvc-runtime-dlls ( properties * )
{
    local result ;
    if <toolset>msvc in $(properties)
    {
        local xbit = "x86" ;
        if <address-model>64 in $(properties)
        {
            xbit = "x64" ;
        }

        result = <assembly-dependency>$(PWIZ_ROOT_PATH)/pwiz_tools/Shared/Lib/$(.msvcrt-$(xbit)) ;
        if ! --without-compassxtract in [ modules.peek : ARGV ]
        {
            result += <assembly-dependency>$(PWIZ_ROOT_PATH)/pwiz_tools/Shared/Lib/$(.msvcrt-$(xbit)-cxt) ;
        }
    }
    return $(result) ;
}

rule install-msvc-runtime-dlls-requirements ( properties * )
{
    local result ;
    if <toolset>msvc in $(properties)
    {
        local xbit = "x86" ;
        if <address-model>64 in $(properties)
        {
            xbit = "x64" ;
        }

        result = <source>$(PWIZ_ROOT_PATH)/pwiz_tools/Shared/Lib/$(.msvcrt-$(xbit)) ;
        if ! --without-compassxtract in [ modules.peek : ARGV ]
        {
            result += <source>$(PWIZ_ROOT_PATH)/pwiz_tools/Shared/Lib/$(.msvcrt-$(xbit)-cxt) ;
        }
    }
    return $(result) ;
}

install install-msvc-runtime-dlls : : <conditional>@install-location <conditional>@install-msvc-runtime-dlls-requirements ;


# any source tree can build binary tarballs

import common ;
import property-set ;
import sequence ;
import option ;
import property ;

.common-location = $(PWIZ_BUILD_PATH) ;

rule binary-tarball-requirements ( properties * )
{
    local toolsets = [ feature.get-values <toolset> : $(properties) ] ;
    local variants = [ feature.get-values <variant> : $(properties) ] ;
    local location = [ install-location $(properties) ] ;
    location = $(location:G=) ;

    local non-redistributables = pwiz_bindings_cli.xml ; # .NET documentation

    if $(variants[1]) = "release"
    {
        non-redistributables += *.pdb ; # MSVC debug symbols
    }

    non-redistributables = [ sequence.join $(non-redistributables) : "&&exclude:" ] ;

    local result = "<tar-source>path-anchor:$(location)&&exclude:$(non-redistributables)&&$(location)" ;
    if ! <architecture> in $(properties:G)
    {
        if $(.platform:L) = "x86_64" && <address-model>32 in $(properties) { properties += <architecture>x86 ; }
        else if $(.platform:L) = "x86" && <address-model>64 in $(properties) { properties += <architecture>x86_64 ; } 
        else { properties += <architecture>$(.platform:L) ; }
    }
    local linkage ;
    if <link>shared in $(properties) { linkage = "-shared" ; }
    local name = [ common.format-name <base> <property:target-os> <property:architecture> <toolset> <property:variant> $(linkage) -$(version-tag:J=_)
                                      : pwiz-bin : TBZ2 : [ property-set.create $(properties) ] ] ;
    result += <name>$(name) <dependency>executables <location>$(.common-location) <dependency>VERSION ;
    return $(result) ;
}

tar.create pwiz-bin.tar.bz2
  : # sources are handled by the conditional

  : # requirements
    <conditional>@binary-tarball-requirements
  ;

rule library-tarball-requirements ( properties * )
{
    local toolsets = [ feature.get-values <toolset> : $(properties) ] ;
    local variants = [ feature.get-values <variant> : $(properties) ] ;
    
    # require that the location come from --prefix or default; do not allow --libdir or --includedir
    if [ MATCH --libdir=(.*) : [ modules.peek : ARGV ] ] ||
       [ MATCH --includedir=(.*) : [ modules.peek : ARGV ] ]
    {
        echo "--libdir and --includedir are not supported for pwiz-lib.tar.bz2; use --prefix instead" ;
        exit ;
    }

    local prefix = [ option.get prefix ] ;
    local location = $(prefix:G=) ;

    # no more redistributables!
    #local non-redistributables =
    #non-redistributables = [ sequence.join $(non-redistributables) : "&&exclude:" ] ;
    #local result = <tar-source>path-anchor:$(location)&&exclude:$(non-redistributables)&&$(location) ;

    local result = "<tar-source>path-anchor:$(location)&&$(location)" ;
    if ! <architecture> in $(properties:G)
    {
        if $(.platform:L) = "x86_64" && <address-model>32 in $(properties) { properties += <architecture>x86 ; }
        else if $(.platform:L) = "x86" && <address-model>64 in $(properties) { properties += <architecture>x86_64 ; } 
        else { properties += <architecture>$(.platform:L) ; }
    }
    local linkage ;
    if <link>shared in $(properties) { linkage = "-shared" ; }
    local name = [ common.format-name <base> <property:target-os> <property:architecture> <toolset> <property:variant> $(linkage) -$(version-tag:J=_)
                                      : pwiz-lib : TBZ2 : [ property-set.create $(properties) ] ] ;
    result += <name>$(name) <dependency>libraries <location>$(.common-location) <dependency>VERSION ;
    return $(result) ;
}

tar.create pwiz-lib.tar.bz2
  : # sources are handled by the conditional

  : # requirements
    <conditional>@library-tarball-requirements
  ;
explicit pwiz-lib.tar.bz2 ;

# full source trees automatically build source tarballs

if ! [ path.exists $(PWIZ_ROOT_PATH)/SUBSET ]
{

import bcp ;
using bcp : $(BOOST_SOURCE) : $(.common-location)/bcp ;

path-constant BOOST_SUBSET_PATH : $(.common-location)/boost-subset ;

bcp.copy-boost-dependencies copy_boost_subset
  : # sources

    # scan all source files for boost dependencies
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz_aux : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_ROOT_PATH)/pwiz_tools : *.cpp *.hpp *.h ]
    [ path.glob-tree $(PWIZ_LIBRARIES_PATH)/boost_aux : *.cpp *.hpp ]
    [ path.glob-tree $(PWIZ_LIBRARIES_PATH)/SQLite : *.cpp *.h ]

    [ mz5-build $(PWIZ_LIBRARIES_PATH)/hdf5-1.8.7/src/init_once_workaround.cpp ]

    # scan all targets and their dependencies
    $(PWIZ_ROOT_PATH)/pwiz_tools/commandline//mstools

  : # requirements
    <location>$(BOOST_SUBSET_PATH)/boost_$(BOOST_VERSION:J=_)
  ;


tar.create boost_$(BOOST_VERSION:J=_).tar.bz2
  : # sources

      "path-anchor:$(BOOST_SUBSET_PATH)"
      $(BOOST_SUBSET_PATH)/boost_$(BOOST_VERSION:J=_)

  : # requirements
    <location>$(BOOST_SUBSET_PATH)/libraries
    <dependency>copy_boost_subset
  ;

.common-src-exclusions = 
    "exclude:.svn"
    "exclude:.git"
    "exclude:*.bak"
    "exclude:cvgen*.exe"
    "exclude:svnrev.hpp"
    "exclude:Version.cpp"
    "exclude:Reader_*_Test.data"
    "exclude:example_data/small*" # large files in example_data
    "exclude:bin" "exclude:obj" "exclude:TestResults" # C#.NET intermediate directories
    "exclude:_ReSharper.*" # ReSharper directory for C# projects
    "exclude:*.ncb" "exclude:*.suo" "exclude:*.user" "exclude:*.p12" "exclude:*.sdf" "exclude:.vs" # More visual studio files
    "exclude:*.xdc" # .NET XML documentation sources
    "exclude:tar.excluded" # a place to put any files in these directories that shouldn't be tarballed
    "exclude:pwiz_aux/msrc/utility/vendor_api/ABI/Clearcore*.dll"
    "exclude:pwiz_aux/msrc/utility/vendor_api/ABI/Sciex*.dll"
    "exclude:pwiz_aux/msrc/utility/vendor_api/ABI/OFX*.dll"
    "exclude:pwiz_aux/msrc/utility/vendor_api/ABI/LicenseKey.h"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Agilent/x*"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Bruker/x*"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Mobilion/*.dll"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Mobilion/*.lib"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Shimadzu/*.dll"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Shimadzu/x*"
    "exclude:pwiz_aux/msrc/utility/vendor_api/thermo/x64"
    "exclude:pwiz_aux/msrc/utility/vendor_api/thermo/x86"
    "exclude:pwiz_aux/msrc/utility/vendor_api/Waters/*_x*"
    "exclude:pwiz_aux/msrc/utility/update"
    "exclude:bootstrap" # boost-build intermediate directories
    "exclude:$(PWIZ_LIBRARIES_PATH)/boost-build/src/engine/bin*"
    "exclude:$(PWIZ_LIBRARIES_PATH)/boost-build/src/engine/bjam*"
    "exclude:$(PWIZ_LIBRARIES_PATH)/boost-build/src/engine/b2*"
;

.pwiz-src-exclusions = $(.common-src-exclusions)
    "exclude:pwiz_tools/BiblioSpec"
    "exclude:pwiz_tools/Skyline"
    "exclude:pwiz_tools/Topograph"
    "exclude:pwiz_tools/Bumbershoot"
    "exclude:pwiz_tools/Shared/BiblioSpec"
    "exclude:pwiz_tools/Shared/Crawdad"
    "exclude:pwiz_tools/Shared/ProteomeDb"
    "exclude:pwiz_tools/Shared/ProteowizardWrapper"
    "exclude:pwiz_tools/Shared/Lib/Microsoft.Diagnostics.Runtime"
    "exclude:pwiz_tools/Shared/Lib/MSAmanda"
    "exclude:pwiz_tools/Shared/Lib/DotNetZip"
    "exclude:pwiz_tools/Shared/Lib/NHibernate"
    "exclude:pwiz_tools/Shared/Lib/npgsql"
    "exclude:pwiz_tools/Shared/Lib/x86"
    "exclude:pwiz_tools/Shared/Lib/x64"
    "exclude:pwiz_tools/Shared/Lib/mysql.*"
    "exclude:pwiz_tools/Shared/Lib/zlib.*"
    "exclude:pwiz_tools/Shared/Lib/*.pdb"
    "exclude:pwiz_tools/Shared/Lib/grpc*"
    "exclude:pwiz_tools/Shared/Lib/log4net*"
    "exclude:pwiz_tools/Shared/Lib/MathNet.Numerics*"
;

# the SUBSET file acts as flag so that building a subset tarball doesn't build a source tarball
make SUBSET : : @make_SUBSET : <location>$(.common-location) ;
actions make_SUBSET
{
@($(STDOUT):E=
This source tree is a subset of the full pwiz source tree.
) > "$(<)"
}

constant .common-sources :
    "path-anchor:$(PWIZ_ROOT_PATH)"
    $(.common-src-exclusions)
    
    $(PWIZ_ROOT_PATH)/Jamroot.jam
    $(PWIZ_ROOT_PATH)/NOTICE
    $(PWIZ_ROOT_PATH)/LICENSE
    $(PWIZ_ROOT_PATH)/quickbuild.bat
    $(PWIZ_ROOT_PATH)/quickbuild.sh
    $(PWIZ_ROOT_PATH)/clean.bat
    $(PWIZ_ROOT_PATH)/clean.sh

    $(PWIZ_ROOT_PATH)/pwiz
    $(PWIZ_ROOT_PATH)/pwiz_aux
    $(PWIZ_ROOT_PATH)/pwiz_tools
    $(PWIZ_ROOT_PATH)/scripts
;

.pwiz-sources = $(.pwiz-src-exclusions) $(.common-sources)
    $(PWIZ_ROOT_PATH)/doc
    $(PWIZ_ROOT_PATH)/example_data

    "path-anchor:$(PWIZ_BUILD_PATH)"
    $(PWIZ_BUILD_PATH)/SUBSET
;

.l = 
    "path-anchor:$(PWIZ_ROOT_PATH)"
    $(PWIZ_LIBRARIES_PATH)/boost-build
    $(PWIZ_LIBRARIES_PATH)/boost_aux
    $(PWIZ_LIBRARIES_PATH)/predef
    $(PWIZ_LIBRARIES_PATH)/libsvm-3.0
    $(PWIZ_LIBRARIES_PATH)/SQLite
    $(PWIZ_LIBRARIES_PATH)/Eigen
    $(PWIZ_LIBRARIES_PATH)/CSpline
    [ path.glob $(PWIZ_LIBRARIES_PATH) : *.bat *.sh *.h *.jam *.dll *.lib *.exe *.cpp libgd*.tar.bz2 libpng*.tar.bz2 freetype*.tar.bz2 zlib*.tar.bz2 hdf5*.tar.bz2 ]

    # include the bcp'd boost tarball as if it was really located at "libraries/boost_*.tar.bz2"
    "path-anchor:$(BOOST_SUBSET_PATH)"
    $(BOOST_SUBSET_PATH)/libraries
;

.no-t = 
    "exclude:*Test*.data*"
    "exclude:*Test.?pp"
    "exclude:*TestData.?pp"
    "exclude:*.pdf # pwiz posters in /doc"
    "exclude:example_data*"
;

.no-v =
    "exclude:vendor_readers/*/*.bat"
    "exclude:vendor_api/ABI"
    "exclude:vendor_api/Agilent"
    "exclude:vendor_api/Bruker"
    "exclude:vendor_api/Mobilion"
    "exclude:vendor_api/Shimadzu"
    "exclude:vendor_api/thermo"
    "exclude:vendor_api/UIMF"
    "exclude:vendor_api/Waters"
    "exclude:vendor_api_*.7z"
;

.common-requirements = <location>$(.common-location) <dependency>boost_$(BOOST_VERSION:J=_).tar.bz2 <dependency>SUBSET <dependency>VERSION ;

# l = without libraries, t = without tests, v = without vendor APIs
tar.create pwiz-src.tar.bz2             : $(.pwiz-sources) $(.l) : $(.common-requirements) <name>pwiz-src-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-l.tar.bz2   : $(.pwiz-sources) : $(.common-requirements) <name>pwiz-src-without-l-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-lt.tar.bz2  : $(.no-t) $(.pwiz-sources) : $(.common-requirements) <name>pwiz-src-without-lt-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-ltv.tar.bz2 : $(.no-t) $(.no-v) $(.pwiz-sources) : $(.common-requirements) <name>pwiz-src-without-ltv-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-lv.tar.bz2  : $(.no-v) $(.pwiz-sources) : $(.common-requirements) <name>pwiz-src-without-lv-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-t.tar.bz2   : $(.no-t) $(.pwiz-sources) $(.l) : $(.common-requirements) <name>pwiz-src-without-t-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-tv.tar.bz2  : $(.no-t) $(.no-v) $(.pwiz-sources) $(.l) : $(.common-requirements) <name>pwiz-src-without-tv-$(version-tag:J=_).tar.bz2 ;
tar.create pwiz-src-without-v.tar.bz2   : $(.no-v) $(.pwiz-sources) $(.l) : $(.common-requirements) <name>pwiz-src-without-v-$(version-tag:J=_).tar.bz2 ;

} # if SUBSET
